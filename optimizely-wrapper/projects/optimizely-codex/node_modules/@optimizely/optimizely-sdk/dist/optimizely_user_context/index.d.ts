/****************************************************************************
 * Copyright 2020-2024, Optimizely, Inc. and contributors                   *
 *                                                                          *
 * Licensed under the Apache License, Version 2.0 (the "License");          *
 * you may not use this file except in compliance with the License.         *
 * You may obtain a copy of the License at                                  *
 *                                                                          *
 *    http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                          *
 * Unless required by applicable law or agreed to in writing, software      *
 * distributed under the License is distributed on an "AS IS" BASIS,        *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 * See the License for the specific language governing permissions and      *
 * limitations under the License.                                           *
 ***************************************************************************/
import Optimizely from '../optimizely';
import { EventTags, OptimizelyDecideOption, OptimizelyDecision, OptimizelyDecisionContext, OptimizelyForcedDecision, UserAttributeValue, UserAttributes } from '../shared_types';
import { OptimizelySegmentOption } from '../core/odp/optimizely_segment_option';
interface OptimizelyUserContextConfig {
    optimizely: Optimizely;
    userId: string;
    attributes?: UserAttributes;
    shouldIdentifyUser?: boolean;
}
export interface IOptimizelyUserContext {
    qualifiedSegments: string[] | null;
    getUserId(): string;
    getAttributes(): UserAttributes;
    setAttribute(key: string, value: unknown): void;
    decide(key: string, options?: OptimizelyDecideOption[]): OptimizelyDecision;
    decideForKeys(keys: string[], options?: OptimizelyDecideOption[]): {
        [key: string]: OptimizelyDecision;
    };
    decideAll(options?: OptimizelyDecideOption[]): {
        [key: string]: OptimizelyDecision;
    };
    trackEvent(eventName: string, eventTags?: EventTags): void;
    setForcedDecision(context: OptimizelyDecisionContext, decision: OptimizelyForcedDecision): boolean;
    getForcedDecision(context: OptimizelyDecisionContext): OptimizelyForcedDecision | null;
    removeForcedDecision(context: OptimizelyDecisionContext): boolean;
    removeAllForcedDecisions(): boolean;
    fetchQualifiedSegments(options?: OptimizelySegmentOption[]): Promise<boolean>;
    isQualifiedFor(segment: string): boolean;
}
export default class OptimizelyUserContext implements IOptimizelyUserContext {
    private optimizely;
    private userId;
    private attributes;
    private forcedDecisionsMap;
    private _qualifiedSegments;
    constructor({ optimizely, userId, attributes, shouldIdentifyUser }: OptimizelyUserContextConfig);
    /**
     * On user context instantiation, fire event to attempt to identify user to ODP.
     * Note: This fails if ODP is not enabled.
     */
    private identifyUser;
    /**
     * Sets an attribute for a given key.
     * @param     {string}                     key         An attribute key
     * @param     {any}                        value       An attribute value
     */
    setAttribute(key: string, value: UserAttributeValue): void;
    getUserId(): string;
    getAttributes(): UserAttributes;
    getOptimizely(): Optimizely;
    get qualifiedSegments(): string[] | null;
    set qualifiedSegments(qualifiedSegments: string[] | null);
    /**
     * Returns a decision result for a given flag key and a user context, which contains all data required to deliver the flag.
     * If the SDK finds an error, it will return a decision with null for variationKey. The decision will include an error message in reasons.
     * @param     {string}                     key         A flag key for which a decision will be made.
     * @param     {OptimizelyDecideOption}     options     An array of options for decision-making.
     * @return    {OptimizelyDecision}                     A decision result.
     */
    decide(key: string, options?: OptimizelyDecideOption[]): OptimizelyDecision;
    /**
     * Returns an object of decision results for multiple flag keys and a user context.
     * If the SDK finds an error for a key, the response will include a decision for the key showing reasons for the error.
     * The SDK will always return key-mapped decisions. When it cannot process requests, it will return an empty map after logging the errors.
     * @param     {string[]}                   keys        An array of flag keys for which decisions will be made.
     * @param     {OptimizelyDecideOption[]}   options     An array of options for decision-making.
     * @return    {[key: string]: OptimizelyDecision}      An object of decision results mapped by flag keys.
     */
    decideForKeys(keys: string[], options?: OptimizelyDecideOption[]): {
        [key: string]: OptimizelyDecision;
    };
    /**
     * Returns an object of decision results for all active flag keys.
     * @param     {OptimizelyDecideOption[]}   options     An array of options for decision-making.
     * @return    {[key: string]: OptimizelyDecision}      An object of all decision results mapped by flag keys.
     */
    decideAll(options?: OptimizelyDecideOption[]): {
        [key: string]: OptimizelyDecision;
    };
    /**
     * Tracks an event.
     * @param     {string}                     eventName The event name.
     * @param     {EventTags}                  eventTags An optional map of event tag names to event tag values.
     */
    trackEvent(eventName: string, eventTags?: EventTags): void;
    /**
     * Sets the forced decision for specified optimizely decision context.
     * @param     {OptimizelyDecisionContext}   context      OptimizelyDecisionContext containing flagKey and optional ruleKey.
     * @param     {OptimizelyForcedDecision}    decision     OptimizelyForcedDecision containing forced variation key.
     * @return    {boolean}                     true if the forced decision has been set successfully.
     */
    setForcedDecision(context: OptimizelyDecisionContext, decision: OptimizelyForcedDecision): boolean;
    /**
     * Returns the forced decision for specified optimizely decision context.
     * @param     {OptimizelyDecisionContext}  context  OptimizelyDecisionContext containing flagKey and optional ruleKey.
     * @return    {OptimizelyForcedDecision|null}       OptimizelyForcedDecision for specified context if exists or null.
     */
    getForcedDecision(context: OptimizelyDecisionContext): OptimizelyForcedDecision | null;
    /**
     * Removes the forced decision for specified optimizely decision context.
     * @param     {OptimizelyDecisionContext}  context  OptimizelyDecisionContext containing flagKey and optional ruleKey.
     * @return    {boolean}                    true if the forced decision has been removed successfully
     */
    removeForcedDecision(context: OptimizelyDecisionContext): boolean;
    /**
     * Removes all forced decisions bound to this user context.
     * @return    {boolean}                    true if the forced decision has been removed successfully
     */
    removeAllForcedDecisions(): boolean;
    /**
     * Finds a forced decision in forcedDecisionsMap for provided optimizely decision context.
     * @param     {OptimizelyDecisionContext}     context  OptimizelyDecisionContext containing flagKey and optional ruleKey.
     * @return    {OptimizelyForcedDecision|null}          OptimizelyForcedDecision for specified context if exists or null.
     */
    private findForcedDecision;
    private cloneUserContext;
    /**
     * Fetches a target user's list of qualified segments filtered by any given segment options and stores in qualifiedSegments.
     * @param {OptimizelySegmentOption[]} options   (Optional) List of segment options used to filter qualified segment results.
     * @returns Boolean representing if segments were populated.
     */
    fetchQualifiedSegments(options?: OptimizelySegmentOption[]): Promise<boolean>;
    /**
     * Returns a boolean representing if a user is qualified for a particular segment.
     * @param   {string}  segment   Target segment to be evaluated for user qualification.
     * @returns {boolean}           Boolean representing if a user qualified for the passed in segment.
     */
    isQualifiedFor(segment: string): boolean;
}
export {};
