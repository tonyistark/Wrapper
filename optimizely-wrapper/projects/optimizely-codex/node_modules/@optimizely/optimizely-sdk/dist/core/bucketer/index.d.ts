/**
 * Copyright 2016, 2019-2022, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { LogHandler } from '../../modules/logging';
import { DecisionResponse, BucketerParams, TrafficAllocation, Group } from '../../shared_types';
/**
 * Determines ID of variation to be shown for the given input params
 * @param  {Object}             bucketerParams
 * @param  {string}             bucketerParams.experimentId
 * @param  {string}             bucketerParams.experimentKey
 * @param  {string}             bucketerParams.userId
 * @param  {Object[]}           bucketerParams.trafficAllocationConfig
 * @param  {Array}              bucketerParams.experimentKeyMap
 * @param  {Object}             bucketerParams.groupIdMap
 * @param  {Object}             bucketerParams.variationIdMap
 * @param  {string}             bucketerParams.varationIdMap[].key
 * @param  {Object}             bucketerParams.logger
 * @param  {string}             bucketerParams.bucketingId
 * @return {Object}             DecisionResponse                         DecisionResponse containing variation ID that user has been bucketed into,
 *                                                                       null if user is not bucketed into any experiment and the decide reasons.
 */
export declare const bucket: (bucketerParams: BucketerParams) => DecisionResponse<string | null>;
/**
 * Returns bucketed experiment ID to compare against experiment user is being called into
 * @param  {Group}       group        Group that experiment is in
 * @param  {string}      bucketingId  Bucketing ID
 * @param  {string}      userId       ID of user to be bucketed into experiment
 * @param  {LogHandler}  logger       Logger implementation
 * @return {string|null}              ID of experiment if user is bucketed into experiment within the group, null otherwise
 */
export declare const bucketUserIntoExperiment: (group: Group, bucketingId: string, userId: string, logger: LogHandler) => string | null;
/**
 * Returns entity ID associated with bucket value
 * @param  {number}                bucketValue
 * @param  {TrafficAllocation[]}   trafficAllocationConfig
 * @param  {number}                trafficAllocationConfig[].endOfRange
 * @param  {string}                trafficAllocationConfig[].entityId
 * @return {string|null}           Entity ID for bucketing if bucket value is within traffic allocation boundaries, null otherwise
 */
export declare const _findBucket: (bucketValue: number, trafficAllocationConfig: TrafficAllocation[]) => string | null;
/**
 * Helper function to generate bucket value in half-closed interval [0, MAX_TRAFFIC_VALUE)
 * @param  {string}               bucketingKey          String value for bucketing
 * @return {number}               The generated bucket value
 * @throws                        If bucketing value is not a valid string
 */
export declare const _generateBucketValue: (bucketingKey: string) => number;
declare const _default: {
    bucket: (bucketerParams: BucketerParams) => DecisionResponse<string | null>;
    bucketUserIntoExperiment: (group: Group, bucketingId: string, userId: string, logger: LogHandler) => string | null;
    _generateBucketValue: (bucketingKey: string) => number;
};
export default _default;
