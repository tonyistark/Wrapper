/**
 * Copyright 2020, 2022, Optimizely
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { LogHandler, ErrorHandler } from '../../modules/logging';
import { NotificationListener, ListenerPayload } from '../../shared_types';
import { NOTIFICATION_TYPES } from '../../utils/enums';
interface NotificationCenterOptions {
    logger: LogHandler;
    errorHandler: ErrorHandler;
}
/**
 * NotificationCenter allows registration and triggering of callback functions using
 * notification event types defined in NOTIFICATION_TYPES of utils/enums/index.js:
 * - ACTIVATE: An impression event will be sent to Optimizely.
 * - TRACK a conversion event will be sent to Optimizely
 */
export declare class NotificationCenter {
    private logger;
    private errorHandler;
    private notificationListeners;
    private listenerId;
    /**
     * @constructor
     * @param   {NotificationCenterOptions}  options
     * @param   {LogHandler}                 options.logger       An instance of a logger to log messages with
     * @param   {ErrorHandler}               options.errorHandler An instance of errorHandler to handle any unexpected error
     */
    constructor(options: NotificationCenterOptions);
    /**
     * Add a notification callback to the notification center
     * @param   {string}                   notificationType     One of the values from NOTIFICATION_TYPES in utils/enums/index.js
     * @param   {NotificationListener<T>}  callback             Function that will be called when the event is triggered
     * @returns {number}                   If the callback was successfully added, returns a listener ID which can be used
     * to remove the callback by calling removeNotificationListener. The ID is a number greater than 0.
     * If there was an error and the listener was not added, addNotificationListener returns -1. This
     * can happen if the first argument is not a valid notification type, or if the same callback
     * function was already added as a listener by a prior call to this function.
     */
    addNotificationListener<T extends ListenerPayload>(notificationType: string, callback: NotificationListener<T>): number;
    /**
     * Remove a previously added notification callback
     * @param   {number}                 listenerId ID of listener to be removed
     * @returns {boolean}                Returns true if the listener was found and removed, and false
     * otherwise.
     */
    removeNotificationListener(listenerId: number): boolean;
    /**
     * Removes all previously added notification listeners, for all notification types
     */
    clearAllNotificationListeners(): void;
    /**
     * Remove all previously added notification listeners for the argument type
     * @param   {NOTIFICATION_TYPES}    notificationType One of NOTIFICATION_TYPES
     */
    clearNotificationListeners(notificationType: NOTIFICATION_TYPES): void;
    /**
     * Fires notifications for the argument type. All registered callbacks for this type will be
     * called. The notificationData object will be passed on to callbacks called.
     * @param {string} notificationType One of NOTIFICATION_TYPES
     * @param {Object} notificationData Will be passed to callbacks called
     */
    sendNotifications<T extends ListenerPayload>(notificationType: string, notificationData?: T): void;
}
/**
 * Create an instance of NotificationCenter
 * @param   {NotificationCenterOptions}   options
 * @returns {NotificationCenter}          An instance of NotificationCenter
 */
export declare function createNotificationCenter(options: NotificationCenterOptions): NotificationCenter;
export interface NotificationSender {
    sendNotifications(notificationType: NOTIFICATION_TYPES, notificationData?: any): void;
}
export {};
