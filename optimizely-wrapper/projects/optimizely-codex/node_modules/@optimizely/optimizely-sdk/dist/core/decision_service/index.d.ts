/****************************************************************************
 * Copyright 2017-2022 Optimizely, Inc. and contributors                    *
 *                                                                          *
 * Licensed under the Apache License, Version 2.0 (the "License");          *
 * you may not use this file except in compliance with the License.         *
 * You may obtain a copy of the License at                                  *
 *                                                                          *
 *    http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                          *
 * Unless required by applicable law or agreed to in writing, software      *
 * distributed under the License is distributed on an "AS IS" BASIS,        *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 * See the License for the specific language governing permissions and      *
 * limitations under the License.                                           *
 ***************************************************************************/
import { LogHandler } from '../../modules/logging';
import { ProjectConfig } from '../project_config';
import { DecisionResponse, Experiment, FeatureFlag, OptimizelyUserContext, UserProfileService, Variation } from '../../shared_types';
export interface DecisionObj {
    experiment: Experiment | null;
    variation: Variation | null;
    decisionSource: string;
}
interface DecisionServiceOptions {
    userProfileService: UserProfileService | null;
    logger: LogHandler;
    UNSTABLE_conditionEvaluators: unknown;
}
interface DeliveryRuleResponse<T, K> extends DecisionResponse<T> {
    skipToEveryoneElse: K;
}
/**
 * Optimizely's decision service that determines which variation of an experiment the user will be allocated to.
 *
 * The decision service contains all logic around how a user decision is made. This includes all of the following (in order):
 *   1. Checking experiment status
 *   2. Checking forced bucketing
 *   3. Checking whitelisting
 *   4. Checking user profile service for past bucketing decisions (sticky bucketing)
 *   5. Checking audience targeting
 *   6. Using Murmurhash3 to bucket the user.
 *
 * @constructor
 * @param   {DecisionServiceOptions}      options
 * @returns {DecisionService}
 */
export declare class DecisionService {
    private logger;
    private audienceEvaluator;
    private forcedVariationMap;
    private userProfileService;
    constructor(options: DecisionServiceOptions);
    /**
     * Gets variation where visitor will be bucketed.
     * @param  {ProjectConfig}                          configObj         The parsed project configuration object
     * @param  {Experiment}                             experiment
     * @param  {OptimizelyUserContext}                  user              A user context
     * @param  {[key: string]: boolean}                 options           Optional map of decide options
     * @return {DecisionResponse<string|null>}          DecisionResponse containing the variation the user is bucketed into
     *                                                                    and the decide reasons.
     */
    getVariation(configObj: ProjectConfig, experiment: Experiment, user: OptimizelyUserContext, options?: {
        [key: string]: boolean;
    }): DecisionResponse<string | null>;
    /**
     * Merges attributes from attributes[STICKY_BUCKETING_KEY] and userProfileService
     * @param  {string}               userId
     * @param  {UserAttributes}       attributes
     * @return {ExperimentBucketMap}  finalized copy of experiment_bucket_map
     */
    private resolveExperimentBucketMap;
    /**
     * Checks whether the experiment is running
     * @param  {ProjectConfig}  configObj     The parsed project configuration object
     * @param  {string}         experimentKey Key of experiment being validated
     * @return {boolean}        True if experiment is running
     */
    private checkIfExperimentIsActive;
    /**
     * Checks if user is whitelisted into any variation and return that variation if so
     * @param  {Experiment}                                 experiment
     * @param  {string}                                     userId
     * @return {DecisionResponse<Variation|null>}           DecisionResponse containing the forced variation if it exists
     *                                                      or user ID and the decide reasons.
     */
    private getWhitelistedVariation;
    /**
     * Checks whether the user is included in experiment audience
     * @param  {ProjectConfig}                configObj            The parsed project configuration object
     * @param  {string}                       experimentKey        Key of experiment being validated
     * @param  {string}                       evaluationAttribute  String representing experiment key or rule
     * @param  {string}                       userId               ID of user
     * @param  {UserAttributes}               attributes           Optional parameter for user's attributes
     * @param  {string}                       loggingKey           String representing experiment key or rollout rule. To be used in log messages only.
     * @return {DecisionResponse<boolean>}    DecisionResponse     DecisionResponse containing result true if user meets audience conditions and
     *                                                             the decide reasons.
     */
    private checkIfUserIsInAudience;
    /**
     * Given an experiment key and user ID, returns params used in bucketer call
     * @param  {ProjectConfig}         configObj     The parsed project configuration object
     * @param  {string}                experimentKey Experiment key used for bucketer
     * @param  {string}                bucketingId   ID to bucket user into
     * @param  {string}                userId        ID of user to be bucketed
     * @return {BucketerParams}
     */
    private buildBucketerParams;
    /**
     * Pull the stored variation out of the experimentBucketMap for an experiment/userId
     * @param  {ProjectConfig}        configObj            The parsed project configuration object
     * @param  {Experiment}           experiment
     * @param  {string}               userId
     * @param  {ExperimentBucketMap}  experimentBucketMap  mapping experiment => { variation_id: <variationId> }
     * @return {Variation|null}       the stored variation or null if the user profile does not have one for the given experiment
     */
    private getStoredVariation;
    /**
     * Get the user profile with the given user ID
     * @param  {string} userId
     * @return {UserProfile|null} the stored user profile or null if one isn't found
     */
    private getUserProfile;
    /**
     * Saves the bucketing decision to the user profile
     * @param {Experiment}          experiment
     * @param {Variation}           variation
     * @param {string}              userId
     * @param {ExperimentBucketMap} experimentBucketMap
     */
    private saveUserProfile;
    /**
     * Given a feature, user ID, and attributes, returns a decision response containing
     * an object representing a decision and decide reasons. If the user was bucketed into
     * a variation for the given feature and attributes, the decision object will have variation and
     * experiment properties (both objects), as well as a decisionSource property.
     * decisionSource indicates whether the decision was due to a rollout or an
     * experiment.
     * @param   {ProjectConfig}               configObj         The parsed project configuration object
     * @param   {FeatureFlag}                 feature           A feature flag object from project configuration
     * @param   {OptimizelyUserContext}       user              A user context
     * @param   {[key: string]: boolean}      options           Map of decide options
     * @return  {DecisionResponse}            DecisionResponse  DecisionResponse containing an object with experiment, variation, and decisionSource
     *                                                          properties and decide reasons. If the user was not bucketed into a variation, the variation
     *                                                          property in decision object is null.
     */
    getVariationForFeature(configObj: ProjectConfig, feature: FeatureFlag, user: OptimizelyUserContext, options?: {
        [key: string]: boolean;
    }): DecisionResponse<DecisionObj>;
    private getVariationForFeatureExperiment;
    private getVariationForRollout;
    /**
     * Get bucketing Id from user attributes.
     * @param   {string}          userId
     * @param   {UserAttributes}  attributes
     * @returns {string}          Bucketing Id if it is a string type in attributes, user Id otherwise.
     */
    private getBucketingId;
    /**
     * Finds a validated forced decision for specific flagKey and optional ruleKey.
     * @param     {ProjectConfig}         config               A projectConfig.
     * @param     {OptimizelyUserContext} user                 A Optimizely User Context.
     * @param     {string}                flagKey              A flagKey.
     * @param     {ruleKey}               ruleKey              A ruleKey (optional).
     * @return    {DecisionResponse<Variation|null>}  DecisionResponse object containing valid variation object and decide reasons.
     */
    findValidatedForcedDecision(config: ProjectConfig, user: OptimizelyUserContext, flagKey: string, ruleKey?: string): DecisionResponse<Variation | null>;
    /**
     * Removes forced variation for given userId and experimentKey
     * @param  {string} userId         String representing the user id
     * @param  {string} experimentId   Number representing the experiment id
     * @param  {string} experimentKey  Key representing the experiment id
     * @throws If the user id is not valid or not in the forced variation map
     */
    removeForcedVariation(userId: string, experimentId: string, experimentKey: string): void;
    /**
     * Sets forced variation for given userId and experimentKey
     * @param  {string} userId        String representing the user id
     * @param  {string} experimentId  Number representing the experiment id
     * @param  {number} variationId   Number representing the variation id
     * @throws If the user id is not valid
     */
    private setInForcedVariationMap;
    /**
     * Gets the forced variation key for the given user and experiment.
     * @param  {ProjectConfig}                  configObj         Object representing project configuration
     * @param  {string}                         experimentKey     Key for experiment.
     * @param  {string}                         userId            The user Id.
     * @return {DecisionResponse<string|null>}                    DecisionResponse containing variation which the given user and experiment
     *                                                            should be forced into and the decide reasons.
     */
    getForcedVariation(configObj: ProjectConfig, experimentKey: string, userId: string): DecisionResponse<string | null>;
    /**
     * Sets the forced variation for a user in a given experiment
     * @param  {ProjectConfig}  configObj      Object representing project configuration
     * @param  {string}         experimentKey  Key for experiment.
     * @param  {string}         userId         The user Id.
     * @param  {string|null}    variationKey   Key for variation. If null, then clear the existing experiment-to-variation mapping
     * @return {boolean}     A boolean value that indicates if the set completed successfully.
     */
    setForcedVariation(configObj: ProjectConfig, experimentKey: string, userId: string, variationKey: string | null): boolean;
    getVariationFromExperimentRule(configObj: ProjectConfig, flagKey: string, rule: Experiment, user: OptimizelyUserContext, options?: {
        [key: string]: boolean;
    }): DecisionResponse<string | null>;
    getVariationFromDeliveryRule(configObj: ProjectConfig, flagKey: string, rules: Experiment[], ruleIndex: number, user: OptimizelyUserContext): DeliveryRuleResponse<Variation | null, boolean>;
}
/**
 * Creates an instance of the DecisionService.
 * @param  {DecisionServiceOptions}     options       Configuration options
 * @return {Object}                     An instance of the DecisionService
 */
export declare function createDecisionService(options: DecisionServiceOptions): DecisionService;
export {};
