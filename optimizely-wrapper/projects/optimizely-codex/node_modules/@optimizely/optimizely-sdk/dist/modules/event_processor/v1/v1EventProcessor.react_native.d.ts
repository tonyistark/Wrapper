import { NotificationSender } from '../../../core/notification_center';
import { EventProcessor, ProcessableEvent } from "../eventProcessor";
import { EventQueue } from '../eventQueue';
import { EventDispatcher } from '../eventDispatcher';
import { PersistentCacheProvider } from '../../../shared_types';
/**
 * React Native Events Processor with Caching support for events when app is offline.
 */
export declare class LogTierV1EventProcessor implements EventProcessor {
    private dispatcher;
    queue: EventQueue<ProcessableEvent>;
    private notificationSender?;
    private requestTracker;
    private unsubscribeNetInfo;
    private isInternetReachable;
    private pendingEventsPromise;
    private synchronizer;
    private shouldSkipDispatchToPreserveSequence;
    /**
     * This Stores Formatted events before dispatching. The events are removed after they are successfully dispatched.
     * Stored events are retried on every new event dispatch, when connection becomes available again or when SDK initializes the next time.
     */
    private pendingEventsStore;
    /**
     * This stores individual events generated from the SDK till they are part of the pending buffer.
     * The store is cleared right before the event is formatted to be dispatched.
     * This is to make sure that individual events are not lost when app closes before the buffer was flushed.
     */
    private eventBufferStore;
    constructor({ dispatcher, flushInterval, batchSize, maxQueueSize, notificationCenter, persistentCacheProvider, }: {
        dispatcher: EventDispatcher;
        flushInterval?: number;
        batchSize?: number;
        maxQueueSize?: number;
        notificationCenter?: NotificationSender;
        persistentCacheProvider?: PersistentCacheProvider;
    });
    private connectionListener;
    private isSuccessResponse;
    private drainQueue;
    private processPendingEvents;
    private getPendingEventsPromise;
    private dispatchEvent;
    start(): Promise<void>;
    process(event: ProcessableEvent): void;
    stop(): Promise<void>;
}
