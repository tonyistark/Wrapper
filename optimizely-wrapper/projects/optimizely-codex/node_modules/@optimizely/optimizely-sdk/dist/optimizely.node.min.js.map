{"version":3,"file":"optimizely.node.min.js","sources":["../node_modules/tslib/tslib.es6.js","../lib/modules/logging/models.ts","../lib/modules/logging/errorHandler.ts","../lib/utils/fns/index.ts","../lib/modules/logging/logger.ts","../lib/core/odp/odp_event.ts","../lib/core/odp/optimizely_segment_option.ts","../lib/shared_types.ts","../lib/optimizely_decision/index.ts","../lib/utils/enums/index.ts","../lib/optimizely_user_context/index.ts","../lib/core/condition_tree_evaluator/index.ts","../lib/core/optimizely_config/index.ts","../lib/utils/config_validator/index.ts","../lib/core/odp/odp_config.ts","../lib/core/project_config/index.ts","../lib/utils/microtask/index.ts","../lib/core/project_config/project_config_manager.ts","../lib/core/bucketer/index.ts","../lib/utils/semantic_version/index.ts","../lib/core/custom_attribute_condition_evaluator/index.ts","../lib/core/audience_evaluator/odp_segment_condition_evaluator/index.ts","../lib/core/audience_evaluator/index.ts","../lib/utils/string_value_validator/index.ts","../lib/core/decision_service/index.ts","../lib/utils/event_tag_utils/index.ts","../lib/utils/attributes_validator/index.ts","../lib/core/event_builder/index.ts","../lib/core/decision/index.ts","../lib/core/event_builder/event_helpers.ts","../lib/core/notification_center/index.ts","../lib/core/notification_center/notification_registry.ts","../lib/utils/user_profile_service_validator/index.ts","../lib/optimizely/index.ts","../lib/utils/event_tags_validator/index.ts","../lib/plugins/logger/index.ts","../lib/plugins/error_handler/index.ts","../lib/plugins/event_dispatcher/index.node.ts","../lib/utils/event_processor_config_validator/index.ts","../lib/modules/event_processor/events.ts","../lib/modules/event_processor/eventQueue.ts","../lib/modules/event_processor/eventProcessor.ts","../lib/modules/event_processor/pendingEventsStore.ts","../lib/modules/event_processor/pendingEventsDispatcher.ts","../lib/modules/event_processor/v1/buildEventV1.ts","../lib/modules/event_processor/requestTracker.ts","../lib/modules/event_processor/v1/v1EventProcessor.ts","../lib/modules/datafile-manager/config.ts","../lib/modules/datafile-manager/nodeRequest.ts","../lib/modules/datafile-manager/eventEmitter.ts","../lib/modules/datafile-manager/backoffController.ts","../lib/modules/datafile-manager/httpPollingDatafileManager.ts","../lib/modules/datafile-manager/nodeDatafileManager.ts","../lib/modules/datafile-manager/index.node.ts","../lib/plugins/datafile_manager/http_polling_datafile_manager.ts","../lib/utils/http_request_handler/node_request_handler.ts","../lib/utils/lru_cache/cache_element.ts","../lib/utils/lru_cache/lru_cache.ts","../lib/utils/lru_cache/server_lru_cache.ts","../lib/plugins/vuid_manager/index.ts","../lib/core/odp/odp_utils.ts","../lib/utils/promise/resolvablePromise.ts","../lib/core/odp/odp_manager.ts","../lib/core/odp/odp_event_manager.ts","../lib/plugins/odp/event_api_manager/index.node.ts","../lib/core/odp/odp_event_api_manager.ts","../lib/plugins/odp/event_manager/index.node.ts","../lib/core/odp/odp_segment_manager.ts","../lib/core/project_config/project_config_schema.ts","../lib/core/odp/odp_response_schema.ts","../lib/core/odp/odp_segment_api_manager.ts","../lib/utils/json_schema_validator/index.ts","../lib/plugins/odp_manager/index.node.ts","../lib/index.node.ts","../lib/plugins/event_processor/index.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","/**\n * Copyright 2019, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum LogLevel {\n  NOTSET = 0,\n  DEBUG = 1,\n  INFO = 2,\n  WARNING = 3,\n  ERROR = 4,\n}\n\nexport interface LoggerFacade {\n  log(level: LogLevel | string, message: string, ...splat: any[]): void\n\n  info(message: string | Error, ...splat: any[]): void\n\n  debug(message: string | Error, ...splat: any[]): void\n\n  warn(message: string | Error, ...splat: any[]): void\n\n  error(message: string | Error, ...splat: any[]): void\n}\n\nexport interface LogManager {\n  getLogger(name?: string): LoggerFacade\n}\n\nexport interface LogHandler {\n  log(level: LogLevel, message: string, ...splat: any[]): void\n}\n","/**\n * Copyright 2019, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @export\n * @interface ErrorHandler\n */\nexport interface ErrorHandler {\n  /**\n   * @param {Error} exception\n   * @memberof ErrorHandler\n   */\n  handleError(exception: Error): void\n}\n\n/**\n * @export\n * @class NoopErrorHandler\n * @implements {ErrorHandler}\n */\nexport class NoopErrorHandler implements ErrorHandler {\n  /**\n   * @param {Error} exception\n   * @memberof NoopErrorHandler\n   */\n  handleError(exception: Error): void {\n    // no-op\n    return\n  }\n}\n\nlet globalErrorHandler: ErrorHandler = new NoopErrorHandler()\n\n/**\n * @export\n * @param {ErrorHandler} handler\n */\nexport function setErrorHandler(handler: ErrorHandler): void {\n  globalErrorHandler = handler\n}\n\n/**\n * @export\n * @returns {ErrorHandler}\n */\nexport function getErrorHandler(): ErrorHandler {\n  return globalErrorHandler\n}\n\n/**\n * @export\n */\nexport function resetErrorHandler(): void {\n  globalErrorHandler = new NoopErrorHandler()\n}\n","/**\n * Copyright 2017, 2019-2020, 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { v4 } from 'uuid';\n\nconst MAX_SAFE_INTEGER_LIMIT = Math.pow(2, 53);\n\n// eslint-disable-next-line\nexport function assign(target: any, ...sources: any[]): any {\n  if (!target) {\n    return {};\n  }\n  if (typeof Object.assign === 'function') {\n    return Object.assign(target, ...sources);\n  } else {\n    const to = Object(target);\n    for (let index = 0; index < sources.length; index++) {\n      const nextSource = sources[index];\n      if (nextSource !== null && nextSource !== undefined) {\n        for (const nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  }\n}\n\nfunction currentTimestamp(): number {\n  return Math.round(new Date().getTime());\n}\n\nfunction isSafeInteger(number: unknown): boolean {\n  return typeof number == 'number' && Math.abs(number) <= MAX_SAFE_INTEGER_LIMIT;\n}\n\nexport function keyBy<K>(arr: K[], key: string): { [key: string]: K } {\n  if (!arr) return {};\n  return keyByUtil(arr, function(item) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (item as any)[key];\n  });\n}\n\nfunction isNumber(value: unknown): boolean {\n  return typeof value === 'number';\n}\n\nexport function uuid(): string {\n  return v4();\n}\n\nexport type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\n\nexport function getTimestamp(): number {\n  return new Date().getTime();\n}\n\n/**\n * Validates a value is a valid TypeScript enum\n *\n * @export\n * @param {object} enumToCheck\n * @param {*} value\n * @returns {boolean}\n */\n// TODO[OASIS-6649]: Don't use any type\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nexport function isValidEnum(enumToCheck: { [key: string]: any }, value: number | string): boolean {\n  let found = false;\n\n  const keys = Object.keys(enumToCheck);\n  for (let index = 0; index < keys.length; index++) {\n    if (value === enumToCheck[keys[index]]) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n}\n\nexport function groupBy<K>(arr: K[], grouperFn: (item: K) => string): Array<K[]> {\n  const grouper: { [key: string]: K[] } = {};\n\n  arr.forEach(item => {\n    const key = grouperFn(item);\n    grouper[key] = grouper[key] || [];\n    grouper[key].push(item);\n  });\n\n  return objectValues(grouper);\n}\n\nexport function objectValues<K>(obj: { [key: string]: K }): K[] {\n  return Object.keys(obj).map(key => obj[key]);\n}\n\nexport function objectEntries<K>(obj: { [key: string]: K }): [string, K][] {\n  return Object.keys(obj).map(key => [key, obj[key]]);\n}\n\nexport function find<K>(arr: K[], cond: (arg: K) => boolean): K | undefined {\n  let found;\n\n  for (const item of arr) {\n    if (cond(item)) {\n      found = item;\n      break;\n    }\n  }\n\n  return found;\n}\n\nexport function keyByUtil<K>(arr: K[], keyByFn: (item: K) => string): { [key: string]: K } {\n  const map: { [key: string]: K } = {};\n  arr.forEach(item => {\n    const key = keyByFn(item);\n    map[key] = item;\n  });\n  return map;\n}\n\n// TODO[OASIS-6649]: Don't use any type\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nexport function sprintf(format: string, ...args: any[]): string {\n  let i = 0;\n  return format.replace(/%s/g, function() {\n    const arg = args[i++];\n    const type = typeof arg;\n    if (type === 'function') {\n      return arg();\n    } else if (type === 'string') {\n      return arg;\n    } else {\n      return String(arg);\n    }\n  });\n}\n\n/**\n * Checks two string arrays for equality.\n * @param arrayA First Array to be compared against.\n * @param arrayB Second Array to be compared against.\n * @returns {boolean} True if both arrays are equal, otherwise returns false.\n */\nexport function checkArrayEquality(arrayA: string[], arrayB: string[]): boolean {\n  return arrayA.length === arrayB.length && arrayA.every((item, index) => item === arrayB[index]);\n}\n\nexport default {\n  assign,\n  checkArrayEquality,\n  currentTimestamp,\n  isSafeInteger,\n  keyBy,\n  uuid,\n  isNumber,\n  getTimestamp,\n  isValidEnum,\n  groupBy,\n  objectValues,\n  objectEntries,\n  find,\n  keyByUtil,\n  sprintf,\n};\n","/**\n * Copyright 2019, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getErrorHandler } from './errorHandler'\nimport { isValidEnum, sprintf } from '../../utils/fns'\n\nimport { LogLevel, LoggerFacade, LogManager, LogHandler } from './models'\n\ntype StringToLogLevel = {\n  NOTSET: number,\n  DEBUG: number,\n  INFO: number,\n  WARNING: number,\n  ERROR: number,\n}\n\nconst stringToLogLevel: StringToLogLevel = {\n  NOTSET: 0,\n  DEBUG: 1,\n  INFO: 2,\n  WARNING: 3,\n  ERROR: 4,\n}\n\nfunction coerceLogLevel(level: any): LogLevel {\n  if (typeof level !== 'string') {\n    return level\n  }\n\n  level = level.toUpperCase()\n  if (level === 'WARN') {\n    level = 'WARNING'\n  }\n\n  if (!stringToLogLevel[level as keyof StringToLogLevel]) {\n    return level\n  }\n\n  return stringToLogLevel[level as keyof StringToLogLevel]\n}\n\ntype LogData = {\n  message: string\n  splat: any[]\n  error?: Error\n}\n\nclass DefaultLogManager implements LogManager {\n  private loggers: {\n    [name: string]: LoggerFacade\n  }\n  private defaultLoggerFacade = new OptimizelyLogger()\n\n  constructor() {\n    this.loggers = {}\n  }\n\n  getLogger(name?: string): LoggerFacade {\n    if (!name) {\n      return this.defaultLoggerFacade\n    }\n\n    if (!this.loggers[name]) {\n      this.loggers[name] = new OptimizelyLogger({ messagePrefix: name })\n    }\n\n    return this.loggers[name]\n  }\n}\n\ntype ConsoleLogHandlerConfig = {\n  logLevel?: LogLevel | string\n  logToConsole?: boolean\n  prefix?: string\n}\n\nexport class ConsoleLogHandler implements LogHandler {\n  public logLevel: LogLevel\n  private logToConsole: boolean\n  private prefix: string\n\n  /**\n   * Creates an instance of ConsoleLogger.\n   * @param {ConsoleLogHandlerConfig} config\n   * @memberof ConsoleLogger\n   */\n  constructor(config: ConsoleLogHandlerConfig = {}) {\n    this.logLevel = LogLevel.NOTSET\n    if (config.logLevel !== undefined && isValidEnum(LogLevel, config.logLevel)) {\n      this.setLogLevel(config.logLevel)\n    }\n\n    this.logToConsole = config.logToConsole !== undefined ? !!config.logToConsole : true\n    this.prefix = config.prefix !== undefined ? config.prefix : '[OPTIMIZELY]'\n  }\n\n  /**\n   * @param {LogLevel} level\n   * @param {string} message\n   * @memberof ConsoleLogger\n   */\n  log(level: LogLevel, message: string) : void {\n    if (!this.shouldLog(level) || !this.logToConsole) {\n      return\n    }\n\n    const logMessage = `${this.prefix} - ${this.getLogLevelName(\n      level,\n    )} ${this.getTime()} ${message}`\n\n    this.consoleLog(level, [logMessage])\n  }\n\n  /**\n   * @param {LogLevel} level\n   * @memberof ConsoleLogger\n   */\n  setLogLevel(level: LogLevel | string) : void {\n    level = coerceLogLevel(level)\n    if (!isValidEnum(LogLevel, level) || level === undefined) {\n      this.logLevel = LogLevel.ERROR\n    } else {\n      this.logLevel = level\n    }\n  }\n\n  /**\n   * @returns {string}\n   * @memberof ConsoleLogger\n   */\n  getTime(): string {\n    return new Date().toISOString()\n  }\n\n  /**\n   * @private\n   * @param {LogLevel} targetLogLevel\n   * @returns {boolean}\n   * @memberof ConsoleLogger\n   */\n  private shouldLog(targetLogLevel: LogLevel): boolean {\n    return targetLogLevel >= this.logLevel\n  }\n\n  /**\n   * @private\n   * @param {LogLevel} logLevel\n   * @returns {string}\n   * @memberof ConsoleLogger\n   */\n  private getLogLevelName(logLevel: LogLevel): string {\n    switch (logLevel) {\n      case LogLevel.DEBUG:\n        return 'DEBUG'\n      case LogLevel.INFO:\n        return 'INFO '\n      case LogLevel.WARNING:\n        return 'WARN '\n      case LogLevel.ERROR:\n        return 'ERROR'\n      default:\n        return 'NOTSET'\n    }\n  }\n\n  /**\n   * @private\n   * @param {LogLevel} logLevel\n   * @param {string[]} logArguments\n   * @memberof ConsoleLogger\n   */\n  private consoleLog(logLevel: LogLevel, logArguments: [string, ...string[]]) {\n    switch (logLevel) {\n      case LogLevel.DEBUG:\n        console.log(...logArguments)\n        break\n      case LogLevel.INFO:\n        console.info(...logArguments)\n        break\n      case LogLevel.WARNING:\n        console.warn(...logArguments)\n        break\n      case LogLevel.ERROR:\n        console.error(...logArguments)\n        break\n      default:\n        console.log(...logArguments)\n    }\n  }\n}\n\nlet globalLogLevel: LogLevel = LogLevel.NOTSET\nlet globalLogHandler: LogHandler | null = null\n\nclass OptimizelyLogger implements LoggerFacade {\n  private messagePrefix = ''\n\n  constructor(opts: { messagePrefix?: string } = {}) {\n    if (opts.messagePrefix) {\n      this.messagePrefix = opts.messagePrefix\n    }\n  }\n\n  /**\n   * @param {(LogLevel | LogInputObject)} levelOrObj\n   * @param {string} [message]\n   * @memberof OptimizelyLogger\n   */\n  log(level: LogLevel | string, message: string, ...splat: any[]): void {\n    this.internalLog(coerceLogLevel(level), {\n      message,\n      splat,\n    })\n  }\n\n  info(message: string | Error, ...splat: any[]): void {\n    this.namedLog(LogLevel.INFO, message, splat)\n  }\n\n  debug(message: string | Error, ...splat: any[]): void {\n    this.namedLog(LogLevel.DEBUG, message, splat)\n  }\n\n  warn(message: string | Error, ...splat: any[]): void {\n    this.namedLog(LogLevel.WARNING, message, splat)\n  }\n\n  error(message: string | Error, ...splat: any[]): void {\n    this.namedLog(LogLevel.ERROR, message, splat)\n  }\n\n  private format(data: LogData): string {\n    return `${this.messagePrefix ? this.messagePrefix + ': ' : ''}${sprintf(\n      data.message,\n      ...data.splat,\n    )}`\n  }\n\n  private internalLog(level: LogLevel, data: LogData): void {\n    if (!globalLogHandler) {\n      return\n    }\n\n    if (level < globalLogLevel) {\n      return\n    }\n\n    globalLogHandler.log(level, this.format(data))\n\n    if (data.error && data.error instanceof Error) {\n      getErrorHandler().handleError(data.error)\n    }\n  }\n\n  private namedLog(level: LogLevel, message: string | Error, splat: any[]): void {\n    let error: Error | undefined\n\n    if (message instanceof Error) {\n      error = message\n      message = error.message\n      this.internalLog(level, {\n        error,\n        message,\n        splat,\n      })\n      return\n    }\n\n    if (splat.length === 0) {\n      this.internalLog(level, {\n        message,\n        splat,\n      })\n      return\n    }\n\n    const last = splat[splat.length - 1]\n    if (last instanceof Error) {\n      error = last\n      splat.splice(-1)\n    }\n\n    this.internalLog(level, { message, error, splat })\n  }\n}\n\nlet globalLogManager: LogManager = new DefaultLogManager()\n\nexport function getLogger(name?: string): LoggerFacade {\n  return globalLogManager.getLogger(name)\n}\n\nexport function setLogHandler(logger: LogHandler | null) : void {\n  globalLogHandler = logger\n}\n\nexport function setLogLevel(level: LogLevel | string) : void {\n  level = coerceLogLevel(level)\n  if (!isValidEnum(LogLevel, level) || level === undefined) {\n    globalLogLevel = LogLevel.ERROR\n  } else {\n    globalLogLevel = level\n  }\n}\n\nexport function getLogLevel(): LogLevel {\n  return globalLogLevel\n}\n\n/**\n * Resets all global logger state to it's original\n */\nexport function resetLogger() : void {\n  globalLogManager = new DefaultLogManager()\n  globalLogLevel = LogLevel.NOTSET\n}\n\nexport default {\n  setLogLevel: setLogLevel,\n  setLogHandler: setLogHandler\n}\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class OdpEvent {\n  /**\n   * Type of event (typically \"fullstack\")\n   */\n  type: string;\n\n  /**\n   * Subcategory of the event type\n   */\n  action: string;\n\n  /**\n   * Key-value map of user identifiers\n   */\n  identifiers: Map<string, string>;\n\n  /**\n   * Event data in a key-value map\n   */\n  data: Map<string, unknown>;\n\n  /**\n   * Event to be sent and stored in the Optimizely Data Platform\n   * @param type Type of event (typically \"fullstack\")\n   * @param action Subcategory of the event type\n   * @param identifiers Key-value map of user identifiers\n   * @param data Event data in a key-value map.\n   */\n  constructor(type: string, action: string, identifiers?: Map<string, string>, data?: Map<string, unknown>) {\n    this.type = type;\n    this.action = action;\n    this.identifiers = identifiers ?? new Map<string, string>();\n    this.data = data ?? new Map<string, unknown>();\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Options for defining behavior of OdpSegmentManager's caching mechanism when calling fetchSegments()\nexport enum OptimizelySegmentOption {\n  IGNORE_CACHE = 'IGNORE_CACHE',\n  RESET_CACHE = 'RESET_CACHE',\n}\n","/**\n * Copyright 2020-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This file contains the shared type definitions collected from the SDK.\n * These shared type definitions include ones that will be referenced by external consumers via export_types.ts.\n */\n\nimport { ErrorHandler, LogHandler, LogLevel, LoggerFacade } from './modules/logging';\nimport { EventProcessor } from './modules/event_processor';\n\nimport { NotificationCenter as NotificationCenterImpl } from './core/notification_center';\nimport { NOTIFICATION_TYPES } from './utils/enums';\n\nimport { IOptimizelyUserContext as OptimizelyUserContext } from './optimizely_user_context';\n\nimport { ICache } from './utils/lru_cache';\nimport { RequestHandler } from './utils/http_request_handler/http';\nimport { OptimizelySegmentOption } from './core/odp/optimizely_segment_option';\nimport { IOdpSegmentApiManager } from './core/odp/odp_segment_api_manager';\nimport { IOdpSegmentManager } from './core/odp/odp_segment_manager';\nimport { IOdpEventApiManager } from './core/odp/odp_event_api_manager';\nimport { IOdpEventManager } from './core/odp/odp_event_manager';\nimport { IOdpManager } from './core/odp/odp_manager';\nimport { IUserAgentParser } from './core/odp/user_agent_parser';\nimport PersistentCache from './plugins/key_value_cache/persistentKeyValueCache';\nimport { ProjectConfig } from './core/project_config';\n\nexport interface BucketerParams {\n  experimentId: string;\n  experimentKey: string;\n  userId: string;\n  trafficAllocationConfig: TrafficAllocation[];\n  experimentKeyMap: { [key: string]: Experiment };\n  experimentIdMap: { [id: string]: Experiment };\n  groupIdMap: { [key: string]: Group };\n  variationIdMap: { [id: string]: Variation };\n  logger: LogHandler;\n  bucketingId: string;\n}\n\nexport interface DecisionResponse<T> {\n  readonly result: T;\n  readonly reasons: (string | number)[][];\n}\n\nexport type UserAttributeValue = string | number | boolean | null;\n\nexport type UserAttributes = {\n  [name: string]: UserAttributeValue;\n};\n\nexport interface ExperimentBucketMap {\n  [experiment_id: string]: { variation_id: string };\n}\n\n// Information about past bucketing decisions for a user.\nexport interface UserProfile {\n  user_id: string;\n  experiment_bucket_map: ExperimentBucketMap;\n}\n\nexport type EventTags = {\n  [key: string]: string | number | null;\n};\n\nexport interface UserProfileService {\n  lookup(userId: string): UserProfile;\n  save(profile: UserProfile): void;\n}\n\nexport interface DatafileManagerConfig {\n  sdkKey: string;\n  datafile?: string;\n}\n\nexport interface DatafileOptions {\n  autoUpdate?: boolean;\n  updateInterval?: number;\n  urlTemplate?: string;\n  datafileAccessToken?: string;\n}\n\nexport interface OdpOptions {\n  disabled?: boolean;\n  segmentsCache?: ICache<string, string[]>;\n  segmentsCacheSize?: number;\n  segmentsCacheTimeout?: number;\n  segmentsApiTimeout?: number;\n  segmentsRequestHandler?: RequestHandler;\n  segmentManager?: IOdpSegmentManager;\n  eventFlushInterval?: number;\n  eventBatchSize?: number;\n  eventQueueSize?: number;\n  eventApiTimeout?: number;\n  eventRequestHandler?: RequestHandler;\n  eventManager?: IOdpEventManager;\n  userAgentParser?: IUserAgentParser;\n}\n\nexport interface ListenerPayload {\n  userId: string;\n  attributes?: UserAttributes;\n}\n\nexport type NotificationListener<T extends ListenerPayload> = (notificationData: T) => void;\n\n// NotificationCenter-related types\nexport interface NotificationCenter {\n  addNotificationListener<T extends ListenerPayload>(\n    notificationType: string,\n    callback: NotificationListener<T>\n  ): number;\n  removeNotificationListener(listenerId: number): boolean;\n  clearAllNotificationListeners(): void;\n  clearNotificationListeners(notificationType: NOTIFICATION_TYPES): void;\n}\n\n// An event to be submitted to Optimizely, enabling tracking the reach and impact of\n// tests and feature rollouts.\nexport interface Event {\n  // URL to which to send the HTTP request.\n  url: string;\n  // HTTP method with which to send the event.\n  httpVerb: 'POST';\n  // Value to send in the request body, JSON-serialized.\n  // TODO[OASIS-6649]: Don't use any type\n  // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n  params: any;\n}\n\nexport interface EventDispatcher {\n  /**\n   * @param event\n   *        Event being submitted for eventual dispatch.\n   * @param callback\n   *        After the event has at least been queued for dispatch, call this function to return\n   *        control back to the Client.\n   */\n  dispatchEvent: (event: Event, callback: (response: { statusCode: number }) => void) => void;\n}\n\nexport interface VariationVariable {\n  id: string;\n  value: string;\n}\n\nexport interface Variation {\n  id: string;\n  key: string;\n  featureEnabled?: boolean;\n  variablesMap: OptimizelyVariablesMap;\n  variables?: VariationVariable[];\n}\n\nexport interface Experiment {\n  id: string;\n  key: string;\n  variations: Variation[];\n  variationKeyMap: { [key: string]: Variation };\n  groupId?: string;\n  layerId: string;\n  status: string;\n  audienceConditions: Array<string | string[]>;\n  audienceIds: string[];\n  trafficAllocation: TrafficAllocation[];\n  forcedVariations?: { [key: string]: string };\n}\n\nexport enum VariableType {\n  BOOLEAN = 'boolean',\n  DOUBLE = 'double',\n  INTEGER = 'integer',\n  STRING = 'string',\n  JSON = 'json',\n}\n\nexport interface FeatureVariable {\n  type: VariableType;\n  key: string;\n  id: string;\n  defaultValue: string;\n  subType?: string;\n}\n\nexport interface FeatureFlag {\n  rolloutId: string;\n  key: string;\n  id: string;\n  experimentIds: string[];\n  variables: FeatureVariable[];\n  variableKeyMap: { [key: string]: FeatureVariable };\n  groupId?: string;\n}\n\nexport type Condition = {\n  name: string;\n  type: string;\n  match?: string;\n  value: string | number | boolean | null;\n};\n\nexport interface Audience {\n  id: string;\n  name: string;\n  conditions: unknown[] | string;\n}\n\nexport interface Integration {\n  key: string;\n  host?: string;\n  publicKey?: string;\n  pixelUrl?: string;\n}\n\nexport interface TrafficAllocation {\n  entityId: string;\n  endOfRange: number;\n}\n\nexport interface Group {\n  id: string;\n  policy: string;\n  trafficAllocation: TrafficAllocation[];\n  experiments: Experiment[];\n}\n\nexport interface TrafficAllocation {\n  entityId: string;\n  endOfRange: number;\n}\n\nexport interface Group {\n  id: string;\n  policy: string;\n  trafficAllocation: TrafficAllocation[];\n  experiments: Experiment[];\n}\n\nexport interface FeatureKeyMap {\n  [key: string]: FeatureFlag;\n}\n\nexport interface OnReadyResult {\n  success: boolean;\n  reason?: string;\n}\n\nexport type ObjectWithUnknownProperties = {\n  [key: string]: unknown;\n};\n\nexport interface Rollout {\n  id: string;\n  experiments: Experiment[];\n}\n\n//TODO: Move OptimizelyDecideOption to @optimizely/optimizely-sdk/lib/utils/enums\nexport enum OptimizelyDecideOption {\n  DISABLE_DECISION_EVENT = 'DISABLE_DECISION_EVENT',\n  ENABLED_FLAGS_ONLY = 'ENABLED_FLAGS_ONLY',\n  IGNORE_USER_PROFILE_SERVICE = 'IGNORE_USER_PROFILE_SERVICE',\n  INCLUDE_REASONS = 'INCLUDE_REASONS',\n  EXCLUDE_VARIABLES = 'EXCLUDE_VARIABLES',\n}\n\n/**\n * options required to create optimizely object\n */\nexport interface OptimizelyOptions {\n  UNSTABLE_conditionEvaluators?: unknown;\n  clientEngine: string;\n  clientVersion?: string;\n  // TODO[OASIS-6649]: Don't use object type\n  // eslint-disable-next-line  @typescript-eslint/ban-types\n  datafile?: string | object;\n  datafileManager?: DatafileManager;\n  errorHandler: ErrorHandler;\n  eventProcessor: EventProcessor;\n  isValidInstance: boolean;\n  jsonSchemaValidator?: {\n    validate(jsonObject: unknown): boolean;\n  };\n  logger: LoggerFacade;\n  sdkKey?: string;\n  userProfileService?: UserProfileService | null;\n  defaultDecideOptions?: OptimizelyDecideOption[];\n  odpManager?: IOdpManager;\n  notificationCenter: NotificationCenterImpl;\n}\n\n/**\n * Optimizely Config Entities\n */\nexport interface OptimizelyExperiment {\n  id: string;\n  key: string;\n  audiences: string;\n  variationsMap: {\n    [variationKey: string]: OptimizelyVariation;\n  };\n}\n\nexport type FeatureVariableValue = number | string | boolean | object | null;\n\nexport interface OptimizelyVariable {\n  id: string;\n  key: string;\n  type: string;\n  value: string;\n}\n\nexport interface Client {\n  // TODO: In the future, will add a function to allow overriding the VUID.\n  getVuid(): string | undefined;\n  createUserContext(userId?: string, attributes?: UserAttributes): OptimizelyUserContext | null;\n  notificationCenter: NotificationCenter;\n  activate(experimentKey: string, userId: string, attributes?: UserAttributes): string | null;\n  track(eventKey: string, userId: string, attributes?: UserAttributes, eventTags?: EventTags): void;\n  getVariation(experimentKey: string, userId: string, attributes?: UserAttributes): string | null;\n  setForcedVariation(experimentKey: string, userId: string, variationKey: string | null): boolean;\n  getForcedVariation(experimentKey: string, userId: string): string | null;\n  isFeatureEnabled(featureKey: string, userId: string, attributes?: UserAttributes): boolean;\n  getEnabledFeatures(userId: string, attributes?: UserAttributes): string[];\n  getFeatureVariable(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): FeatureVariableValue;\n  getFeatureVariableBoolean(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): boolean | null;\n  getFeatureVariableDouble(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): number | null;\n  getFeatureVariableInteger(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): number | null;\n  getFeatureVariableString(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): string | null;\n  getFeatureVariableJSON(featureKey: string, variableKey: string, userId: string, attributes?: UserAttributes): unknown;\n  getAllFeatureVariables(\n    featureKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): { [variableKey: string]: unknown } | null;\n  getOptimizelyConfig(): OptimizelyConfig | null;\n  onReady(options?: { timeout?: number }): Promise<{ success: boolean; reason?: string }>;\n  close(): Promise<{ success: boolean; reason?: string }>;\n  sendOdpEvent(action: string, type?: string, identifiers?: Map<string, string>, data?: Map<string, unknown>): void;\n  getProjectConfig(): ProjectConfig | null;\n  isOdpIntegrated(): boolean;\n}\n\nexport interface ActivateListenerPayload extends ListenerPayload {\n  experiment: import('./shared_types').Experiment;\n  variation: import('./shared_types').Variation;\n  logEvent: Event;\n}\n\nexport interface TrackListenerPayload extends ListenerPayload {\n  eventKey: string;\n  eventTags: EventTags;\n  logEvent: Event;\n}\n\nexport type PersistentCacheProvider = () => PersistentCache;\n\n/**\n * Entry level Config Entities\n * For compatibility with the previous declaration file\n */\nexport interface Config extends ConfigLite {\n  datafileOptions?: DatafileOptions; // Options for Datafile Manager\n  eventBatchSize?: number; // Maximum size of events to be dispatched in a batch\n  eventFlushInterval?: number; // Maximum time for an event to be enqueued\n  eventMaxQueueSize?: number; // Maximum size for the event queue\n  sdkKey?: string;\n  odpOptions?: OdpOptions;\n  persistentCacheProvider?: PersistentCacheProvider;\n}\n\n/**\n * Entry level Config Entities for Lite bundle\n * For compatibility with the previous declaration file\n */\nexport interface ConfigLite {\n  // Datafile string\n  // TODO[OASIS-6649]: Don't use object type\n  // eslint-disable-next-line  @typescript-eslint/ban-types\n  datafile?: object | string;\n  // errorHandler object for logging error\n  errorHandler?: ErrorHandler;\n  // event dispatcher function\n  eventDispatcher?: EventDispatcher;\n  // event dispatcher to use when closing\n  closingEventDispatcher?: EventDispatcher;\n  // The object to validate against the schema\n  jsonSchemaValidator?: {\n    validate(jsonObject: unknown): boolean;\n  };\n  // level of logging i.e debug, info, error, warning etc\n  logLevel?: LogLevel | string;\n  // LogHandler object for logging\n  logger?: LogHandler;\n  // user profile that contains user information\n  userProfileService?: UserProfileService;\n  // dafault options for decide API\n  defaultDecideOptions?: OptimizelyDecideOption[];\n  clientEngine?: string;\n  clientVersion?: string;\n}\n\nexport type OptimizelyExperimentsMap = {\n  [experimentKey: string]: OptimizelyExperiment;\n};\n\nexport type OptimizelyVariablesMap = {\n  [variableKey: string]: OptimizelyVariable;\n};\n\nexport type OptimizelyFeaturesMap = {\n  [featureKey: string]: OptimizelyFeature;\n};\n\nexport type OptimizelyAttribute = {\n  id: string;\n  key: string;\n};\n\nexport type OptimizelyAudience = {\n  id: string;\n  name: string;\n  conditions: string;\n};\n\nexport type OptimizelyEvent = {\n  id: string;\n  key: string;\n  experimentsIds: string[];\n};\n\nexport interface OptimizelyFeature {\n  id: string;\n  key: string;\n  experimentRules: OptimizelyExperiment[];\n  deliveryRules: OptimizelyExperiment[];\n  variablesMap: OptimizelyVariablesMap;\n\n  /**\n   * @deprecated Use experimentRules and deliveryRules\n   */\n  experimentsMap: OptimizelyExperimentsMap;\n}\n\nexport interface OptimizelyVariation {\n  id: string;\n  key: string;\n  featureEnabled?: boolean;\n  variablesMap: OptimizelyVariablesMap;\n}\n\nexport interface OptimizelyConfig {\n  environmentKey: string;\n  sdkKey: string;\n  revision: string;\n\n  /**\n   * This experimentsMap is for experiments of legacy projects only.\n   * For flag projects, experiment keys are not guaranteed to be unique\n   * across multiple flags, so this map may not include all experiments\n   * when keys conflict.\n   */\n  experimentsMap: OptimizelyExperimentsMap;\n\n  featuresMap: OptimizelyFeaturesMap;\n  attributes: OptimizelyAttribute[];\n  audiences: OptimizelyAudience[];\n  events: OptimizelyEvent[];\n  getDatafile(): string;\n}\n\nexport { OptimizelyUserContext };\n\nexport interface OptimizelyDecision {\n  variationKey: string | null;\n  // The boolean value indicating if the flag is enabled or not\n  enabled: boolean;\n  // The collection of variables associated with the decision\n  variables: { [variableKey: string]: unknown };\n  // The rule key of the decision\n  ruleKey: string | null;\n  // The flag key for which the decision has been made for\n  flagKey: string;\n  // A copy of the user context for which the decision has been made for\n  userContext: OptimizelyUserContext;\n  // An array of error/info messages describing why the decision has been made.\n  reasons: string[];\n}\n\nexport interface DatafileUpdate {\n  datafile: string;\n}\n\nexport interface DatafileUpdateListener {\n  (datafileUpdate: DatafileUpdate): void;\n}\n\n// TODO: Replace this with the one from js-sdk-models\ninterface Managed {\n  start(): void;\n\n  stop(): Promise<unknown>;\n}\n\nexport interface DatafileManager extends Managed {\n  get: () => string;\n  on(eventName: string, listener: DatafileUpdateListener): () => void;\n  onReady: () => Promise<void>;\n}\n\nexport interface OptimizelyDecisionContext {\n  flagKey: string;\n  ruleKey?: string;\n}\n\nexport interface OptimizelyForcedDecision {\n  variationKey: string;\n}\n\n// ODP Exports\n\nexport {\n  ICache,\n  RequestHandler,\n  OptimizelySegmentOption,\n  IOdpSegmentApiManager,\n  IOdpSegmentManager,\n  IOdpEventApiManager,\n  IOdpEventManager,\n  IOdpManager,\n};\n","/****************************************************************************\n * Copyright 2020, Optimizely, Inc. and contributors                   *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\nimport { OptimizelyUserContext, OptimizelyDecision } from '../shared_types';\n\nexport function newErrorDecision(key: string, user: OptimizelyUserContext, reasons: string[]): OptimizelyDecision {\n  return {\n    variationKey: null,\n    enabled: false,\n    variables: {},\n    ruleKey: null,\n    flagKey: key,\n    userContext: user,\n    reasons: reasons,\n  };\n}\n","/****************************************************************************\n * Copyright 2016-2024 Optimizely, Inc. and contributors                   *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    https://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\n\n/**\n * Contains global enums used throughout the library\n */\nexport const LOG_LEVEL = {\n  NOTSET: 0,\n  DEBUG: 1,\n  INFO: 2,\n  WARNING: 3,\n  ERROR: 4,\n};\n\nexport const ERROR_MESSAGES = {\n  BROWSER_ODP_MANAGER_INITIALIZATION_FAILED: '%s: Error initializing Browser ODP Manager.',\n  CONDITION_EVALUATOR_ERROR: '%s: Error evaluating audience condition of type %s: %s',\n  DATAFILE_AND_SDK_KEY_MISSING: '%s: You must provide at least one of sdkKey or datafile. Cannot start Optimizely',\n  EXPERIMENT_KEY_NOT_IN_DATAFILE: '%s: Experiment key %s is not in datafile.',\n  FEATURE_NOT_IN_DATAFILE: '%s: Feature key %s is not in datafile.',\n  FETCH_SEGMENTS_FAILED_NETWORK_ERROR: '%s: Audience segments fetch failed. (network error)',\n  FETCH_SEGMENTS_FAILED_DECODE_ERROR: '%s: Audience segments fetch failed. (decode error)',\n  IMPROPERLY_FORMATTED_EXPERIMENT: '%s: Experiment key %s is improperly formatted.',\n  INVALID_ATTRIBUTES: '%s: Provided attributes are in an invalid format.',\n  INVALID_BUCKETING_ID: '%s: Unable to generate hash for bucketing ID %s: %s',\n  INVALID_DATAFILE: '%s: Datafile is invalid - property %s: %s',\n  INVALID_DATAFILE_MALFORMED: '%s: Datafile is invalid because it is malformed.',\n  INVALID_CONFIG: '%s: Provided Optimizely config is in an invalid format.',\n  INVALID_JSON: '%s: JSON object is not valid.',\n  INVALID_ERROR_HANDLER: '%s: Provided \"errorHandler\" is in an invalid format.',\n  INVALID_EVENT_DISPATCHER: '%s: Provided \"eventDispatcher\" is in an invalid format.',\n  INVALID_EVENT_TAGS: '%s: Provided event tags are in an invalid format.',\n  INVALID_EXPERIMENT_KEY: '%s: Experiment key %s is not in datafile. It is either invalid, paused, or archived.',\n  INVALID_EXPERIMENT_ID: '%s: Experiment ID %s is not in datafile.',\n  INVALID_GROUP_ID: '%s: Group ID %s is not in datafile.',\n  INVALID_LOGGER: '%s: Provided \"logger\" is in an invalid format.',\n  INVALID_ROLLOUT_ID: '%s: Invalid rollout ID %s attached to feature %s',\n  INVALID_USER_ID: '%s: Provided user ID is in an invalid format.',\n  INVALID_USER_PROFILE_SERVICE: '%s: Provided user profile service instance is in an invalid format: %s.',\n  LOCAL_STORAGE_DOES_NOT_EXIST: 'Error accessing window localStorage.',\n  MISSING_INTEGRATION_KEY: '%s: Integration key missing from datafile. All integrations should include a key.',\n  NO_DATAFILE_SPECIFIED: '%s: No datafile specified. Cannot start optimizely.',\n  NO_JSON_PROVIDED: '%s: No JSON object to validate against schema.',\n  NO_VARIATION_FOR_EXPERIMENT_KEY: '%s: No variation key %s defined in datafile for experiment %s.',\n  ODP_CONFIG_NOT_AVAILABLE: '%s: ODP is not integrated to the project.',\n  ODP_EVENT_FAILED: 'ODP event send failed.',\n  ODP_FETCH_QUALIFIED_SEGMENTS_SEGMENTS_MANAGER_MISSING:\n    '%s: ODP unable to fetch qualified segments (Segments Manager not initialized).',\n  ODP_IDENTIFY_FAILED_EVENT_MANAGER_MISSING:\n    '%s: ODP identify event %s is not dispatched (Event Manager not instantiated).',\n  ODP_INITIALIZATION_FAILED: '%s: ODP failed to initialize.',\n  ODP_INVALID_DATA: '%s: ODP data is not valid',\n  ODP_EVENT_FAILED_ODP_MANAGER_MISSING: '%s: ODP Event failed to send. (ODP Manager not initialized).',\n  ODP_FETCH_QUALIFIED_SEGMENTS_FAILED_ODP_MANAGER_MISSING:\n    '%s: ODP failed to Fetch Qualified Segments. (ODP Manager not initialized).',\n  ODP_IDENTIFY_USER_FAILED_ODP_MANAGER_MISSING: '%s: ODP failed to Identify User. (ODP Manager not initialized).',\n  ODP_IDENTIFY_USER_FAILED_USER_CONTEXT_INITIALIZATION:\n    '%s: ODP failed to Identify User. (Failed during User Context Initialization).',\n  ODP_MANAGER_UPDATE_SETTINGS_FAILED_EVENT_MANAGER_MISSING:\n    '%s: ODP Manager failed to update OdpConfig settings for internal event manager. (Event Manager not initialized).',\n  ODP_MANAGER_UPDATE_SETTINGS_FAILED_SEGMENTS_MANAGER_MISSING:\n    '%s: ODP Manager failed to update OdpConfig settings for internal segments manager. (Segments Manager not initialized).',\n  ODP_NOT_ENABLED: 'ODP is not enabled',\n  ODP_NOT_INTEGRATED: '%s: ODP is not integrated',\n  ODP_SEND_EVENT_FAILED_EVENT_MANAGER_MISSING:\n    '%s: ODP send event %s was not dispatched (Event Manager not instantiated).',\n  ODP_SEND_EVENT_FAILED_UID_MISSING: '%s: ODP send event %s was not dispatched (No valid user identifier provided).',\n  ODP_SEND_EVENT_FAILED_VUID_MISSING: '%s: ODP send event %s was not dispatched (Unable to fetch VUID).',\n  ODP_VUID_INITIALIZATION_FAILED: '%s: ODP VUID initialization failed.',\n  ODP_VUID_REGISTRATION_FAILED: '%s: ODP VUID failed to be registered.',\n  ODP_VUID_REGISTRATION_FAILED_EVENT_MANAGER_MISSING: '%s: ODP register vuid failed. (Event Manager not instantiated).',\n  UNDEFINED_ATTRIBUTE: '%s: Provided attribute: %s has an undefined value.',\n  UNRECOGNIZED_ATTRIBUTE: '%s: Unrecognized attribute %s provided. Pruning before sending event to Optimizely.',\n  UNABLE_TO_CAST_VALUE: '%s: Unable to cast value %s to type %s, returning null.',\n  USER_NOT_IN_FORCED_VARIATION: '%s: User %s is not in the forced variation map. Cannot remove their forced variation.',\n  USER_PROFILE_LOOKUP_ERROR: '%s: Error while looking up user profile for user ID \"%s\": %s.',\n  USER_PROFILE_SAVE_ERROR: '%s: Error while saving user profile for user ID \"%s\": %s.',\n  VARIABLE_KEY_NOT_IN_DATAFILE: '%s: Variable with key \"%s\" associated with feature with key \"%s\" is not in datafile.',\n  VARIATION_ID_NOT_IN_DATAFILE: '%s: No variation ID %s defined in datafile for experiment %s.',\n  VARIATION_ID_NOT_IN_DATAFILE_NO_EXPERIMENT: '%s: Variation ID %s is not in the datafile.',\n  INVALID_INPUT_FORMAT: '%s: Provided %s is in an invalid format.',\n  INVALID_DATAFILE_VERSION: '%s: This version of the JavaScript SDK does not support the given datafile version: %s',\n  INVALID_VARIATION_KEY: '%s: Provided variation key is in an invalid format.',\n};\n\nexport const LOG_MESSAGES = {\n  ACTIVATE_USER: '%s: Activating user %s in experiment %s.',\n  DISPATCH_CONVERSION_EVENT: '%s: Dispatching conversion event to URL %s with params %s.',\n  DISPATCH_IMPRESSION_EVENT: '%s: Dispatching impression event to URL %s with params %s.',\n  DEPRECATED_EVENT_VALUE: '%s: Event value is deprecated in %s call.',\n  EVENT_KEY_NOT_FOUND: '%s: Event key %s is not in datafile.',\n  EXPERIMENT_NOT_RUNNING: '%s: Experiment %s is not running.',\n  FEATURE_ENABLED_FOR_USER: '%s: Feature %s is enabled for user %s.',\n  FEATURE_NOT_ENABLED_FOR_USER: '%s: Feature %s is not enabled for user %s.',\n  FEATURE_HAS_NO_EXPERIMENTS: '%s: Feature %s is not attached to any experiments.',\n  FAILED_TO_PARSE_VALUE: '%s: Failed to parse event value \"%s\" from event tags.',\n  FAILED_TO_PARSE_REVENUE: '%s: Failed to parse revenue value \"%s\" from event tags.',\n  FORCED_BUCKETING_FAILED: '%s: Variation key %s is not in datafile. Not activating user %s.',\n  INVALID_OBJECT: '%s: Optimizely object is not valid. Failing %s.',\n  INVALID_CLIENT_ENGINE: '%s: Invalid client engine passed: %s. Defaulting to node-sdk.',\n  INVALID_DEFAULT_DECIDE_OPTIONS: '%s: Provided default decide options is not an array.',\n  INVALID_DECIDE_OPTIONS: '%s: Provided decide options is not an array. Using default decide options.',\n  INVALID_VARIATION_ID: '%s: Bucketed into an invalid variation ID. Returning null.',\n  NOTIFICATION_LISTENER_EXCEPTION: '%s: Notification listener for (%s) threw exception: %s',\n  NO_ROLLOUT_EXISTS: '%s: There is no rollout of feature %s.',\n  NOT_ACTIVATING_USER: '%s: Not activating user %s for experiment %s.',\n  NOT_TRACKING_USER: '%s: Not tracking user %s.',\n  ODP_DISABLED: 'ODP Disabled.',\n  ODP_IDENTIFY_FAILED_ODP_DISABLED: '%s: ODP identify event for user %s is not dispatched (ODP disabled).',\n  ODP_IDENTIFY_FAILED_ODP_NOT_INTEGRATED: '%s: ODP identify event %s is not dispatched (ODP not integrated).',\n  ODP_SEND_EVENT_IDENTIFIER_CONVERSION_FAILED:\n    '%s: sendOdpEvent failed to parse through and convert fs_user_id aliases',\n  PARSED_REVENUE_VALUE: '%s: Parsed revenue value \"%s\" from event tags.',\n  PARSED_NUMERIC_VALUE: '%s: Parsed event value \"%s\" from event tags.',\n  RETURNING_STORED_VARIATION:\n    '%s: Returning previously activated variation \"%s\" of experiment \"%s\" for user \"%s\" from user profile.',\n  ROLLOUT_HAS_NO_EXPERIMENTS: '%s: Rollout of feature %s has no experiments',\n  SAVED_VARIATION: '%s: Saved variation \"%s\" of experiment \"%s\" for user \"%s\".',\n  SAVED_VARIATION_NOT_FOUND:\n    '%s: User %s was previously bucketed into variation with ID %s for experiment %s, but no matching variation was found.',\n  SHOULD_NOT_DISPATCH_ACTIVATE: '%s: Experiment %s is not in \"Running\" state. Not activating user.',\n  SKIPPING_JSON_VALIDATION: '%s: Skipping JSON schema validation.',\n  TRACK_EVENT: '%s: Tracking event %s for user %s.',\n  UNRECOGNIZED_DECIDE_OPTION: '%s: Unrecognized decide option %s provided.',\n  USER_ASSIGNED_TO_EXPERIMENT_BUCKET: '%s: Assigned bucket %s to user with bucketing ID %s.',\n  USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP: '%s: User %s is in experiment %s of group %s.',\n  USER_BUCKETED_INTO_TARGETING_RULE: '%s: User %s bucketed into targeting rule %s.',\n  USER_IN_FEATURE_EXPERIMENT: '%s: User %s is in variation %s of experiment %s on the feature %s.',\n  USER_IN_ROLLOUT: '%s: User %s is in rollout of feature %s.',\n  USER_NOT_BUCKETED_INTO_EVERYONE_TARGETING_RULE:\n    '%s: User %s not bucketed into everyone targeting rule due to traffic allocation.',\n  USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP: '%s: User %s is not in experiment %s of group %s.',\n  USER_NOT_BUCKETED_INTO_ANY_EXPERIMENT_IN_GROUP: '%s: User %s is not in any experiment of group %s.',\n  USER_NOT_BUCKETED_INTO_TARGETING_RULE:\n    '%s User %s not bucketed into targeting rule %s due to traffic allocation. Trying everyone rule.',\n  USER_NOT_IN_FEATURE_EXPERIMENT: '%s: User %s is not in any experiment on the feature %s.',\n  USER_NOT_IN_ROLLOUT: '%s: User %s is not in rollout of feature %s.',\n  USER_FORCED_IN_VARIATION: '%s: User %s is forced in variation %s.',\n  USER_MAPPED_TO_FORCED_VARIATION: '%s: Set variation %s for experiment %s and user %s in the forced variation map.',\n  USER_DOESNT_MEET_CONDITIONS_FOR_TARGETING_RULE: '%s: User %s does not meet conditions for targeting rule %s.',\n  USER_MEETS_CONDITIONS_FOR_TARGETING_RULE: '%s: User %s meets conditions for targeting rule %s.',\n  USER_HAS_VARIATION: '%s: User %s is in variation %s of experiment %s.',\n  USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED:\n    'Variation (%s) is mapped to flag (%s), rule (%s) and user (%s) in the forced decision map.',\n  USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED:\n    'Variation (%s) is mapped to flag (%s) and user (%s) in the forced decision map.',\n  USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED_BUT_INVALID:\n    'Invalid variation is mapped to flag (%s), rule (%s) and user (%s) in the forced decision map.',\n  USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED_BUT_INVALID:\n    'Invalid variation is mapped to flag (%s) and user (%s) in the forced decision map.',\n  USER_HAS_FORCED_VARIATION: '%s: Variation %s is mapped to experiment %s and user %s in the forced variation map.',\n  USER_HAS_NO_VARIATION: '%s: User %s is in no variation of experiment %s.',\n  USER_HAS_NO_FORCED_VARIATION: '%s: User %s is not in the forced variation map.',\n  USER_HAS_NO_FORCED_VARIATION_FOR_EXPERIMENT: '%s: No experiment %s mapped to user %s in the forced variation map.',\n  USER_NOT_IN_ANY_EXPERIMENT: '%s: User %s is not in any experiment of group %s.',\n  USER_NOT_IN_EXPERIMENT: '%s: User %s does not meet conditions to be in experiment %s.',\n  USER_RECEIVED_DEFAULT_VARIABLE_VALUE:\n    '%s: User \"%s\" is not in any variation or rollout rule. Returning default value for variable \"%s\" of feature flag \"%s\".',\n  FEATURE_NOT_ENABLED_RETURN_DEFAULT_VARIABLE_VALUE:\n    '%s: Feature \"%s\" is not enabled for user %s. Returning the default variable value \"%s\".',\n  VARIABLE_NOT_USED_RETURN_DEFAULT_VARIABLE_VALUE:\n    '%s: Variable \"%s\" is not used in variation \"%s\". Returning default value.',\n  USER_RECEIVED_VARIABLE_VALUE: '%s: Got variable value \"%s\" for variable \"%s\" of feature flag \"%s\"',\n  VALID_DATAFILE: '%s: Datafile is valid.',\n  VALID_USER_PROFILE_SERVICE: '%s: Valid user profile service provided.',\n  VARIATION_REMOVED_FOR_USER: '%s: Variation mapped to experiment %s has been removed for user %s.',\n  VARIABLE_REQUESTED_WITH_WRONG_TYPE:\n    '%s: Requested variable type \"%s\", but variable is of type \"%s\". Use correct API to retrieve value. Returning None.',\n  VALID_BUCKETING_ID: '%s: BucketingId is valid: \"%s\"',\n  BUCKETING_ID_NOT_STRING: '%s: BucketingID attribute is not a string. Defaulted to userId',\n  EVALUATING_AUDIENCE: '%s: Starting to evaluate audience \"%s\" with conditions: %s.',\n  EVALUATING_AUDIENCES_COMBINED: '%s: Evaluating audiences for %s \"%s\": %s.',\n  AUDIENCE_EVALUATION_RESULT: '%s: Audience \"%s\" evaluated to %s.',\n  AUDIENCE_EVALUATION_RESULT_COMBINED: '%s: Audiences for %s %s collectively evaluated to %s.',\n  MISSING_ATTRIBUTE_VALUE:\n    '%s: Audience condition %s evaluated to UNKNOWN because no value was passed for user attribute \"%s\".',\n  UNEXPECTED_CONDITION_VALUE:\n    '%s: Audience condition %s evaluated to UNKNOWN because the condition value is not supported.',\n  UNEXPECTED_TYPE:\n    '%s: Audience condition %s evaluated to UNKNOWN because a value of type \"%s\" was passed for user attribute \"%s\".',\n  UNEXPECTED_TYPE_NULL:\n    '%s: Audience condition %s evaluated to UNKNOWN because a null value was passed for user attribute \"%s\".',\n  UNKNOWN_CONDITION_TYPE:\n    '%s: Audience condition %s has an unknown condition type. You may need to upgrade to a newer release of the Optimizely SDK.',\n  UNKNOWN_MATCH_TYPE:\n    '%s: Audience condition %s uses an unknown match type. You may need to upgrade to a newer release of the Optimizely SDK.',\n  UPDATED_OPTIMIZELY_CONFIG: '%s: Updated Optimizely config to revision %s (project id %s)',\n  OUT_OF_BOUNDS:\n    '%s: Audience condition %s evaluated to UNKNOWN because the number value for user attribute \"%s\" is not in the range [-2^53, +2^53].',\n  UNABLE_TO_ATTACH_UNLOAD: '%s: unable to bind optimizely.close() to page unload event: \"%s\"',\n};\n\nexport const enum RESERVED_EVENT_KEYWORDS {\n  REVENUE = 'revenue',\n  VALUE = 'value',\n}\n\nexport const CONTROL_ATTRIBUTES = {\n  BOT_FILTERING: '$opt_bot_filtering',\n  BUCKETING_ID: '$opt_bucketing_id',\n  STICKY_BUCKETING_KEY: '$opt_experiment_bucket_map',\n  USER_AGENT: '$opt_user_agent',\n  FORCED_DECISION_NULL_RULE_KEY: '$opt_null_rule_key',\n};\n\nexport const JAVASCRIPT_CLIENT_ENGINE = 'javascript-sdk';\nexport const NODE_CLIENT_ENGINE = 'node-sdk';\nexport const REACT_CLIENT_ENGINE = 'react-sdk';\nexport const REACT_NATIVE_CLIENT_ENGINE = 'react-native-sdk';\nexport const REACT_NATIVE_JS_CLIENT_ENGINE = 'react-native-js-sdk';\nexport const CLIENT_VERSION ='5.3.4' \n\nexport const DECISION_NOTIFICATION_TYPES = {\n  AB_TEST: 'ab-test',\n  FEATURE: 'feature',\n  FEATURE_TEST: 'feature-test',\n  FEATURE_VARIABLE: 'feature-variable',\n  ALL_FEATURE_VARIABLES: 'all-feature-variables',\n  FLAG: 'flag',\n};\n\n/*\n * Represents the source of a decision for feature management. When a feature\n * is accessed through isFeatureEnabled or getVariableValue APIs, the decision\n * source is used to decide whether to dispatch an impression event to\n * Optimizely.\n */\nexport const DECISION_SOURCES = {\n  FEATURE_TEST: 'feature-test',\n  ROLLOUT: 'rollout',\n  EXPERIMENT: 'experiment',\n};\n\nexport const AUDIENCE_EVALUATION_TYPES = {\n  RULE: 'rule',\n  EXPERIMENT: 'experiment',\n};\n\n/*\n * Possible types of variables attached to features\n */\nexport const FEATURE_VARIABLE_TYPES = {\n  BOOLEAN: 'boolean',\n  DOUBLE: 'double',\n  INTEGER: 'integer',\n  STRING: 'string',\n  JSON: 'json',\n};\n\n/*\n * Supported datafile versions\n */\nexport const DATAFILE_VERSIONS = {\n  V2: '2',\n  V3: '3',\n  V4: '4',\n};\n\n/*\n * Pre-Release and Build symbols\n */\nexport const enum VERSION_TYPE {\n  PRE_RELEASE_VERSION_DELIMITER = '-',\n  BUILD_VERSION_DELIMITER = '+',\n}\n\nexport const DECISION_MESSAGES = {\n  SDK_NOT_READY: 'Optimizely SDK not configured properly yet.',\n  FLAG_KEY_INVALID: 'No flag was found for key \"%s\".',\n  VARIABLE_VALUE_INVALID: 'Variable value for key \"%s\" is invalid or wrong type.',\n};\n\n/*\n * Notification types for use with NotificationCenter\n * Format is EVENT: <list of parameters to callback>\n *\n * SDK consumers can use these to register callbacks with the notification center.\n *\n *  @deprecated since 3.1.0\n *  ACTIVATE: An impression event will be sent to Optimizely\n *  Callbacks will receive an object argument with the following properties:\n *    - experiment {Object}\n *    - userId {string}\n *    - attributes {Object|undefined}\n *    - variation {Object}\n *    - logEvent {Object}\n *\n *  DECISION: A decision is made in the system. i.e. user activation,\n *  feature access or feature-variable value retrieval\n *  Callbacks will receive an object argument with the following properties:\n *    - type {string}\n *    - userId {string}\n *    - attributes {Object|undefined}\n *    - decisionInfo {Object|undefined}\n *\n *  LOG_EVENT: A batch of events, which could contain impressions and/or conversions,\n *  will be sent to Optimizely\n *  Callbacks will receive an object argument with the following properties:\n *    - url {string}\n *    - httpVerb {string}\n *    - params {Object}\n *\n *  OPTIMIZELY_CONFIG_UPDATE: This Optimizely instance has been updated with a new\n *  config\n *\n *  TRACK: A conversion event will be sent to Optimizely\n *  Callbacks will receive the an object argument with the following properties:\n *    - eventKey {string}\n *    - userId {string}\n *    - attributes {Object|undefined}\n *    - eventTags {Object|undefined}\n *    - logEvent {Object}\n *\n */\nexport enum NOTIFICATION_TYPES {\n  ACTIVATE = 'ACTIVATE:experiment, user_id,attributes, variation, event',\n  DECISION = 'DECISION:type, userId, attributes, decisionInfo',\n  LOG_EVENT = 'LOG_EVENT:logEvent',\n  OPTIMIZELY_CONFIG_UPDATE = 'OPTIMIZELY_CONFIG_UPDATE',\n  TRACK = 'TRACK:event_key, user_id, attributes, event_tags, event',\n}\n\n/**\n * Default milliseconds before request timeout\n */\nexport const REQUEST_TIMEOUT_MS = 60 * 1000; // 1 minute\nexport const REQUEST_TIMEOUT_ODP_SEGMENTS_MS = 10 * 1000; // 10 secs\nexport const REQUEST_TIMEOUT_ODP_EVENTS_MS = 10 * 1000; // 10 secs\n\n/**\n * ODP User Key Options\n */\nexport enum ODP_USER_KEY {\n  VUID = 'vuid',\n  FS_USER_ID = 'fs_user_id',\n}\n\n/**\n * Alias for fs_user_id to catch for and automatically convert to fs_user_id\n */\nexport const FS_USER_ID_ALIAS = 'fs-user-id';\n\nexport const ODP_DEFAULT_EVENT_TYPE = 'fullstack';\n\n/**\n * ODP Event Action Options\n */\nexport enum ODP_EVENT_ACTION {\n  IDENTIFIED = 'identified',\n  INITIALIZED = 'client_initialized',\n}\n","/****************************************************************************\n * Copyright 2020-2024, Optimizely, Inc. and contributors                   *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\nimport Optimizely from '../optimizely';\nimport {\n  EventTags,\n  OptimizelyDecideOption,\n  OptimizelyDecision,\n  OptimizelyDecisionContext,\n  OptimizelyForcedDecision,\n  UserAttributeValue,\n  UserAttributes,\n} from '../shared_types';\nimport { CONTROL_ATTRIBUTES } from '../utils/enums';\nimport { OptimizelySegmentOption } from '../core/odp/optimizely_segment_option';\n\ninterface OptimizelyUserContextConfig {\n  optimizely: Optimizely;\n  userId: string;\n  attributes?: UserAttributes;\n  shouldIdentifyUser?: boolean;\n}\n\nexport interface IOptimizelyUserContext {\n  qualifiedSegments: string[] | null;\n  getUserId(): string;\n  getAttributes(): UserAttributes;\n  setAttribute(key: string, value: unknown): void;\n  decide(key: string, options?: OptimizelyDecideOption[]): OptimizelyDecision;\n  decideForKeys(keys: string[], options?: OptimizelyDecideOption[]): { [key: string]: OptimizelyDecision };\n  decideAll(options?: OptimizelyDecideOption[]): { [key: string]: OptimizelyDecision };\n  trackEvent(eventName: string, eventTags?: EventTags): void;\n  setForcedDecision(context: OptimizelyDecisionContext, decision: OptimizelyForcedDecision): boolean;\n  getForcedDecision(context: OptimizelyDecisionContext): OptimizelyForcedDecision | null;\n  removeForcedDecision(context: OptimizelyDecisionContext): boolean;\n  removeAllForcedDecisions(): boolean;\n  fetchQualifiedSegments(options?: OptimizelySegmentOption[]): Promise<boolean>;\n  isQualifiedFor(segment: string): boolean;\n}\n\nexport default class OptimizelyUserContext implements IOptimizelyUserContext {\n  private optimizely: Optimizely;\n  private userId: string;\n  private attributes: UserAttributes;\n  private forcedDecisionsMap: { [key: string]: { [key: string]: OptimizelyForcedDecision } };\n  private _qualifiedSegments: string[] | null = null;\n\n  constructor({ optimizely, userId, attributes, shouldIdentifyUser = true }: OptimizelyUserContextConfig) {\n    this.optimizely = optimizely;\n    this.userId = userId;\n    this.attributes = { ...attributes } ?? {};\n    this.forcedDecisionsMap = {};\n\n    if (shouldIdentifyUser) {\n      this.optimizely.onReady().then(({ success }) => {\n        if (success) {\n          this.identifyUser();\n        }\n      });\n    }\n  }\n\n  /**\n   * On user context instantiation, fire event to attempt to identify user to ODP.\n   * Note: This fails if ODP is not enabled.\n   */\n  private identifyUser(): void {\n    this.optimizely.identifyUser(this.userId);\n  }\n\n  /**\n   * Sets an attribute for a given key.\n   * @param     {string}                     key         An attribute key\n   * @param     {any}                        value       An attribute value\n   */\n  setAttribute(key: string, value: UserAttributeValue): void {\n    this.attributes[key] = value;\n  }\n\n  getUserId(): string {\n    return this.userId;\n  }\n\n  getAttributes(): UserAttributes {\n    return { ...this.attributes };\n  }\n\n  getOptimizely(): Optimizely {\n    return this.optimizely;\n  }\n\n  public get qualifiedSegments(): string[] | null {\n    return this._qualifiedSegments;\n  }\n\n  public set qualifiedSegments(qualifiedSegments: string[] | null) {\n    this._qualifiedSegments = qualifiedSegments;\n  }\n\n  /**\n   * Returns a decision result for a given flag key and a user context, which contains all data required to deliver the flag.\n   * If the SDK finds an error, it will return a decision with null for variationKey. The decision will include an error message in reasons.\n   * @param     {string}                     key         A flag key for which a decision will be made.\n   * @param     {OptimizelyDecideOption}     options     An array of options for decision-making.\n   * @return    {OptimizelyDecision}                     A decision result.\n   */\n  decide(key: string, options: OptimizelyDecideOption[] = []): OptimizelyDecision {\n    return this.optimizely.decide(this.cloneUserContext(), key, options);\n  }\n\n  /**\n   * Returns an object of decision results for multiple flag keys and a user context.\n   * If the SDK finds an error for a key, the response will include a decision for the key showing reasons for the error.\n   * The SDK will always return key-mapped decisions. When it cannot process requests, it will return an empty map after logging the errors.\n   * @param     {string[]}                   keys        An array of flag keys for which decisions will be made.\n   * @param     {OptimizelyDecideOption[]}   options     An array of options for decision-making.\n   * @return    {[key: string]: OptimizelyDecision}      An object of decision results mapped by flag keys.\n   */\n  decideForKeys(keys: string[], options: OptimizelyDecideOption[] = []): { [key: string]: OptimizelyDecision } {\n    return this.optimizely.decideForKeys(this.cloneUserContext(), keys, options);\n  }\n\n  /**\n   * Returns an object of decision results for all active flag keys.\n   * @param     {OptimizelyDecideOption[]}   options     An array of options for decision-making.\n   * @return    {[key: string]: OptimizelyDecision}      An object of all decision results mapped by flag keys.\n   */\n  decideAll(options: OptimizelyDecideOption[] = []): { [key: string]: OptimizelyDecision } {\n    return this.optimizely.decideAll(this.cloneUserContext(), options);\n  }\n\n  /**\n   * Tracks an event.\n   * @param     {string}                     eventName The event name.\n   * @param     {EventTags}                  eventTags An optional map of event tag names to event tag values.\n   */\n  trackEvent(eventName: string, eventTags?: EventTags): void {\n    this.optimizely.track(eventName, this.userId, this.attributes, eventTags);\n  }\n\n  /**\n   * Sets the forced decision for specified optimizely decision context.\n   * @param     {OptimizelyDecisionContext}   context      OptimizelyDecisionContext containing flagKey and optional ruleKey.\n   * @param     {OptimizelyForcedDecision}    decision     OptimizelyForcedDecision containing forced variation key.\n   * @return    {boolean}                     true if the forced decision has been set successfully.\n   */\n  setForcedDecision(context: OptimizelyDecisionContext, decision: OptimizelyForcedDecision): boolean {\n    const flagKey = context.flagKey;\n\n    const ruleKey = context.ruleKey ?? CONTROL_ATTRIBUTES.FORCED_DECISION_NULL_RULE_KEY;\n    const variationKey = decision.variationKey;\n    const forcedDecision = { variationKey };\n\n    if (!this.forcedDecisionsMap[flagKey]) {\n      this.forcedDecisionsMap[flagKey] = {};\n    }\n    this.forcedDecisionsMap[flagKey][ruleKey] = forcedDecision;\n\n    return true;\n  }\n\n  /**\n   * Returns the forced decision for specified optimizely decision context.\n   * @param     {OptimizelyDecisionContext}  context  OptimizelyDecisionContext containing flagKey and optional ruleKey.\n   * @return    {OptimizelyForcedDecision|null}       OptimizelyForcedDecision for specified context if exists or null.\n   */\n  getForcedDecision(context: OptimizelyDecisionContext): OptimizelyForcedDecision | null {\n    return this.findForcedDecision(context);\n  }\n\n  /**\n   * Removes the forced decision for specified optimizely decision context.\n   * @param     {OptimizelyDecisionContext}  context  OptimizelyDecisionContext containing flagKey and optional ruleKey.\n   * @return    {boolean}                    true if the forced decision has been removed successfully\n   */\n  removeForcedDecision(context: OptimizelyDecisionContext): boolean {\n    const ruleKey = context.ruleKey ?? CONTROL_ATTRIBUTES.FORCED_DECISION_NULL_RULE_KEY;\n    const flagKey = context.flagKey;\n\n    let isForcedDecisionRemoved = false;\n\n    if (this.forcedDecisionsMap.hasOwnProperty(flagKey)) {\n      const forcedDecisionByRuleKey = this.forcedDecisionsMap[flagKey];\n      if (forcedDecisionByRuleKey.hasOwnProperty(ruleKey)) {\n        delete this.forcedDecisionsMap[flagKey][ruleKey];\n        isForcedDecisionRemoved = true;\n      }\n      if (Object.keys(this.forcedDecisionsMap[flagKey]).length === 0) {\n        delete this.forcedDecisionsMap[flagKey];\n      }\n    }\n\n    return isForcedDecisionRemoved;\n  }\n\n  /**\n   * Removes all forced decisions bound to this user context.\n   * @return    {boolean}                    true if the forced decision has been removed successfully\n   */\n  removeAllForcedDecisions(): boolean {\n    this.forcedDecisionsMap = {};\n    return true;\n  }\n\n  /**\n   * Finds a forced decision in forcedDecisionsMap for provided optimizely decision context.\n   * @param     {OptimizelyDecisionContext}     context  OptimizelyDecisionContext containing flagKey and optional ruleKey.\n   * @return    {OptimizelyForcedDecision|null}          OptimizelyForcedDecision for specified context if exists or null.\n   */\n  private findForcedDecision(context: OptimizelyDecisionContext): OptimizelyForcedDecision | null {\n    let variationKey;\n    const validRuleKey = context.ruleKey ?? CONTROL_ATTRIBUTES.FORCED_DECISION_NULL_RULE_KEY;\n    const flagKey = context.flagKey;\n\n    if (this.forcedDecisionsMap.hasOwnProperty(context.flagKey)) {\n      const forcedDecisionByRuleKey = this.forcedDecisionsMap[flagKey];\n      if (forcedDecisionByRuleKey.hasOwnProperty(validRuleKey)) {\n        variationKey = forcedDecisionByRuleKey[validRuleKey].variationKey;\n        return { variationKey };\n      }\n    }\n\n    return null;\n  }\n\n  private cloneUserContext(): OptimizelyUserContext {\n    const userContext = new OptimizelyUserContext({\n      shouldIdentifyUser: false,\n      optimizely: this.getOptimizely(),\n      userId: this.getUserId(),\n      attributes: this.getAttributes(),\n    });\n\n    if (Object.keys(this.forcedDecisionsMap).length > 0) {\n      userContext.forcedDecisionsMap = { ...this.forcedDecisionsMap };\n    }\n\n    userContext._qualifiedSegments = this._qualifiedSegments;\n\n    return userContext;\n  }\n\n  /**\n   * Fetches a target user's list of qualified segments filtered by any given segment options and stores in qualifiedSegments.\n   * @param {OptimizelySegmentOption[]} options   (Optional) List of segment options used to filter qualified segment results.\n   * @returns Boolean representing if segments were populated.\n   */\n  async fetchQualifiedSegments(options?: OptimizelySegmentOption[]): Promise<boolean> {\n    const segments = await this.optimizely.fetchQualifiedSegments(this.userId, options);\n\n    this.qualifiedSegments = segments;\n\n    return segments !== null;\n  }\n\n  /**\n   * Returns a boolean representing if a user is qualified for a particular segment.\n   * @param   {string}  segment   Target segment to be evaluated for user qualification.\n   * @returns {boolean}           Boolean representing if a user qualified for the passed in segment.\n   */\n  isQualifiedFor(segment: string): boolean {\n    if (!this._qualifiedSegments) {\n      return false;\n    }\n\n    return this._qualifiedSegments.indexOf(segment) > -1;\n  }\n}\n","/****************************************************************************\n * Copyright 2018, 2021, Optimizely, Inc. and contributors                  *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\n\nconst AND_CONDITION = 'and';\nconst OR_CONDITION = 'or';\nconst NOT_CONDITION = 'not';\n\nexport const DEFAULT_OPERATOR_TYPES = [AND_CONDITION, OR_CONDITION, NOT_CONDITION];\nexport type ConditionTree<Leaf> = Leaf | unknown[];\n\ntype LeafEvaluator<Leaf> = (leaf: Leaf) => boolean | null;\n\n/**\n * Top level method to evaluate conditions\n * @param  {ConditionTree<Leaf>}    conditions      Nested array of and/or conditions, or a single leaf\n *                                                  condition value of any type\n *                                                  Example: ['and', '0', ['or', '1', '2']]\n * @param  {LeafEvaluator<Leaf>}    leafEvaluator   Function which will be called to evaluate leaf condition\n *                                                  values\n * @return {?boolean}                               Result of evaluating the conditions using the operator\n *                                                  rules and the leaf evaluator. A return value of null\n *                                                  indicates that the conditions are invalid or unable to be\n *                                                  evaluated.\n */\nexport function evaluate<Leaf>(conditions: ConditionTree<Leaf>, leafEvaluator: LeafEvaluator<Leaf>): boolean | null {\n  if (Array.isArray(conditions)) {\n    let firstOperator = conditions[0];\n    let restOfConditions = conditions.slice(1);\n\n    if (typeof firstOperator === 'string' && DEFAULT_OPERATOR_TYPES.indexOf(firstOperator) === -1) {\n      // Operator to apply is not explicit - assume 'or'\n      firstOperator = OR_CONDITION;\n      restOfConditions = conditions;\n    }\n\n    switch (firstOperator) {\n      case AND_CONDITION:\n        return andEvaluator(restOfConditions, leafEvaluator);\n      case NOT_CONDITION:\n        return notEvaluator(restOfConditions, leafEvaluator);\n      default:\n        // firstOperator is OR_CONDITION\n        return orEvaluator(restOfConditions, leafEvaluator);\n    }\n  }\n\n  const leafCondition = conditions;\n  return leafEvaluator(leafCondition);\n}\n\n/**\n * Evaluates an array of conditions as if the evaluator had been applied\n * to each entry and the results AND-ed together.\n * @param  {unknown[]}             conditions      Array of conditions ex: [operand_1, operand_2]\n * @param  {LeafEvaluator<Leaf>}   leafEvaluator   Function which will be called to evaluate leaf condition values\n * @return {?boolean}                              Result of evaluating the conditions. A return value of null\n *                                                 indicates that the conditions are invalid or unable to be\n *                                                 evaluated.\n */\nfunction andEvaluator<Leaf>(conditions: ConditionTree<Leaf>, leafEvaluator: LeafEvaluator<Leaf>): boolean | null {\n  let sawNullResult = false;\n  if (Array.isArray(conditions)) {\n    for (let i = 0; i < conditions.length; i++) {\n      const conditionResult = evaluate(conditions[i] as ConditionTree<Leaf>, leafEvaluator);\n      if (conditionResult === false) {\n        return false;\n      }\n      if (conditionResult === null) {\n        sawNullResult = true;\n      }\n    }\n    return sawNullResult ? null : true;\n  }\n  return null;\n}\n\n/**\n * Evaluates an array of conditions as if the evaluator had been applied\n * to a single entry and NOT was applied to the result.\n * @param  {unknown[]}             conditions      Array of conditions ex: [operand_1]\n * @param  {LeafEvaluator<Leaf>}   leafEvaluator   Function which will be called to evaluate leaf condition values\n * @return {?boolean}                              Result of evaluating the conditions. A return value of null\n *                                                 indicates that the conditions are invalid or unable to be\n *                                                 evaluated.\n */\nfunction notEvaluator<Leaf>(conditions: ConditionTree<Leaf>, leafEvaluator: LeafEvaluator<Leaf>): boolean | null {\n  if (Array.isArray(conditions) && conditions.length > 0) {\n    const result = evaluate(conditions[0] as ConditionTree<Leaf>, leafEvaluator);\n    return result === null ? null : !result;\n  }\n  return null;\n}\n\n/**\n * Evaluates an array of conditions as if the evaluator had been applied\n * to each entry and the results OR-ed together.\n * @param  {unknown[]}             conditions      Array of conditions ex: [operand_1, operand_2]\n * @param  {LeafEvaluator<Leaf>}   leafEvaluator   Function which will be called to evaluate leaf condition values\n * @return {?boolean}                              Result of evaluating the conditions. A return value of null\n *                                                 indicates that the conditions are invalid or unable to be\n *                                                 evaluated.\n */\nfunction orEvaluator<Leaf>(conditions: ConditionTree<Leaf>, leafEvaluator: LeafEvaluator<Leaf>): boolean | null {\n  let sawNullResult = false;\n  if (Array.isArray(conditions)) {\n    for (let i = 0; i < conditions.length; i++) {\n      const conditionResult = evaluate(conditions[i] as ConditionTree<Leaf>, leafEvaluator);\n      if (conditionResult === true) {\n        return true;\n      }\n      if (conditionResult === null) {\n        sawNullResult = true;\n      }\n    }\n    return sawNullResult ? null : false;\n  }\n  return null;\n}\n","/**\n * Copyright 2020-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LoggerFacade, getLogger } from '../../modules/logging';\nimport { ProjectConfig } from '../project_config';\nimport { DEFAULT_OPERATOR_TYPES } from '../condition_tree_evaluator';\nimport {\n  Audience,\n  Experiment,\n  FeatureVariable,\n  OptimizelyAttribute,\n  OptimizelyAudience,\n  OptimizelyEvent,\n  OptimizelyExperiment,\n  OptimizelyExperimentsMap,\n  OptimizelyFeaturesMap,\n  OptimizelyVariable,\n  OptimizelyVariablesMap,\n  OptimizelyVariation,\n  Rollout,\n  Variation,\n  VariationVariable,\n} from '../../shared_types';\n\ninterface FeatureVariablesMap {\n  [key: string]: FeatureVariable[];\n}\n\n/**\n * The OptimizelyConfig class\n * @param {ProjectConfig} configObj\n * @param {string}        datafile\n */\nexport class OptimizelyConfig {\n  public environmentKey: string;\n  public sdkKey: string;\n  public revision: string;\n\n  /**\n   * This experimentsMap is for experiments of legacy projects only.\n   * For flag projects, experiment keys are not guaranteed to be unique\n   * across multiple flags, so this map may not include all experiments\n   * when keys conflict.\n   */\n  public experimentsMap: OptimizelyExperimentsMap;\n\n  public featuresMap: OptimizelyFeaturesMap;\n  public attributes: OptimizelyAttribute[];\n  public audiences: OptimizelyAudience[];\n  public events: OptimizelyEvent[];\n  private datafile: string;\n\n\n  constructor(configObj: ProjectConfig, datafile: string, logger?: LoggerFacade) {\n    this.sdkKey = configObj.sdkKey ?? '';\n    this.environmentKey = configObj.environmentKey ?? '';\n    this.attributes = configObj.attributes;\n    this.audiences = OptimizelyConfig.getAudiences(configObj);\n    this.events = configObj.events;\n    this.revision = configObj.revision;\n\n    const featureIdVariablesMap = (configObj.featureFlags || []).reduce((resultMap: FeatureVariablesMap, feature) => {\n      resultMap[feature.id] = feature.variables;\n      return resultMap;\n    }, {});\n\n    const variableIdMap = OptimizelyConfig.getVariableIdMap(configObj);\n\n    const { experimentsMapById, experimentsMapByKey } = OptimizelyConfig.getExperimentsMap(\n      configObj, featureIdVariablesMap, variableIdMap, logger,\n    );\n\n    this.experimentsMap = experimentsMapByKey;\n    \n    this.featuresMap = OptimizelyConfig.getFeaturesMap(\n      configObj, featureIdVariablesMap, experimentsMapById, variableIdMap\n    );\n    this.datafile = datafile;\n  }\n\n  /**\n   * Get the datafile\n   * @returns {string} JSON string representation of the datafile that was used to create the current config object\n   */\n  getDatafile(): string {\n    return this.datafile;\n  }\n\n  /**\n   * Get Unique audiences list with typedAudiences as priority\n   * @param       {ProjectConfig}              configObj\n   * @returns     {OptimizelyAudience[]}       Array of unique audiences\n   */\n  static getAudiences(configObj: ProjectConfig): OptimizelyAudience[] {\n    const audiences: OptimizelyAudience[] = [];\n    const typedAudienceIds: string[] = [];\n\n    (configObj.typedAudiences || []).forEach((typedAudience) => {\n      audiences.push({\n        id: typedAudience.id,\n        conditions: JSON.stringify(typedAudience.conditions),\n        name: typedAudience.name,\n      });\n      typedAudienceIds.push(typedAudience.id);\n    });\n\n    (configObj.audiences || []).forEach((audience) => {\n      if (typedAudienceIds.indexOf(audience.id) === -1 && audience.id != '$opt_dummy_audience') {\n        audiences.push({\n          id: audience.id,\n          conditions: JSON.stringify(audience.conditions),\n          name: audience.name,\n        });\n      }\n    });\n\n    return audiences;\n  }\n\n  /**\n   * Converts list of audience conditions to serialized audiences used in experiment\n   * for examples:\n   * 1. Input: [\"or\", \"1\", \"2\"]\n   * Output: \"\\\"us\\\" OR \\\"female\\\"\"\n   * 2. Input: [\"not\", \"1\"]\n   * Output: \"NOT \\\"us\\\"\"\n   * 3. Input: [\"or\", \"1\"]\n   * Output: \"\\\"us\\\"\"\n   * 4. Input: [\"and\", [\"or\", \"1\", [\"and\", \"2\", \"3\"]], [\"and\", \"11\", [\"or\", \"12\", \"13\"]]]\n   * Output: \"(\\\"us\\\" OR (\\\"female\\\" AND \\\"adult\\\")) AND (\\\"fr\\\" AND (\\\"male\\\" OR \\\"kid\\\"))\"\n   * @param       {Array<string | string[]>}                 conditions\n   * @param       {[id: string]: Audience}                   audiencesById\n   * @returns     {string}                                   Serialized audiences condition string\n   */\n  static getSerializedAudiences(\n    conditions: Array<string | string[]>,\n    audiencesById: { [id: string]: Audience }\n  ): string {\n    let serializedAudience = '';\n\n    if (conditions) {\n      let cond = '';\n      conditions.forEach((item) => {\n        let subAudience = '';\n        // Checks if item is list of conditions means it is sub audience\n        if (item instanceof Array) {\n          subAudience = OptimizelyConfig.getSerializedAudiences(item, audiencesById);\n          subAudience = `(${subAudience})`;\n        } else if (DEFAULT_OPERATOR_TYPES.indexOf(item) > -1) {\n          cond = item.toUpperCase();\n        } else {\n          // Checks if item is audience id\n          const audienceName = audiencesById[item] ? audiencesById[item].name : item;\n          // if audience condition is \"NOT\" then add \"NOT\" at start. Otherwise check if there is already audience id in serializedAudience then append condition between serializedAudience and item\n          if (serializedAudience || cond === 'NOT') {\n            cond = cond === '' ? 'OR' : cond;\n            if (serializedAudience === '') {\n              serializedAudience = `${cond} \"${audiencesById[item].name}\"`;\n            } else {\n              serializedAudience = serializedAudience.concat(` ${cond} \"${audienceName}\"`);\n            }\n          } else {\n            serializedAudience = `\"${audienceName}\"`;\n          }\n        }\n        // Checks if sub audience is empty or not\n        if (subAudience !== '') {\n          if (serializedAudience !== '' || cond === 'NOT') {\n            cond = cond === '' ? 'OR' : cond;\n            if (serializedAudience === '') {\n              serializedAudience = `${cond} ${subAudience}`;\n            } else {\n              serializedAudience = serializedAudience.concat(` ${cond} ${subAudience}`);\n            }\n          } else {\n            serializedAudience = serializedAudience.concat(subAudience);\n          }\n        }\n      });\n    }\n    return serializedAudience;\n  }\n\n  /**\n   * Get serialized audience condition string for experiment\n   * @param       {Experiment}                 experiment\n   * @param       {ProjectConfig}              configObj\n   * @returns     {string}                     Serialized audiences condition string\n   */\n  static getExperimentAudiences(experiment: Experiment, configObj: ProjectConfig): string {\n    if (!experiment.audienceConditions) {\n      return '';\n    }\n    return OptimizelyConfig.getSerializedAudiences(experiment.audienceConditions, configObj.audiencesById);\n  }\n\n  /**\n   * Make map of featureVariable which are associated with given feature experiment\n   * @param       {FeatureVariablesMap}                 featureIdVariableMap\n   * @param       {[id: string]: FeatureVariable}       variableIdMap\n   * @param       {string}                              featureId\n   * @param       {VariationVariable[] | undefined}     featureVariableUsages\n   * @param       {boolean | undefined}                 isFeatureEnabled\n   * @returns     {OptimizelyVariablesMap}              FeatureVariables mapped by key\n   */\n  static mergeFeatureVariables(\n    featureIdVariableMap: FeatureVariablesMap,\n    variableIdMap: { [id: string]: FeatureVariable },\n    featureId: string,\n    featureVariableUsages: VariationVariable[] | undefined,\n    isFeatureEnabled: boolean | undefined\n  ): OptimizelyVariablesMap {\n    const variablesMap = (featureIdVariableMap[featureId] || []).reduce(\n      (optlyVariablesMap: OptimizelyVariablesMap, featureVariable) => {\n        optlyVariablesMap[featureVariable.key] = {\n          id: featureVariable.id,\n          key: featureVariable.key,\n          type: featureVariable.type,\n          value: featureVariable.defaultValue,\n        };\n        return optlyVariablesMap;\n      },\n      {}\n    );\n\n    (featureVariableUsages || []).forEach((featureVariableUsage) => {\n      const defaultVariable = variableIdMap[featureVariableUsage.id];\n      const optimizelyVariable: OptimizelyVariable = {\n        id: featureVariableUsage.id,\n        key: defaultVariable.key,\n        type: defaultVariable.type,\n        value: isFeatureEnabled ? featureVariableUsage.value : defaultVariable.defaultValue,\n      };\n      variablesMap[defaultVariable.key] = optimizelyVariable;\n    });\n    return variablesMap;\n  }\n\n  /**\n   * Gets Map of all experiment variations and variables including rollouts\n   * @param       {Variation[]}                           variations\n   * @param       {FeatureVariablesMap}                   featureIdVariableMap\n   * @param       {{[id: string]: FeatureVariable}}       variableIdMap\n   * @param       {string}                                featureId\n   * @returns     {[key: string]: Variation}              Variations mapped by key\n   */\n  static getVariationsMap(\n    variations: Variation[],\n    featureIdVariableMap: FeatureVariablesMap,\n    variableIdMap: { [id: string]: FeatureVariable },\n    featureId: string\n  ): { [key: string]: Variation } {\n    let variationsMap: { [key: string]: OptimizelyVariation } = {};\n    variationsMap = variations.reduce((optlyVariationsMap: { [key: string]: OptimizelyVariation }, variation) => {\n      const variablesMap = OptimizelyConfig.mergeFeatureVariables(\n        featureIdVariableMap,\n        variableIdMap,\n        featureId,\n        variation.variables,\n        variation.featureEnabled\n      );\n      optlyVariationsMap[variation.key] = {\n        id: variation.id,\n        key: variation.key,\n        featureEnabled: variation.featureEnabled,\n        variablesMap: variablesMap,\n      };\n      return optlyVariationsMap;\n    }, {});\n\n    return variationsMap;\n  }\n\n  /**\n   * Gets Map of FeatureVariable with respect to featureVariableId\n   * @param       {ProjectConfig}                        configObj\n   * @returns     {[id: string]: FeatureVariable}        FeatureVariables mapped by id\n   */\n  static getVariableIdMap(configObj: ProjectConfig): { [id: string]: FeatureVariable } {\n    let variablesIdMap: { [id: string]: FeatureVariable } = {};\n    variablesIdMap = (configObj.featureFlags || []).reduce((resultMap: { [id: string]: FeatureVariable }, feature) => {\n      feature.variables.forEach((variable) => {\n        resultMap[variable.id] = variable;\n      });\n      return resultMap;\n    }, {});\n\n    return variablesIdMap;\n  }\n\n  /**\n   * Gets list of rollout experiments\n   * @param       {ProjectConfig}                     configObj\n   * @param       {FeatureVariablesMap}               featureVariableIdMap\n   * @param       {string}                            featureId\n   * @param       {Experiment[]}                      experiments\n   * @param       {{[id: string]: FeatureVariable}}   variableIdMap\n   * @returns     {OptimizelyExperiment[]}            List of Optimizely rollout experiments\n   */\n  static getDeliveryRules(\n    configObj: ProjectConfig,\n    featureVariableIdMap: FeatureVariablesMap,\n    featureId: string,\n    experiments: Experiment[],\n    variableIdMap: {[id: string]: FeatureVariable}\n  ): OptimizelyExperiment[] {\n    return experiments.map((experiment) => {\n      return {\n        id: experiment.id,\n        key: experiment.key,\n        audiences: OptimizelyConfig.getExperimentAudiences(experiment, configObj),\n        variationsMap: OptimizelyConfig.getVariationsMap(\n          experiment.variations,\n          featureVariableIdMap,\n          variableIdMap,\n          featureId\n        ),\n      };\n    });\n  }\n\n  /**\n   * Get Experiment Ids which are part of rollout\n   * @param       {Rollout[]}     rollouts\n   * @returns     {string[]}      Array of experiment Ids\n   */\n  static getRolloutExperimentIds(rollouts: Rollout[]): string[] {\n    const experimentIds: string[] = [];\n    (rollouts || []).forEach((rollout) => {\n      rollout.experiments.forEach((e) => {\n        experimentIds.push(e.id);\n      });\n    });\n    return experimentIds;\n  }\n\n  /**\n   * Get experiments mapped by their id's which are not part of a rollout\n   * @param       {ProjectConfig}                           configObj\n   * @param       {FeatureVariablesMap}                     featureIdVariableMap\n   * @param       {{[id: string]: FeatureVariable}}         variableIdMap\n   * @returns     { experimentsMapById: { [id: string]: OptimizelyExperiment }, experimentsMapByKey: OptimizelyExperimentsMap }      Experiments mapped by id and key\n   */\n  static getExperimentsMap(\n    configObj: ProjectConfig,\n    featureIdVariableMap: FeatureVariablesMap,\n    variableIdMap: {[id: string]: FeatureVariable},\n    logger?: LoggerFacade,\n  ) : { experimentsMapById: { [id: string]: OptimizelyExperiment }, experimentsMapByKey: OptimizelyExperimentsMap } {\n    const rolloutExperimentIds = this.getRolloutExperimentIds(configObj.rollouts);\n\n    const experimentsMapById: { [id : string]: OptimizelyExperiment } = {};\n    const experimentsMapByKey: OptimizelyExperimentsMap = {};\n\n    const experiments = configObj.experiments || [];\n    experiments.forEach((experiment) => {\n      if (rolloutExperimentIds.indexOf(experiment.id) !== -1) {\n        return;\n      }\n\n      const featureIds = configObj.experimentFeatureMap[experiment.id];\n      let featureId = '';\n      if (featureIds && featureIds.length > 0) {\n        featureId = featureIds[0];\n      }\n      const variationsMap = OptimizelyConfig.getVariationsMap(\n        experiment.variations,\n        featureIdVariableMap,\n        variableIdMap,\n        featureId.toString()\n      );\n\n      const optimizelyExperiment: OptimizelyExperiment = {\n        id: experiment.id,\n        key: experiment.key,\n        audiences: OptimizelyConfig.getExperimentAudiences(experiment, configObj),\n        variationsMap: variationsMap,\n      };\n\n      experimentsMapById[experiment.id] = optimizelyExperiment;\n      if (experimentsMapByKey[experiment.key] && logger) {\n        logger.warn(`Duplicate experiment keys found in datafile: ${experiment.key}`);\n      }\n      experimentsMapByKey[experiment.key] = optimizelyExperiment;\n    });\n\n    return { experimentsMapById, experimentsMapByKey };\n  }\n\n  /**\n   * Get experiments mapped by their keys\n   * @param       {OptimizelyExperimentsMap}     experimentsMapById\n   * @returns     {OptimizelyExperimentsMap}     Experiments mapped by key\n   */\n  static getExperimentsKeyMap(experimentsMapById: OptimizelyExperimentsMap): OptimizelyExperimentsMap {\n    const experimentKeysMap: OptimizelyExperimentsMap = {};\n\n    for (const id in experimentsMapById) {\n      const experiment = experimentsMapById[id];\n      experimentKeysMap[experiment.key] = experiment;\n    }\n    return experimentKeysMap;\n  }\n\n  /**\n   * Gets Map of all FeatureFlags and associated experiment map inside it\n   * @param       {ProjectConfig}                     configObj\n   * @param       {FeatureVariablesMap}               featureVariableIdMap\n   * @param       {OptimizelyExperimentsMap}          experimentsMapById\n   * @param       {{[id: string]: FeatureVariable}}   variableIdMap\n   * @returns     {OptimizelyFeaturesMap}             OptimizelyFeature mapped by key\n   */\n  static getFeaturesMap(\n    configObj: ProjectConfig,\n    featureVariableIdMap: FeatureVariablesMap,\n    experimentsMapById: OptimizelyExperimentsMap,\n    variableIdMap: {[id: string]: FeatureVariable}\n  ): OptimizelyFeaturesMap {\n    const featuresMap: OptimizelyFeaturesMap = {};\n    configObj.featureFlags.forEach((featureFlag) => {\n      const featureExperimentMap: OptimizelyExperimentsMap = {};\n      const experimentRules: OptimizelyExperiment[] = [];\n      featureFlag.experimentIds.forEach(experimentId => {\n        const experiment = experimentsMapById[experimentId];\n        if (experiment) {\n          featureExperimentMap[experiment.key] = experiment;\n        }\n        experimentRules.push(experimentsMapById[experimentId]);\n      });\n      const featureVariableMap = (featureFlag.variables || []).reduce((variables: OptimizelyVariablesMap, variable) => {\n        variables[variable.key] = {\n          id: variable.id,\n          key: variable.key,\n          type: variable.type,\n          value: variable.defaultValue,\n        };\n        return variables;\n      }, {});\n      let deliveryRules: OptimizelyExperiment[] = [];\n      const rollout = configObj.rolloutIdMap[featureFlag.rolloutId];\n      if (rollout) {\n        deliveryRules = OptimizelyConfig.getDeliveryRules(\n          configObj,\n          featureVariableIdMap,\n          featureFlag.id,\n          rollout.experiments,\n          variableIdMap,\n        );\n      }\n      featuresMap[featureFlag.key] = {\n        id: featureFlag.id,\n        key: featureFlag.key,\n        experimentRules: experimentRules,\n        deliveryRules: deliveryRules,\n        experimentsMap: featureExperimentMap,\n        variablesMap: featureVariableMap,\n      };\n    });\n    return featuresMap;\n  }\n}\n\n/**\n * Create an instance of OptimizelyConfig\n * @param   {ProjectConfig}             configObj\n * @param   {string}                    datafile\n * @returns {OptimizelyConfig}          An instance of OptimizelyConfig\n */\nexport function createOptimizelyConfig(configObj: ProjectConfig, datafile: string, logger?: LoggerFacade): OptimizelyConfig {\n  return new OptimizelyConfig(configObj, datafile, logger);\n}\n","/**\n * Copyright 2016, 2018-2020, 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { sprintf } from '../../utils/fns';\nimport { ObjectWithUnknownProperties } from '../../shared_types';\n\nimport { \n  ERROR_MESSAGES, \n  DATAFILE_VERSIONS,\n} from '../enums';\n\nconst MODULE_NAME = 'CONFIG_VALIDATOR';\nconst SUPPORTED_VERSIONS = [DATAFILE_VERSIONS.V2, DATAFILE_VERSIONS.V3, DATAFILE_VERSIONS.V4];\n\n/**\n * Validates the given config options\n * @param  {unknown} config\n * @param  {object}  config.errorHandler\n * @param  {object}  config.eventDispatcher\n * @param  {object}  config.logger\n * @return {boolean} true if the config options are valid\n * @throws If any of the config options are not valid\n */\nexport const validate = function(config: unknown): boolean {\n  if (typeof config === 'object' && config !== null) {\n    const configObj = config as ObjectWithUnknownProperties;\n    const errorHandler = configObj['errorHandler'];\n    const eventDispatcher = configObj['eventDispatcher'];\n    const logger = configObj['logger'];\n    if (errorHandler && typeof (errorHandler as ObjectWithUnknownProperties)['handleError'] !== 'function') {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_ERROR_HANDLER, MODULE_NAME));\n    }\n    if (eventDispatcher && typeof (eventDispatcher as ObjectWithUnknownProperties)['dispatchEvent'] !== 'function') {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_EVENT_DISPATCHER, MODULE_NAME));\n    }\n    if (logger && typeof (logger as ObjectWithUnknownProperties)['log'] !== 'function') {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_LOGGER, MODULE_NAME));\n    }\n    return true;\n  }\n  throw new Error(sprintf(ERROR_MESSAGES.INVALID_CONFIG, MODULE_NAME));\n}\n\n/**\n * Validates the datafile\n * @param {Object|string}  datafile\n * @return {Object} The datafile object if the datafile is valid\n * @throws If the datafile is not valid for any of the following reasons:\n - The datafile string is undefined\n - The datafile string cannot be parsed as a JSON object\n - The datafile version is not supported\n */\n// eslint-disable-next-line\nexport const validateDatafile = function(datafile: unknown): any {\n  if (!datafile) {\n    throw new Error(sprintf(ERROR_MESSAGES.NO_DATAFILE_SPECIFIED, MODULE_NAME));\n  }\n  if (typeof datafile === 'string') {\n    // Attempt to parse the datafile string\n    try {\n      datafile = JSON.parse(datafile);\n    } catch (ex) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_DATAFILE_MALFORMED, MODULE_NAME));\n    }\n  }\n  if (typeof datafile === 'object' && !Array.isArray(datafile) && datafile !== null) {\n    if (SUPPORTED_VERSIONS.indexOf(datafile['version' as keyof unknown]) === -1) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_DATAFILE_VERSION, MODULE_NAME, datafile['version' as keyof unknown]));\n    }\n  }\n\n  return datafile;\n};\n\n/**\n * Provides utility methods for validating that the configuration options are valid\n */\nexport default {\n  validate: validate,\n  validateDatafile: validateDatafile,\n}\n","/**\n * Copyright 2022-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { checkArrayEquality } from '../../utils/fns';\n\nexport class OdpConfig {\n  /**\n   * Host of ODP audience segments API.\n   */\n  readonly apiHost: string;\n\n  /**\n   * Public API key for the ODP account from which the audience segments will be fetched (optional).\n   */\n  readonly apiKey: string;\n\n  /**\n   * Url for sending events via pixel.\n   */\n  readonly pixelUrl: string;\n\n  /**\n   * All ODP segments used in the current datafile (associated with apiHost/apiKey).\n   */\n  readonly segmentsToCheck: string[];\n\n  constructor(apiKey: string, apiHost: string, pixelUrl: string, segmentsToCheck: string[]) {\n    this.apiKey = apiKey;\n    this.apiHost = apiHost;\n    this.pixelUrl = pixelUrl;\n    this.segmentsToCheck = segmentsToCheck;\n  }\n\n  /**\n   * Detects if there are any changes between the current and incoming ODP Configs\n   * @param configToCompare ODP Configuration to check self against for equality\n   * @returns Boolean based on if the current ODP Config is equivalent to the incoming ODP Config\n   */\n  equals(configToCompare: OdpConfig): boolean {\n    return (\n      this.apiHost === configToCompare.apiHost &&\n      this.apiKey === configToCompare.apiKey &&\n      this.pixelUrl === configToCompare.pixelUrl &&\n      checkArrayEquality(this.segmentsToCheck, configToCompare.segmentsToCheck)\n    );\n  }\n}\n\nexport type OdpNotIntegratedConfig = {\n  readonly integrated: false;\n}\n\nexport type OdpIntegratedConfig = {\n  readonly integrated: true;\n  readonly odpConfig: OdpConfig;\n}\n\nexport const odpIntegrationsAreEqual = (config1: OdpIntegrationConfig, config2: OdpIntegrationConfig): boolean => {\n  if (config1.integrated !== config2.integrated) {\n    return false;\n  }\n\n  if (config1.integrated && config2.integrated) {\n    return config1.odpConfig.equals(config2.odpConfig);\n  }\n\n  return true;\n}\n\nexport type OdpIntegrationConfig = OdpNotIntegratedConfig | OdpIntegratedConfig;\n","/**\n * Copyright 2016-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { find, objectEntries, objectValues, sprintf, assign, keyBy } from '../../utils/fns';\n\nimport { ERROR_MESSAGES, LOG_LEVEL, LOG_MESSAGES, FEATURE_VARIABLE_TYPES } from '../../utils/enums';\nimport configValidator from '../../utils/config_validator';\n\nimport { LogHandler } from '../../modules/logging';\nimport {\n  Audience,\n  Experiment,\n  FeatureFlag,\n  FeatureVariable,\n  Group,\n  OptimizelyVariation,\n  Rollout,\n  TrafficAllocation,\n  Variation,\n  VariableType,\n  VariationVariable,\n  Integration,\n  FeatureVariableValue,\n} from '../../shared_types';\nimport { OdpConfig, OdpIntegrationConfig } from '../odp/odp_config';\n\ninterface TryCreatingProjectConfigConfig {\n  // TODO[OASIS-6649]: Don't use object type\n  // eslint-disable-next-line  @typescript-eslint/ban-types\n  datafile: string | object;\n  jsonSchemaValidator?: {\n    validate(jsonObject: unknown): boolean;\n  };\n  logger: LogHandler;\n}\n\ninterface Event {\n  key: string;\n  id: string;\n  experimentsIds: string[];\n}\n\ninterface VariableUsageMap {\n  [id: string]: VariationVariable;\n}\n\nexport interface ProjectConfig {\n  revision: string;\n  projectId: string;\n  sdkKey: string;\n  environmentKey: string;\n  sendFlagDecisions?: boolean;\n  experimentKeyMap: { [key: string]: Experiment };\n  featureKeyMap: {\n    [key: string]: FeatureFlag;\n  };\n  rollouts: Rollout[];\n  featureFlags: FeatureFlag[];\n  experimentIdMap: { [id: string]: Experiment };\n  experimentFeatureMap: { [key: string]: string[] };\n  experiments: Experiment[];\n  eventKeyMap: { [key: string]: Event };\n  audiences: Audience[];\n  attributeKeyMap: { [key: string]: { id: string } };\n  variationIdMap: { [id: string]: OptimizelyVariation };\n  variationVariableUsageMap: { [id: string]: VariableUsageMap };\n  audiencesById: { [id: string]: Audience };\n  __datafileStr: string;\n  groupIdMap: { [id: string]: Group };\n  groups: Group[];\n  events: Event[];\n  attributes: Array<{ id: string; key: string }>;\n  typedAudiences: Audience[];\n  rolloutIdMap: { [id: string]: Rollout };\n  anonymizeIP?: boolean | null;\n  botFiltering?: boolean;\n  accountId: string;\n  flagRulesMap: { [key: string]: Experiment[] };\n  flagVariationsMap: { [key: string]: Variation[] };\n  integrations: Integration[];\n  integrationKeyMap?: { [key: string]: Integration };\n  odpIntegrationConfig: OdpIntegrationConfig;\n}\n\nconst EXPERIMENT_RUNNING_STATUS = 'Running';\nconst RESERVED_ATTRIBUTE_PREFIX = '$opt_';\nconst MODULE_NAME = 'PROJECT_CONFIG';\n\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nfunction createMutationSafeDatafileCopy(datafile: any): ProjectConfig {\n  const datafileCopy = assign({}, datafile);\n  datafileCopy.audiences = (datafile.audiences || []).map((audience: Audience) => {\n    return assign({}, audience);\n  });\n  datafileCopy.experiments = (datafile.experiments || []).map((experiment: Experiment) => {\n    return assign({}, experiment);\n  });\n  datafileCopy.featureFlags = (datafile.featureFlags || []).map((featureFlag: FeatureFlag) => {\n    return assign({}, featureFlag);\n  });\n  datafileCopy.groups = (datafile.groups || []).map((group: Group) => {\n    const groupCopy = assign({}, group);\n    groupCopy.experiments = (group.experiments || []).map(experiment => {\n      return assign({}, experiment);\n    });\n    return groupCopy;\n  });\n  datafileCopy.rollouts = (datafile.rollouts || []).map((rollout: Rollout) => {\n    const rolloutCopy = assign({}, rollout);\n    rolloutCopy.experiments = (rollout.experiments || []).map(experiment => {\n      return assign({}, experiment);\n    });\n    return rolloutCopy;\n  });\n\n  datafileCopy.environmentKey = datafile.environmentKey ?? '';\n  datafileCopy.sdkKey = datafile.sdkKey ?? '';\n\n  return datafileCopy;\n}\n\n/**\n * Creates projectConfig object to be used for quick project property lookup\n * @param  {Object}        datafileObj   JSON datafile representing the project\n * @param  {string|null}   datafileStr   JSON string representation of the datafile\n * @return {ProjectConfig} Object representing project configuration\n */\nexport const createProjectConfig = function(datafileObj?: JSON, datafileStr: string | null = null): ProjectConfig {\n  const projectConfig = createMutationSafeDatafileCopy(datafileObj);\n\n  projectConfig.__datafileStr = datafileStr === null ? JSON.stringify(datafileObj) : datafileStr;\n\n  /*\n   * Conditions of audiences in projectConfig.typedAudiences are not\n   * expected to be string-encoded as they are here in projectConfig.audiences.\n   */\n  (projectConfig.audiences || []).forEach(audience => {\n    audience.conditions = JSON.parse(audience.conditions as string);\n  });\n  projectConfig.audiencesById = keyBy(projectConfig.audiences, 'id');\n  assign(projectConfig.audiencesById, keyBy(projectConfig.typedAudiences, 'id'));\n\n  projectConfig.attributeKeyMap = keyBy(projectConfig.attributes, 'key');\n  projectConfig.eventKeyMap = keyBy(projectConfig.events, 'key');\n  projectConfig.groupIdMap = keyBy(projectConfig.groups, 'id');\n\n  let experiments;\n  Object.keys(projectConfig.groupIdMap || {}).forEach(Id => {\n    experiments = projectConfig.groupIdMap[Id].experiments;\n    (experiments || []).forEach(experiment => {\n      projectConfig.experiments.push(assign(experiment, { groupId: Id }));\n    });\n  });\n\n  projectConfig.rolloutIdMap = keyBy(projectConfig.rollouts || [], 'id');\n  objectValues(projectConfig.rolloutIdMap || {}).forEach(rollout => {\n    (rollout.experiments || []).forEach(experiment => {\n      projectConfig.experiments.push(experiment);\n      // Creates { <variationKey>: <variation> } map inside of the experiment\n      experiment.variationKeyMap = keyBy(experiment.variations, 'key');\n    });\n  });\n\n  const allSegmentsSet = new Set<string>();\n\n  Object.keys(projectConfig.audiencesById)\n    .map(audience => getAudienceSegments(projectConfig.audiencesById[audience]))\n    .forEach(audienceSegments => {\n      audienceSegments.forEach(segment => {\n        allSegmentsSet.add(segment);\n      });\n    });\n\n  const allSegments = Array.from(allSegmentsSet);\n\n  let odpIntegrated = false;\n  let odpApiHost = '';\n  let odpApiKey = '';\n  let odpPixelUrl = '';\n\n  if (projectConfig.integrations) {\n    projectConfig.integrationKeyMap = keyBy(projectConfig.integrations, 'key');\n\n    projectConfig.integrations.forEach(integration => {\n      if (!('key' in integration)) {\n        throw new Error(sprintf(ERROR_MESSAGES.MISSING_INTEGRATION_KEY, MODULE_NAME));\n      }\n\n      if (integration.key === 'odp') {\n        odpIntegrated = true;\n        odpApiKey = odpApiKey || integration.publicKey || '';\n        odpApiHost = odpApiHost || integration.host || '';\n        odpPixelUrl = odpPixelUrl || integration.pixelUrl || '';\n      }\n    });\n  }\n\n  if (odpIntegrated) {\n    projectConfig.odpIntegrationConfig = {\n      integrated: true,\n      odpConfig: new OdpConfig(odpApiKey, odpApiHost, odpPixelUrl, allSegments),\n    }\n  } else {\n    projectConfig.odpIntegrationConfig = { integrated: false };\n  }\n\n  projectConfig.experimentKeyMap = keyBy(projectConfig.experiments, 'key');\n  projectConfig.experimentIdMap = keyBy(projectConfig.experiments, 'id');\n\n  projectConfig.variationIdMap = {};\n  projectConfig.variationVariableUsageMap = {};\n  (projectConfig.experiments || []).forEach(experiment => {\n    // Creates { <variationKey>: <variation> } map inside of the experiment\n    experiment.variationKeyMap = keyBy(experiment.variations, 'key');\n\n    // Creates { <variationId>: { key: <variationKey>, id: <variationId> } } mapping for quick lookup\n    assign(projectConfig.variationIdMap, keyBy(experiment.variations, 'id'));\n    objectValues(experiment.variationKeyMap || {}).forEach(variation => {\n      if (variation.variables) {\n        projectConfig.variationVariableUsageMap[variation.id] = keyBy(variation.variables, 'id');\n      }\n    });\n  });\n\n  // Object containing experiment Ids that exist in any feature\n  // for checking that experiment is a feature experiment or not.\n  projectConfig.experimentFeatureMap = {};\n\n  projectConfig.featureKeyMap = keyBy(projectConfig.featureFlags || [], 'key');\n  objectValues(projectConfig.featureKeyMap || {}).forEach(feature => {\n    // Json type is represented in datafile as a subtype of string for the sake of backwards compatibility.\n    // Converting it to a first-class json type while creating Project Config\n    feature.variables.forEach(variable => {\n      if (variable.type === FEATURE_VARIABLE_TYPES.STRING && variable.subType === FEATURE_VARIABLE_TYPES.JSON) {\n        variable.type = FEATURE_VARIABLE_TYPES.JSON as VariableType;\n        delete variable.subType;\n      }\n    });\n\n    feature.variableKeyMap = keyBy(feature.variables, 'key');\n    (feature.experimentIds || []).forEach(experimentId => {\n      // Add this experiment in experiment-feature map.\n      if (projectConfig.experimentFeatureMap[experimentId]) {\n        projectConfig.experimentFeatureMap[experimentId].push(feature.id);\n      } else {\n        projectConfig.experimentFeatureMap[experimentId] = [feature.id];\n      }\n    });\n  });\n\n  // all rules (experiment rules and delivery rules) for each flag\n  projectConfig.flagRulesMap = {};\n\n  (projectConfig.featureFlags || []).forEach(featureFlag => {\n    const flagRuleExperiments: Experiment[] = [];\n    featureFlag.experimentIds.forEach(experimentId => {\n      const experiment = projectConfig.experimentIdMap[experimentId];\n      if (experiment) {\n        flagRuleExperiments.push(experiment);\n      }\n    });\n\n    const rollout = projectConfig.rolloutIdMap[featureFlag.rolloutId];\n    if (rollout) {\n      flagRuleExperiments.push(...rollout.experiments);\n    }\n\n    projectConfig.flagRulesMap[featureFlag.key] = flagRuleExperiments;\n  });\n\n  // all variations for each flag\n  // - datafile does not contain a separate entity for this.\n  // - we collect variations used in each rule (experiment rules and delivery rules)\n  projectConfig.flagVariationsMap = {};\n\n  objectEntries(projectConfig.flagRulesMap || {}).forEach(([flagKey, rules]) => {\n    const variations: OptimizelyVariation[] = [];\n    rules.forEach(rule => {\n      rule.variations.forEach(variation => {\n        if (!find(variations, item => item.id === variation.id)) {\n          variations.push(variation);\n        }\n      });\n    });\n    projectConfig.flagVariationsMap[flagKey] = variations;\n  });\n\n  return projectConfig;\n};\n\n/**\n * Extract all audience segments used in this audience's conditions\n * @param  {Audience}     audience  Object representing the audience being parsed\n * @return {string[]}               List of all audience segments\n */\nexport const getAudienceSegments = function(audience: Audience): string[] {\n  if (!audience.conditions) return [];\n  return getSegmentsFromConditions(audience.conditions);\n};\n\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nconst getSegmentsFromConditions = (condition: any): string[] => {\n  const segments = [];\n\n  if (isLogicalOperator(condition)) {\n    return [];\n  } else if (Array.isArray(condition)) {\n    condition.forEach(nextCondition => segments.push(...getSegmentsFromConditions(nextCondition)));\n  } else if (condition['match'] === 'qualified') {\n    segments.push(condition['value']);\n  }\n\n  return segments;\n};\n\nfunction isLogicalOperator(condition: string): boolean {\n  return ['and', 'or', 'not'].includes(condition);\n}\n\n/**\n * Get experiment ID for the provided experiment key\n * @param  {ProjectConfig}    projectConfig   Object representing project configuration\n * @param  {string}           experimentKey   Experiment key for which ID is to be determined\n * @return {string}                           Experiment ID corresponding to the provided experiment key\n * @throws If experiment key is not in datafile\n */\nexport const getExperimentId = function(projectConfig: ProjectConfig, experimentKey: string): string {\n  const experiment = projectConfig.experimentKeyMap[experimentKey];\n  if (!experiment) {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n  }\n  return experiment.id;\n};\n\n/**\n * Get layer ID for the provided experiment key\n * @param  {ProjectConfig}    projectConfig   Object representing project configuration\n * @param  {string}           experimentId    Experiment ID for which layer ID is to be determined\n * @return {string}                           Layer ID corresponding to the provided experiment key\n * @throws If experiment key is not in datafile\n */\nexport const getLayerId = function(projectConfig: ProjectConfig, experimentId: string): string {\n  const experiment = projectConfig.experimentIdMap[experimentId];\n  if (!experiment) {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n  }\n  return experiment.layerId;\n};\n\n/**\n * Get attribute ID for the provided attribute key\n * @param  {ProjectConfig}   projectConfig    Object representing project configuration\n * @param  {string}          attributeKey     Attribute key for which ID is to be determined\n * @param  {LogHandler}      logger\n * @return {string|null}     Attribute ID corresponding to the provided attribute key. Attribute key if it is a reserved attribute.\n */\nexport const getAttributeId = function(\n  projectConfig: ProjectConfig,\n  attributeKey: string,\n  logger: LogHandler\n): string | null {\n  const attribute = projectConfig.attributeKeyMap[attributeKey];\n  const hasReservedPrefix = attributeKey.indexOf(RESERVED_ATTRIBUTE_PREFIX) === 0;\n  if (attribute) {\n    if (hasReservedPrefix) {\n      logger.log(\n        LOG_LEVEL.WARNING,\n        'Attribute %s unexpectedly has reserved prefix %s; using attribute ID instead of reserved attribute name.',\n        attributeKey,\n        RESERVED_ATTRIBUTE_PREFIX\n      );\n    }\n    return attribute.id;\n  } else if (hasReservedPrefix) {\n    return attributeKey;\n  }\n\n  logger.log(LOG_LEVEL.DEBUG, ERROR_MESSAGES.UNRECOGNIZED_ATTRIBUTE, MODULE_NAME, attributeKey);\n  return null;\n};\n\n/**\n * Get event ID for the provided\n * @param  {ProjectConfig}   projectConfig  Object representing project configuration\n * @param  {string}          eventKey       Event key for which ID is to be determined\n * @return {string|null}     Event ID corresponding to the provided event key\n */\nexport const getEventId = function(projectConfig: ProjectConfig, eventKey: string): string | null {\n  const event = projectConfig.eventKeyMap[eventKey];\n  if (event) {\n    return event.id;\n  }\n  return null;\n};\n\n/**\n * Get experiment status for the provided experiment key\n * @param  {ProjectConfig}  projectConfig   Object representing project configuration\n * @param  {string}         experimentKey   Experiment key for which status is to be determined\n * @return {string}         Experiment status corresponding to the provided experiment key\n * @throws If experiment key is not in datafile\n */\nexport const getExperimentStatus = function(projectConfig: ProjectConfig, experimentKey: string): string {\n  const experiment = projectConfig.experimentKeyMap[experimentKey];\n  if (!experiment) {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey));\n  }\n  return experiment.status;\n};\n\n/**\n * Returns whether experiment has a status of 'Running'\n * @param  {ProjectConfig}  projectConfig   Object representing project configuration\n * @param  {string}         experimentKey   Experiment key for which status is to be compared with 'Running'\n * @return {boolean}                        True if experiment status is set to 'Running', false otherwise\n */\nexport const isActive = function(projectConfig: ProjectConfig, experimentKey: string): boolean {\n  return getExperimentStatus(projectConfig, experimentKey) === EXPERIMENT_RUNNING_STATUS;\n};\n\n/**\n * Determine for given experiment if event is running, which determines whether should be dispatched or not\n * @param  {ProjectConfig}  configObj       Object representing project configuration\n * @param  {string}         experimentKey   Experiment key for which the status is to be determined\n * @return {boolean}                        True if the experiment is running\n *                                          False if the experiment is not running\n *\n */\nexport const isRunning = function(projectConfig: ProjectConfig, experimentKey: string): boolean {\n  return getExperimentStatus(projectConfig, experimentKey) === EXPERIMENT_RUNNING_STATUS;\n};\n\n/**\n * Get audience conditions for the experiment\n * @param  {ProjectConfig}  projectConfig   Object representing project configuration\n * @param  {string}         experimentId    Experiment id for which audience conditions are to be determined\n * @return {Array<string|string[]>}         Audience conditions for the experiment - can be an array of audience IDs, or a\n *                                          nested array of conditions\n *                                          Examples: [\"5\", \"6\"], [\"and\", [\"or\", \"1\", \"2\"], \"3\"]\n * @throws If experiment key is not in datafile\n */\nexport const getExperimentAudienceConditions = function(\n  projectConfig: ProjectConfig,\n  experimentId: string\n): Array<string | string[]> {\n  const experiment = projectConfig.experimentIdMap[experimentId];\n  if (!experiment) {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n  }\n\n  return experiment.audienceConditions || experiment.audienceIds;\n};\n\n/**\n * Get variation key given experiment key and variation ID\n * @param  {ProjectConfig}  projectConfig   Object representing project configuration\n * @param  {string}         variationId     ID of the variation\n * @return {string|null}    Variation key or null if the variation ID is not found\n */\nexport const getVariationKeyFromId = function(projectConfig: ProjectConfig, variationId: string): string | null {\n  if (projectConfig.variationIdMap.hasOwnProperty(variationId)) {\n    return projectConfig.variationIdMap[variationId].key;\n  }\n\n  return null;\n};\n\n/**\n * Get variation given variation ID\n * @param  {ProjectConfig}  projectConfig   Object representing project configuration\n * @param  {string}         variationId     ID of the variation\n * @return {Variation|null}    Variation or null if the variation ID is not found\n */\nexport const getVariationFromId = function(projectConfig: ProjectConfig, variationId: string): Variation | null {\n  if (projectConfig.variationIdMap.hasOwnProperty(variationId)) {\n    return projectConfig.variationIdMap[variationId];\n  }\n\n  return null;\n};\n\n/**\n * Get the variation ID given the experiment key and variation key\n * @param  {ProjectConfig}  projectConfig   Object representing project configuration\n * @param  {string}         experimentKey   Key of the experiment the variation belongs to\n * @param  {string}         variationKey    The variation key\n * @return {string|null}    Variation ID or null\n */\nexport const getVariationIdFromExperimentAndVariationKey = function(\n  projectConfig: ProjectConfig,\n  experimentKey: string,\n  variationKey: string\n): string | null {\n  const experiment = projectConfig.experimentKeyMap[experimentKey];\n  if (experiment.variationKeyMap.hasOwnProperty(variationKey)) {\n    return experiment.variationKeyMap[variationKey].id;\n  }\n\n  return null;\n};\n\n/**\n * Get experiment from provided experiment key\n * @param  {ProjectConfig}  projectConfig  Object representing project configuration\n * @param  {string}         experimentKey  Event key for which experiment IDs are to be retrieved\n * @return {Experiment}     Experiment\n * @throws If experiment key is not in datafile\n */\nexport const getExperimentFromKey = function(projectConfig: ProjectConfig, experimentKey: string): Experiment {\n  if (projectConfig.experimentKeyMap.hasOwnProperty(experimentKey)) {\n    const experiment = projectConfig.experimentKeyMap[experimentKey];\n    if (experiment) {\n      return experiment;\n    }\n  }\n\n  throw new Error(sprintf(ERROR_MESSAGES.EXPERIMENT_KEY_NOT_IN_DATAFILE, MODULE_NAME, experimentKey));\n};\n\n/**\n * Given an experiment id, returns the traffic allocation within that experiment\n * @param  {ProjectConfig}  projectConfig  Object representing project configuration\n * @param  {string}         experimentId   Id representing the experiment\n * @return {TrafficAllocation[]}           Traffic allocation for the experiment\n * @throws If experiment key is not in datafile\n */\nexport const getTrafficAllocation = function(projectConfig: ProjectConfig, experimentId: string): TrafficAllocation[] {\n  const experiment = projectConfig.experimentIdMap[experimentId];\n  if (!experiment) {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId));\n  }\n  return experiment.trafficAllocation;\n};\n\n/**\n * Get experiment from provided experiment id. Log an error if no experiment\n * exists in the project config with the given ID.\n * @param  {ProjectConfig}  projectConfig  Object representing project configuration\n * @param  {string}         experimentId   ID of desired experiment object\n * @param  {LogHandler}     logger\n * @return {Experiment|null}               Experiment object or null\n */\nexport const getExperimentFromId = function(\n  projectConfig: ProjectConfig,\n  experimentId: string,\n  logger: LogHandler\n): Experiment | null {\n  if (projectConfig.experimentIdMap.hasOwnProperty(experimentId)) {\n    const experiment = projectConfig.experimentIdMap[experimentId];\n    if (experiment) {\n      return experiment;\n    }\n  }\n\n  logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.INVALID_EXPERIMENT_ID, MODULE_NAME, experimentId);\n  return null;\n};\n\n/**\n * Returns flag variation for specified flagKey and variationKey\n * @param  {flagKey}        string\n * @param  {variationKey}   string\n * @return {Variation|null}\n */\nexport const getFlagVariationByKey = function(\n  projectConfig: ProjectConfig,\n  flagKey: string,\n  variationKey: string\n): Variation | null {\n  if (!projectConfig) {\n    return null;\n  }\n\n  const variations = projectConfig.flagVariationsMap[flagKey];\n  const result = find(variations, item => item.key === variationKey);\n  if (result) {\n    return result;\n  }\n\n  return null;\n};\n\n/**\n * Get feature from provided feature key. Log an error if no feature exists in\n * the project config with the given key.\n * @param  {ProjectConfig}    projectConfig\n * @param  {string}           featureKey\n * @param  {LogHandler}       logger\n * @return {FeatureFlag|null} Feature object, or null if no feature with the given\n *                            key exists\n */\nexport const getFeatureFromKey = function(\n  projectConfig: ProjectConfig,\n  featureKey: string,\n  logger: LogHandler\n): FeatureFlag | null {\n  if (projectConfig.featureKeyMap.hasOwnProperty(featureKey)) {\n    const feature = projectConfig.featureKeyMap[featureKey];\n    if (feature) {\n      return feature;\n    }\n  }\n\n  logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, featureKey);\n  return null;\n};\n\n/**\n * Get the variable with the given key associated with the feature with the\n * given key. If the feature key or the variable key are invalid, log an error\n * message.\n * @param  {ProjectConfig}        projectConfig\n * @param  {string}               featureKey\n * @param  {string}               variableKey\n * @param  {LogHandler}           logger\n * @return {FeatureVariable|null} Variable object, or null one or both of the given\n * feature and variable keys are invalid\n */\nexport const getVariableForFeature = function(\n  projectConfig: ProjectConfig,\n  featureKey: string,\n  variableKey: string,\n  logger: LogHandler\n): FeatureVariable | null {\n  const feature = projectConfig.featureKeyMap[featureKey];\n  if (!feature) {\n    logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, featureKey);\n    return null;\n  }\n\n  const variable = feature.variableKeyMap[variableKey];\n  if (!variable) {\n    logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.VARIABLE_KEY_NOT_IN_DATAFILE, MODULE_NAME, variableKey, featureKey);\n    return null;\n  }\n\n  return variable;\n};\n\n/**\n * Get the value of the given variable for the given variation. If the given\n * variable has no value for the given variation, return null. Log an error message if the variation is invalid. If the\n * variable or variation are invalid, return null.\n * @param  {ProjectConfig}     projectConfig\n * @param  {FeatureVariable}   variable\n * @param  {Variation}         variation\n * @param  {LogHandler}        logger\n * @return {string|null}       The value of the given variable for the given\n * variation, or null if the given variable has no value\n * for the given variation or if the variation or variable are invalid\n */\nexport const getVariableValueForVariation = function(\n  projectConfig: ProjectConfig,\n  variable: FeatureVariable,\n  variation: Variation,\n  logger: LogHandler\n): string | null {\n  if (!variable || !variation) {\n    return null;\n  }\n\n  if (!projectConfig.variationVariableUsageMap.hasOwnProperty(variation.id)) {\n    logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.VARIATION_ID_NOT_IN_DATAFILE_NO_EXPERIMENT, MODULE_NAME, variation.id);\n    return null;\n  }\n\n  const variableUsages = projectConfig.variationVariableUsageMap[variation.id];\n  const variableUsage = variableUsages[variable.id];\n\n  return variableUsage ? variableUsage.value : null;\n};\n\n/**\n * Given a variable value in string form, try to cast it to the argument type.\n * If the type cast succeeds, return the type casted value, otherwise log an\n * error and return null.\n * @param {string}     variableValue  Variable value in string form\n * @param {string}     variableType   Type of the variable whose value was passed\n *                                    in the first argument. Must be one of\n *                                    FEATURE_VARIABLE_TYPES in\n *                                    lib/utils/enums/index.js. The return value's\n *                                    type is determined by this argument (boolean\n *                                    for BOOLEAN, number for INTEGER or DOUBLE,\n *                                    and string for STRING).\n * @param {LogHandler} logger         Logger instance\n * @returns {*}                       Variable value of the appropriate type, or\n *                                    null if the type cast failed\n */\nexport const getTypeCastValue = function(\n  variableValue: string,\n  variableType: VariableType,\n  logger: LogHandler\n): FeatureVariableValue {\n  let castValue : FeatureVariableValue;\n\n  switch (variableType) {\n    case FEATURE_VARIABLE_TYPES.BOOLEAN:\n      if (variableValue !== 'true' && variableValue !== 'false') {\n        logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType);\n        castValue = null;\n      } else {\n        castValue = variableValue === 'true';\n      }\n      break;\n\n    case FEATURE_VARIABLE_TYPES.INTEGER:\n      castValue = parseInt(variableValue, 10);\n      if (isNaN(castValue)) {\n        logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType);\n        castValue = null;\n      }\n      break;\n\n    case FEATURE_VARIABLE_TYPES.DOUBLE:\n      castValue = parseFloat(variableValue);\n      if (isNaN(castValue)) {\n        logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType);\n        castValue = null;\n      }\n      break;\n\n    case FEATURE_VARIABLE_TYPES.JSON:\n      try {\n        castValue = JSON.parse(variableValue);\n      } catch (e) {\n        logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.UNABLE_TO_CAST_VALUE, MODULE_NAME, variableValue, variableType);\n        castValue = null;\n      }\n      break;\n\n    default:\n      // type is STRING\n      castValue = variableValue;\n      break;\n  }\n\n  return castValue;\n};\n\n/**\n * Returns an object containing all audiences in the project config. Keys are audience IDs\n * and values are audience objects.\n * @param   {ProjectConfig}     projectConfig\n * @returns {{ [id: string]: Audience }}\n */\nexport const getAudiencesById = function(projectConfig: ProjectConfig): { [id: string]: Audience } {\n  return projectConfig.audiencesById;\n};\n\n/**\n * Returns true if an event with the given key exists in the datafile, and false otherwise\n * @param   {ProjectConfig}     projectConfig\n * @param   {string}            eventKey\n * @returns {boolean}\n */\nexport const eventWithKeyExists = function(projectConfig: ProjectConfig, eventKey: string): boolean {\n  return projectConfig.eventKeyMap.hasOwnProperty(eventKey);\n};\n\n/**\n * Returns true if experiment belongs to any feature, false otherwise.\n * @param   {ProjectConfig}       projectConfig\n * @param   {string}              experimentId\n * @returns {boolean}\n */\nexport const isFeatureExperiment = function(projectConfig: ProjectConfig, experimentId: string): boolean {\n  return projectConfig.experimentFeatureMap.hasOwnProperty(experimentId);\n};\n\n/**\n * Returns the JSON string representation of the datafile\n * @param   {ProjectConfig}       projectConfig\n * @returns {string}\n */\nexport const toDatafile = function(projectConfig: ProjectConfig): string {\n  return projectConfig.__datafileStr;\n};\n\n/**\n * @typedef   {Object}\n * @property  {Object|null} configObj\n * @property  {Error|null}  error\n */\n\n/**\n * Try to create a project config object from the given datafile and\n * configuration properties.\n * Returns an object with configObj and error properties.\n * If successful, configObj is the project config object, and error is null.\n * Otherwise, configObj is null and error is an error with more information.\n * @param   {Object}         config\n * @param   {Object|string}  config.datafile\n * @param   {Object}         config.jsonSchemaValidator\n * @param   {Object}         config.logger\n * @returns {Object}         Object containing configObj and error properties\n */\nexport const tryCreatingProjectConfig = function(\n  config: TryCreatingProjectConfigConfig\n): { configObj: ProjectConfig | null; error: Error | null } {\n  let newDatafileObj;\n  try {\n    newDatafileObj = configValidator.validateDatafile(config.datafile);\n  } catch (error) {\n    return { configObj: null, error };\n  }\n\n  if (config.jsonSchemaValidator) {\n    try {\n      config.jsonSchemaValidator.validate(newDatafileObj);\n      config.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.VALID_DATAFILE, MODULE_NAME);\n    } catch (error) {\n      return { configObj: null, error };\n    }\n  } else {\n    config.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.SKIPPING_JSON_VALIDATION, MODULE_NAME);\n  }\n\n  const createProjectConfigArgs = [newDatafileObj];\n  if (typeof config.datafile === 'string') {\n    // Since config.datafile was validated above, we know that it is a valid JSON string\n    createProjectConfigArgs.push(config.datafile);\n  }\n\n  const newConfigObj = createProjectConfig(...createProjectConfigArgs);\n\n  return {\n    configObj: newConfigObj,\n    error: null,\n  };\n};\n\n/**\n * Get the send flag decisions value\n * @param  {ProjectConfig}   projectConfig\n * @return {boolean}         A boolean value that indicates if we should send flag decisions\n */\nexport const getSendFlagDecisionsValue = function(projectConfig: ProjectConfig): boolean {\n  return !!projectConfig.sendFlagDecisions;\n};\n\nexport default {\n  createProjectConfig,\n  getExperimentId,\n  getLayerId,\n  getAttributeId,\n  getEventId,\n  getExperimentStatus,\n  isActive,\n  isRunning,\n  getExperimentAudienceConditions,\n  getVariationFromId,\n  getVariationKeyFromId,\n  getVariationIdFromExperimentAndVariationKey,\n  getExperimentFromKey,\n  getTrafficAllocation,\n  getExperimentFromId,\n  getFlagVariationByKey,\n  getFeatureFromKey,\n  getVariableForFeature,\n  getVariableValueForVariation,\n  getTypeCastValue,\n  getSendFlagDecisionsValue,\n  getAudiencesById,\n  getAudienceSegments,\n  eventWithKeyExists,\n  isFeatureExperiment,\n  toDatafile,\n  tryCreatingProjectConfig,\n};\n","/**\n * Copyright 2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ntype Callback = () => void; \n\nexport const scheduleMicrotaskOrTimeout = (callback: Callback): void =>{\n  if (typeof queueMicrotask === 'function') {\n    queueMicrotask(callback);\n  } else {\n    setTimeout(callback);\n  }\n}","/**\n * Copyright 2019-2022, 2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLogger } from '../../modules/logging';\nimport { sprintf } from '../../utils/fns';\n\nimport { ERROR_MESSAGES } from '../../utils/enums';\nimport { createOptimizelyConfig } from '../optimizely_config';\nimport { OnReadyResult, OptimizelyConfig, DatafileManager } from '../../shared_types';\nimport { ProjectConfig, toDatafile, tryCreatingProjectConfig } from '../project_config';\nimport { scheduleMicrotaskOrTimeout } from '../../utils/microtask';\n\nconst logger = getLogger();\nconst MODULE_NAME = 'PROJECT_CONFIG_MANAGER';\n\ninterface ProjectConfigManagerConfig {\n  // TODO[OASIS-6649]: Don't use object type\n  // eslint-disable-next-line  @typescript-eslint/ban-types\n  datafile?: string | object;\n  jsonSchemaValidator?: {\n    validate(jsonObject: unknown): boolean;\n  };\n  sdkKey?: string;\n  datafileManager?: DatafileManager;\n}\n\n/**\n * Return an error message derived from a thrown value. If the thrown value is\n * an error, return the error's message property. Otherwise, return a default\n * provided by the second argument.\n * @param  {Error|null}                   maybeError\n * @param  {string}                       defaultMessage\n * @return {string}\n */\nfunction getErrorMessage(maybeError: Error | null, defaultMessage?: string): string {\n  if (maybeError instanceof Error) {\n    return maybeError.message;\n  }\n  return defaultMessage || 'Unknown error';\n}\n\n/**\n * ProjectConfigManager provides project config objects via its methods\n * getConfig and onUpdate. It uses a DatafileManager to fetch datafiles. It is\n * responsible for parsing and validating datafiles, and converting datafile\n * string into project config objects.\n * @param {ProjectConfigManagerConfig}    config\n */\nexport class ProjectConfigManager {\n  private updateListeners: Array<(config: ProjectConfig) => void> = [];\n  private configObj: ProjectConfig | null = null;\n  private optimizelyConfigObj: OptimizelyConfig | null = null;\n  private readyPromise: Promise<OnReadyResult>;\n  public jsonSchemaValidator: { validate(jsonObject: unknown): boolean } | undefined;\n  public datafileManager: DatafileManager | null = null;\n\n  constructor(config: ProjectConfigManagerConfig) {\n    try {\n      this.jsonSchemaValidator = config.jsonSchemaValidator;\n\n      if (!config.datafile && !config.sdkKey) {\n        const datafileAndSdkKeyMissingError = new Error(\n          sprintf(ERROR_MESSAGES.DATAFILE_AND_SDK_KEY_MISSING, MODULE_NAME)\n        );\n        this.readyPromise = Promise.resolve({\n          success: false,\n          reason: getErrorMessage(datafileAndSdkKeyMissingError),\n        });\n        logger.error(datafileAndSdkKeyMissingError);\n        return;\n      }\n\n      let handleNewDatafileException = null;\n      if (config.datafile) {\n        handleNewDatafileException = this.handleNewDatafile(config.datafile);\n      }\n\n      if (config.sdkKey && config.datafileManager) {\n        this.datafileManager = config.datafileManager;\n        this.datafileManager.start();\n\n        this.readyPromise = this.datafileManager\n          .onReady()\n          .then(this.onDatafileManagerReadyFulfill.bind(this), this.onDatafileManagerReadyReject.bind(this));\n        this.datafileManager.on('update', this.onDatafileManagerUpdate.bind(this));\n      } else if (this.configObj) {\n        this.readyPromise = Promise.resolve({\n          success: true,\n        });\n      } else {\n        this.readyPromise = Promise.resolve({\n          success: false,\n          reason: getErrorMessage(handleNewDatafileException, 'Invalid datafile'),\n        });\n      }\n    } catch (ex) {\n      logger.error(ex);\n      this.readyPromise = Promise.resolve({\n        success: false,\n        reason: getErrorMessage(ex, 'Error in initialize'),\n      });\n    }\n  }\n\n  /**\n   * Respond to datafile manager's onReady promise becoming fulfilled.\n   * If there are validation or parse failures using the datafile provided by\n   * DatafileManager, ProjectConfigManager's ready promise is resolved with an\n   * unsuccessful result. Otherwise, ProjectConfigManager updates its own project\n   * config object from the new datafile, and its ready promise is resolved with a\n   * successful result.\n   */\n  private onDatafileManagerReadyFulfill(): OnReadyResult {\n    if (this.datafileManager) {\n      const newDatafileError = this.handleNewDatafile(this.datafileManager.get());\n      if (newDatafileError) {\n        return {\n          success: false,\n          reason: getErrorMessage(newDatafileError),\n        };\n      }\n      return { success: true };\n    }\n\n    return {\n      success: false,\n      reason: getErrorMessage(null, 'Datafile manager is not provided'),\n    };\n  }\n\n  /**\n   * Respond to datafile manager's onReady promise becoming rejected.\n   * When DatafileManager's onReady promise is rejected, there is no possibility\n   * of obtaining a datafile. In this case, ProjectConfigManager's ready promise\n   * is fulfilled with an unsuccessful result.\n   * @param   {Error}   err\n   * @returns {Object}\n   */\n  private onDatafileManagerReadyReject(err: Error): OnReadyResult {\n    return {\n      success: false,\n      reason: getErrorMessage(err, 'Failed to become ready'),\n    };\n  }\n\n  /**\n   * Respond to datafile manager's update event. Attempt to update own config\n   * object using latest datafile from datafile manager. Call own registered\n   * update listeners if successful\n   */\n  private onDatafileManagerUpdate(): void {\n    if (this.datafileManager) {\n      this.handleNewDatafile(this.datafileManager.get());\n    }\n  }\n\n  /**\n   * Handle new datafile by attemping to create a new Project Config object. If successful and\n   * the new config object's revision is newer than the current one, sets/updates the project config\n   * and optimizely config object instance variables and returns null for the error. If unsuccessful,\n   * the project config and optimizely config objects will not be updated, and the error is returned.\n   * @param   {string | object}        newDatafile\n   * @returns {Error|null}    error or null\n   */\n  // TODO[OASIS-6649]: Don't use object type\n  // eslint-disable-next-line  @typescript-eslint/ban-types\n  private handleNewDatafile(newDatafile: string | object): Error | null {\n    const { configObj, error } = tryCreatingProjectConfig({\n      datafile: newDatafile,\n      jsonSchemaValidator: this.jsonSchemaValidator,\n      logger: logger,\n    });\n\n    if (error) {\n      logger.error(error);\n    } else {\n      const oldRevision = this.configObj ? this.configObj.revision : 'null';\n      if (configObj && oldRevision !== configObj.revision) {\n        this.configObj = configObj;\n        this.optimizelyConfigObj = null;\n        scheduleMicrotaskOrTimeout(() => {\n          this.updateListeners.forEach(listener => listener(configObj));\n        }) \n      }\n    }\n\n    return error;\n  }\n\n  /**\n   * Returns the current project config object, or null if no project config object\n   * is available\n   * @return {ProjectConfig|null}\n   */\n  getConfig(): ProjectConfig | null {\n    return this.configObj;\n  }\n\n  /**\n   * Returns the optimizely config object or null\n   * @return {OptimizelyConfig|null}\n   */\n  getOptimizelyConfig(): OptimizelyConfig | null {\n    if (!this.optimizelyConfigObj && this.configObj) {\n      this.optimizelyConfigObj = createOptimizelyConfig(this.configObj, toDatafile(this.configObj), logger);\n    }\n    return this.optimizelyConfigObj;\n  }\n\n  /**\n   * Returns a Promise that fulfills when this ProjectConfigManager is ready to\n   * use (meaning it has a valid project config object), or has failed to become\n   * ready.\n   *\n   * Failure can be caused by the following:\n   * - At least one of sdkKey or datafile is not provided in the constructor argument\n   * - The provided datafile was invalid\n   * - The datafile provided by the datafile manager was invalid\n   * - The datafile manager failed to fetch a datafile\n   *\n   * The returned Promise is fulfilled with a result object containing these\n   * properties:\n   *    - success (boolean): True if this instance is ready to use with a valid\n   *                         project config object, or false if it failed to\n   *                         become ready\n   *    - reason (string=):  If success is false, this is a string property with\n   *                         an explanatory message.\n   * @return {Promise}\n   */\n  onReady(): Promise<OnReadyResult> {\n    return this.readyPromise;\n  }\n\n  /**\n   * Add a listener for project config updates. The listener will be called\n   * whenever this instance has a new project config object available.\n   * Returns a dispose function that removes the subscription\n   * @param  {Function} listener\n   * @return {Function}\n   */\n  onUpdate(listener: (config: ProjectConfig) => void): () => void {\n    this.updateListeners.push(listener);\n    return () => {\n      const index = this.updateListeners.indexOf(listener);\n      if (index > -1) {\n        this.updateListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Stop the internal datafile manager and remove all update listeners\n   */\n  stop(): void {\n    if (this.datafileManager) {\n      this.datafileManager.stop();\n    }\n    this.updateListeners = [];\n  }\n}\n\nexport function createProjectConfigManager(config: ProjectConfigManagerConfig): ProjectConfigManager {\n  return new ProjectConfigManager(config);\n}\n","/**\n * Copyright 2016, 2019-2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Bucketer API for determining the variation id from the specified parameters\n */\nimport { sprintf } from '../../utils/fns';\nimport murmurhash from 'murmurhash';\nimport { LogHandler } from '../../modules/logging';\nimport {\n  DecisionResponse,\n  BucketerParams,\n  TrafficAllocation,\n  Group,\n} from '../../shared_types';\n\nimport {\n  ERROR_MESSAGES,\n  LOG_LEVEL,\n  LOG_MESSAGES,\n} from '../../utils/enums';\n\nconst HASH_SEED = 1;\nconst MAX_HASH_VALUE = Math.pow(2, 32);\nconst MAX_TRAFFIC_VALUE = 10000;\nconst MODULE_NAME = 'BUCKETER';\nconst RANDOM_POLICY = 'random';\n\n/**\n * Determines ID of variation to be shown for the given input params\n * @param  {Object}             bucketerParams\n * @param  {string}             bucketerParams.experimentId\n * @param  {string}             bucketerParams.experimentKey\n * @param  {string}             bucketerParams.userId\n * @param  {Object[]}           bucketerParams.trafficAllocationConfig\n * @param  {Array}              bucketerParams.experimentKeyMap\n * @param  {Object}             bucketerParams.groupIdMap\n * @param  {Object}             bucketerParams.variationIdMap\n * @param  {string}             bucketerParams.varationIdMap[].key\n * @param  {Object}             bucketerParams.logger\n * @param  {string}             bucketerParams.bucketingId\n * @return {Object}             DecisionResponse                         DecisionResponse containing variation ID that user has been bucketed into,\n *                                                                       null if user is not bucketed into any experiment and the decide reasons.\n */\nexport const bucket = function(bucketerParams: BucketerParams): DecisionResponse<string | null> {\n  const decideReasons: (string | number)[][] = [];\n  // Check if user is in a random group; if so, check if user is bucketed into a specific experiment\n  const experiment = bucketerParams.experimentIdMap[bucketerParams.experimentId];\n  const groupId = experiment['groupId'];\n  if (groupId) {\n    const group = bucketerParams.groupIdMap[groupId];\n    if (!group) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_GROUP_ID, MODULE_NAME, groupId));\n    }\n    if (group.policy === RANDOM_POLICY) {\n      const bucketedExperimentId = bucketUserIntoExperiment(\n        group,\n        bucketerParams.bucketingId,\n        bucketerParams.userId,\n        bucketerParams.logger\n      );\n\n      // Return if user is not bucketed into any experiment\n      if (bucketedExperimentId === null) {\n        bucketerParams.logger.log(\n          LOG_LEVEL.INFO,\n          LOG_MESSAGES.USER_NOT_IN_ANY_EXPERIMENT,\n          MODULE_NAME,\n          bucketerParams.userId,\n          groupId,\n        );\n        decideReasons.push([\n          LOG_MESSAGES.USER_NOT_IN_ANY_EXPERIMENT,\n          MODULE_NAME,\n          bucketerParams.userId,\n          groupId,\n        ]);\n        return {\n          result: null,\n          reasons: decideReasons,\n        };\n      }\n\n      // Return if user is bucketed into a different experiment than the one specified\n      if (bucketedExperimentId !== bucketerParams.experimentId) {        \n        bucketerParams.logger.log(\n          LOG_LEVEL.INFO,\n          LOG_MESSAGES.USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP,\n          MODULE_NAME,\n          bucketerParams.userId,\n          bucketerParams.experimentKey,\n          groupId,\n        );\n        decideReasons.push([\n          LOG_MESSAGES.USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP,\n          MODULE_NAME,\n          bucketerParams.userId,\n          bucketerParams.experimentKey,\n          groupId,\n        ]);\n        return {\n          result: null,\n          reasons: decideReasons,\n        };\n      }\n\n      // Continue bucketing if user is bucketed into specified experiment      \n      bucketerParams.logger.log(\n        LOG_LEVEL.INFO,\n        LOG_MESSAGES.USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP,\n        MODULE_NAME,\n        bucketerParams.userId,\n        bucketerParams.experimentKey,\n        groupId,\n      );\n      decideReasons.push([\n        LOG_MESSAGES.USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP,\n        MODULE_NAME,\n        bucketerParams.userId,\n        bucketerParams.experimentKey,\n        groupId,\n      ]);\n    }\n  }\n  const bucketingId = `${bucketerParams.bucketingId}${bucketerParams.experimentId}`;\n  const bucketValue = _generateBucketValue(bucketingId);\n  \n  bucketerParams.logger.log(\n    LOG_LEVEL.DEBUG,\n    LOG_MESSAGES.USER_ASSIGNED_TO_EXPERIMENT_BUCKET,\n    MODULE_NAME,\n    bucketValue,\n    bucketerParams.userId,\n  );\n  decideReasons.push([\n    LOG_MESSAGES.USER_ASSIGNED_TO_EXPERIMENT_BUCKET,\n    MODULE_NAME,\n    bucketValue,\n    bucketerParams.userId,\n  ]);\n\n  const entityId = _findBucket(bucketValue, bucketerParams.trafficAllocationConfig);\n  if (entityId !== null) {\n    if (!bucketerParams.variationIdMap[entityId]) {\n      if (entityId) {        \n        bucketerParams.logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.INVALID_VARIATION_ID, MODULE_NAME);\n        decideReasons.push([LOG_MESSAGES.INVALID_VARIATION_ID, MODULE_NAME]);\n      }\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n  }\n\n  return {\n    result: entityId,\n    reasons: decideReasons,\n  };\n};\n\n/**\n * Returns bucketed experiment ID to compare against experiment user is being called into\n * @param  {Group}       group        Group that experiment is in\n * @param  {string}      bucketingId  Bucketing ID\n * @param  {string}      userId       ID of user to be bucketed into experiment\n * @param  {LogHandler}  logger       Logger implementation\n * @return {string|null}              ID of experiment if user is bucketed into experiment within the group, null otherwise\n */\nexport const bucketUserIntoExperiment = function(\n  group: Group,\n  bucketingId: string,\n  userId: string,\n  logger: LogHandler\n): string | null {\n  const bucketingKey = `${bucketingId}${group.id}`;\n  const bucketValue = _generateBucketValue(bucketingKey);\n  logger.log(\n    LOG_LEVEL.DEBUG,\n    LOG_MESSAGES.USER_ASSIGNED_TO_EXPERIMENT_BUCKET,\n    MODULE_NAME,\n    bucketValue,\n    userId,\n  );\n  const trafficAllocationConfig = group.trafficAllocation;\n  const bucketedExperimentId = _findBucket(bucketValue, trafficAllocationConfig);\n  return bucketedExperimentId;\n};\n\n/**\n * Returns entity ID associated with bucket value\n * @param  {number}                bucketValue\n * @param  {TrafficAllocation[]}   trafficAllocationConfig\n * @param  {number}                trafficAllocationConfig[].endOfRange\n * @param  {string}                trafficAllocationConfig[].entityId\n * @return {string|null}           Entity ID for bucketing if bucket value is within traffic allocation boundaries, null otherwise\n */\nexport const _findBucket = function(\n  bucketValue: number,\n  trafficAllocationConfig: TrafficAllocation[]\n): string | null {\n  for (let i = 0; i < trafficAllocationConfig.length; i++) {\n    if (bucketValue < trafficAllocationConfig[i].endOfRange) {\n      return trafficAllocationConfig[i].entityId;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Helper function to generate bucket value in half-closed interval [0, MAX_TRAFFIC_VALUE)\n * @param  {string}               bucketingKey          String value for bucketing\n * @return {number}               The generated bucket value\n * @throws                        If bucketing value is not a valid string\n */\nexport const _generateBucketValue = function(bucketingKey: string): number {\n  try {\n    // NOTE: the mmh library already does cast the hash value as an unsigned 32bit int\n    // https://github.com/perezd/node-murmurhash/blob/master/murmurhash.js#L115\n    const hashValue = murmurhash.v3(bucketingKey, HASH_SEED);\n    const ratio = hashValue / MAX_HASH_VALUE;\n    return Math.floor(ratio * MAX_TRAFFIC_VALUE);\n  } catch (ex: any) {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_BUCKETING_ID, MODULE_NAME, bucketingKey, ex.message));\n  }\n};\n\nexport default {\n  bucket: bucket,\n  bucketUserIntoExperiment: bucketUserIntoExperiment,\n  _generateBucketValue: _generateBucketValue,\n};\n","/**\n * Copyright 2020, 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLogger } from '../../modules/logging';\nimport { VERSION_TYPE, LOG_MESSAGES } from '../enums';\n\nconst MODULE_NAME = 'SEMANTIC VERSION';\nconst logger = getLogger();\n\n/**\n * Evaluate if provided string is number only\n * @param  {unknown}  content\n * @return {boolean}  true if the string is number only\n *\n */\nfunction isNumber(content: string): boolean {\n  return /^\\d+$/.test(content);\n}\n\n/**\n * Evaluate if provided version contains pre-release \"-\"\n * @param  {unknown}  version\n * @return {boolean}  true if the version contains \"-\" and meets condition\n *\n */\nfunction isPreReleaseVersion(version: string): boolean {\n  const preReleaseIndex = version.indexOf(VERSION_TYPE.PRE_RELEASE_VERSION_DELIMITER);\n  const buildIndex = version.indexOf(VERSION_TYPE.BUILD_VERSION_DELIMITER);\n\n  if (preReleaseIndex < 0) {\n    return false;\n  }\n\n  if (buildIndex < 0) {\n    return true;\n  }\n\n  return preReleaseIndex < buildIndex;\n}\n\n/**\n * Evaluate if provided version contains build \"+\"\n * @param  {unknown}  version\n * @return {boolean}  true if the version contains \"+\" and meets condition\n *\n */\nfunction isBuildVersion(version: string): boolean {\n  const preReleaseIndex = version.indexOf(VERSION_TYPE.PRE_RELEASE_VERSION_DELIMITER);\n  const buildIndex = version.indexOf(VERSION_TYPE.BUILD_VERSION_DELIMITER);\n\n  if (buildIndex < 0) {\n    return false;\n  }\n\n  if (preReleaseIndex < 0) {\n    return true;\n  }\n\n  return buildIndex < preReleaseIndex;\n}\n\n/**\n * check if there is any white spaces \" \" in version\n * @param  {unknown}  version\n * @return {boolean}  true if the version contains \" \"\n *\n */\nfunction hasWhiteSpaces(version: string): boolean {\n  return /\\s/.test(version);\n}\n\n/**\n * split version in parts\n * @param  {unknown}  version\n * @return {boolean}  The array of version split into smaller parts i.e major, minor, patch etc\n *                    null if given version is in invalid format\n */\nfunction splitVersion(version: string): string[] | null {\n  let targetPrefix = version;\n  let targetSuffix = '';\n\n  // check that version shouldn't have white space\n  if (hasWhiteSpaces(version)) {\n    logger.warn(LOG_MESSAGES.UNKNOWN_MATCH_TYPE, MODULE_NAME, version);\n    return null;\n  }\n  //check for pre release e.g. 1.0.0-alpha where 'alpha' is a pre release\n  //otherwise check for build e.g. 1.0.0+001 where 001 is a build metadata\n  if (isPreReleaseVersion(version)) {\n    targetPrefix = version.substring(0, version.indexOf(VERSION_TYPE.PRE_RELEASE_VERSION_DELIMITER));\n    targetSuffix = version.substring(version.indexOf(VERSION_TYPE.PRE_RELEASE_VERSION_DELIMITER) + 1);\n  } else if (isBuildVersion(version)) {\n    targetPrefix = version.substring(0, version.indexOf(VERSION_TYPE.BUILD_VERSION_DELIMITER));\n    targetSuffix = version.substring(version.indexOf(VERSION_TYPE.BUILD_VERSION_DELIMITER) + 1);\n  }\n\n  // check dot counts in target_prefix\n  if (typeof targetPrefix !== 'string' || typeof targetSuffix !== 'string') {\n    return null;\n  }\n\n  const dotCount = targetPrefix.split('.').length - 1;\n  if (dotCount > 2) {\n    logger.warn(LOG_MESSAGES.UNKNOWN_MATCH_TYPE, MODULE_NAME, version);\n    return null;\n  }\n\n  const targetVersionParts = targetPrefix.split('.');\n  if (targetVersionParts.length != dotCount + 1) {\n    logger.warn(LOG_MESSAGES.UNKNOWN_MATCH_TYPE, MODULE_NAME, version);\n    return null;\n  }\n  for (const part of targetVersionParts) {\n    if (!isNumber(part)) {\n      logger.warn(LOG_MESSAGES.UNKNOWN_MATCH_TYPE, MODULE_NAME, version);\n      return null;\n    }\n  }\n\n  if (targetSuffix) {\n    targetVersionParts.push(targetSuffix);\n  }\n\n  return targetVersionParts;\n}\n\n/**\n * Compare user version with condition version\n * @param  {string}  conditionsVersion\n * @param  {string}  userProvidedVersion\n * @return {number | null}  0 if user version is equal to condition version\n *                          1 if user version is greater than condition version\n *                         -1 if user version is less than condition version\n *                          null if invalid user or condition version is provided\n */\nexport function compareVersion(conditionsVersion: string, userProvidedVersion: string): number | null {\n  const userVersionParts = splitVersion(userProvidedVersion);\n  const conditionsVersionParts = splitVersion(conditionsVersion);\n\n  if (!userVersionParts || !conditionsVersionParts) {\n    return null;\n  }\n\n  const userVersionPartsLen = userVersionParts.length;\n\n  for (let idx = 0; idx < conditionsVersionParts.length; idx++) {\n    if (userVersionPartsLen <= idx) {\n      return isPreReleaseVersion(conditionsVersion) || isBuildVersion(conditionsVersion) ? 1 : -1;\n    } else if (!isNumber(userVersionParts[idx])) {\n      if (userVersionParts[idx] < conditionsVersionParts[idx]) {\n        return isPreReleaseVersion(conditionsVersion) && !isPreReleaseVersion(userProvidedVersion) ? 1 : -1;\n      } else if (userVersionParts[idx] > conditionsVersionParts[idx]) {\n        return !isPreReleaseVersion(conditionsVersion) && isPreReleaseVersion(userProvidedVersion) ? -1 : 1;\n      }\n    } else {\n      const userVersionPart = parseInt(userVersionParts[idx]);\n      const conditionsVersionPart = parseInt(conditionsVersionParts[idx]);\n      if (userVersionPart > conditionsVersionPart) {\n        return 1;\n      } else if (userVersionPart < conditionsVersionPart) {\n        return -1;\n      }\n    }\n  }\n\n  // check if user version contains release and target version does not\n  if (isPreReleaseVersion(userProvidedVersion) && !isPreReleaseVersion(conditionsVersion)) {\n    return -1;\n  }\n\n  return 0;\n}\n","/****************************************************************************\n * Copyright 2018-2019, 2020, 2022, Optimizely, Inc. and contributors              *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\nimport { getLogger } from '../../modules/logging';\nimport { Condition, OptimizelyUserContext } from '../../shared_types';\n\nimport fns from '../../utils/fns';\nimport { LOG_MESSAGES } from '../../utils/enums';\nimport { compareVersion } from '../../utils/semantic_version';\n\nconst MODULE_NAME = 'CUSTOM_ATTRIBUTE_CONDITION_EVALUATOR';\n\nconst logger = getLogger();\n\nconst EXACT_MATCH_TYPE = 'exact';\nconst EXISTS_MATCH_TYPE = 'exists';\nconst GREATER_OR_EQUAL_THAN_MATCH_TYPE = 'ge';\nconst GREATER_THAN_MATCH_TYPE = 'gt';\nconst LESS_OR_EQUAL_THAN_MATCH_TYPE = 'le';\nconst LESS_THAN_MATCH_TYPE = 'lt';\nconst SEMVER_EXACT_MATCH_TYPE = 'semver_eq';\nconst SEMVER_GREATER_OR_EQUAL_THAN_MATCH_TYPE = 'semver_ge';\nconst SEMVER_GREATER_THAN_MATCH_TYPE = 'semver_gt';\nconst SEMVER_LESS_OR_EQUAL_THAN_MATCH_TYPE = 'semver_le';\nconst SEMVER_LESS_THAN_MATCH_TYPE = 'semver_lt';\nconst SUBSTRING_MATCH_TYPE = 'substring';\n\nconst MATCH_TYPES = [\n  EXACT_MATCH_TYPE,\n  EXISTS_MATCH_TYPE,\n  GREATER_THAN_MATCH_TYPE,\n  GREATER_OR_EQUAL_THAN_MATCH_TYPE,\n  LESS_THAN_MATCH_TYPE,\n  LESS_OR_EQUAL_THAN_MATCH_TYPE,\n  SUBSTRING_MATCH_TYPE,\n  SEMVER_EXACT_MATCH_TYPE,\n  SEMVER_LESS_THAN_MATCH_TYPE,\n  SEMVER_LESS_OR_EQUAL_THAN_MATCH_TYPE,\n  SEMVER_GREATER_THAN_MATCH_TYPE,\n  SEMVER_GREATER_OR_EQUAL_THAN_MATCH_TYPE\n];\n\ntype ConditionEvaluator = (condition: Condition, user: OptimizelyUserContext) => boolean | null;\n\nconst EVALUATORS_BY_MATCH_TYPE: { [conditionType: string]: ConditionEvaluator | undefined } = {};\nEVALUATORS_BY_MATCH_TYPE[EXACT_MATCH_TYPE] = exactEvaluator;\nEVALUATORS_BY_MATCH_TYPE[EXISTS_MATCH_TYPE] = existsEvaluator;\nEVALUATORS_BY_MATCH_TYPE[GREATER_THAN_MATCH_TYPE] = greaterThanEvaluator;\nEVALUATORS_BY_MATCH_TYPE[GREATER_OR_EQUAL_THAN_MATCH_TYPE] = greaterThanOrEqualEvaluator;\nEVALUATORS_BY_MATCH_TYPE[LESS_THAN_MATCH_TYPE] = lessThanEvaluator;\nEVALUATORS_BY_MATCH_TYPE[LESS_OR_EQUAL_THAN_MATCH_TYPE] = lessThanOrEqualEvaluator;\nEVALUATORS_BY_MATCH_TYPE[SUBSTRING_MATCH_TYPE] = substringEvaluator;\nEVALUATORS_BY_MATCH_TYPE[SEMVER_EXACT_MATCH_TYPE] = semverEqualEvaluator;\nEVALUATORS_BY_MATCH_TYPE[SEMVER_GREATER_THAN_MATCH_TYPE] = semverGreaterThanEvaluator;\nEVALUATORS_BY_MATCH_TYPE[SEMVER_GREATER_OR_EQUAL_THAN_MATCH_TYPE] = semverGreaterThanOrEqualEvaluator;\nEVALUATORS_BY_MATCH_TYPE[SEMVER_LESS_THAN_MATCH_TYPE] = semverLessThanEvaluator;\nEVALUATORS_BY_MATCH_TYPE[SEMVER_LESS_OR_EQUAL_THAN_MATCH_TYPE] = semverLessThanOrEqualEvaluator;\n\n/**\n * Given a custom attribute audience condition and user attributes, evaluate the\n * condition against the attributes.\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @return {?boolean}               true/false if the given user attributes match/don't match the given condition,\n *                                  null if the given user attributes and condition can't be evaluated\n * TODO: Change to accept and object with named properties\n */\nexport function evaluate(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const conditionMatch = condition.match;\n  if (typeof conditionMatch !== 'undefined' && MATCH_TYPES.indexOf(conditionMatch) === -1) {\n    logger.warn(LOG_MESSAGES.UNKNOWN_MATCH_TYPE, MODULE_NAME, JSON.stringify(condition));\n    return null;\n  }\n\n  const attributeKey = condition.name;\n  if (!userAttributes.hasOwnProperty(attributeKey) && conditionMatch != EXISTS_MATCH_TYPE) {\n    logger.debug(\n      LOG_MESSAGES.MISSING_ATTRIBUTE_VALUE, MODULE_NAME, JSON.stringify(condition), attributeKey\n    );\n    return null;\n  }\n\n  let evaluatorForMatch;\n  if (!conditionMatch) {\n    evaluatorForMatch = exactEvaluator;\n  } else {\n    evaluatorForMatch = EVALUATORS_BY_MATCH_TYPE[conditionMatch] || exactEvaluator;\n  }\n\n  return evaluatorForMatch(condition, user);\n}\n\n/**\n * Returns true if the value is valid for exact conditions. Valid values include\n * strings, booleans, and numbers that aren't NaN, -Infinity, or Infinity.\n * @param value\n * @returns {boolean}\n */\nfunction isValueTypeValidForExactConditions(value: unknown): boolean {\n  return typeof value === 'string' || typeof value === 'boolean' || fns.isNumber(value);\n}\n\n/**\n * Evaluate the given exact match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @return  {?boolean}              true if the user attribute value is equal (===) to the condition value,\n *                                  false if the user attribute value is not equal (!==) to the condition value,\n *                                  null if the condition value or user attribute value has an invalid type, or\n *                                  if there is a mismatch between the user attribute type and the condition value\n *                                  type\n */\nfunction exactEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const conditionValue = condition.value;\n  const conditionValueType = typeof conditionValue;\n  const conditionName = condition.name;\n  const userValue = userAttributes[conditionName];\n  const userValueType = typeof userValue;\n\n  if (\n    !isValueTypeValidForExactConditions(conditionValue) ||\n    (fns.isNumber(conditionValue) && !fns.isSafeInteger(conditionValue))\n  ) {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_CONDITION_VALUE, MODULE_NAME, JSON.stringify(condition)\n    );\n    return null;\n  }\n\n  if (userValue === null) {\n    logger.debug(\n      LOG_MESSAGES.UNEXPECTED_TYPE_NULL, MODULE_NAME, JSON.stringify(condition), conditionName\n    );\n    return null;\n  }\n\n  if (!isValueTypeValidForExactConditions(userValue) || conditionValueType !== userValueType) {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_TYPE, MODULE_NAME, JSON.stringify(condition), userValueType, conditionName\n    );\n    return null;\n  }\n\n  if (fns.isNumber(userValue) && !fns.isSafeInteger(userValue)) {\n    logger.warn(\n      LOG_MESSAGES.OUT_OF_BOUNDS, MODULE_NAME, JSON.stringify(condition), conditionName\n    );\n    return null;\n  }\n\n  return conditionValue === userValue;\n}\n\n/**\n * Evaluate the given exists match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {boolean}               true if both:\n *                                    1) the user attributes have a value for the given condition, and\n *                                    2) the user attribute value is neither null nor undefined\n *                                  Returns false otherwise\n */\nfunction existsEvaluator(condition: Condition, user: OptimizelyUserContext): boolean {\n  const userAttributes = user.getAttributes();\n  const userValue = userAttributes[condition.name];\n  return typeof userValue !== 'undefined' && userValue !== null;\n}\n\n/**\n * Validate user and condition values\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?boolean}              true if values are valid,\n *                                  false if values are not valid\n */\nfunction validateValuesForNumericCondition(condition: Condition, user: OptimizelyUserContext): boolean {\n  const userAttributes = user.getAttributes();\n  const conditionName = condition.name;\n  const userValue = userAttributes[conditionName];\n  const userValueType = typeof userValue;\n  const conditionValue = condition.value;\n\n  if (conditionValue === null || !fns.isSafeInteger(conditionValue)) {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_CONDITION_VALUE, MODULE_NAME, JSON.stringify(condition)\n    );\n    return false;\n  }\n\n  if (userValue === null) {\n    logger.debug(\n      LOG_MESSAGES.UNEXPECTED_TYPE_NULL, MODULE_NAME, JSON.stringify(condition), conditionName\n    );\n    return false;\n  }\n\n  if (!fns.isNumber(userValue)) {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_TYPE, MODULE_NAME, JSON.stringify(condition), userValueType, conditionName\n    );\n    return false;\n  }\n\n  if (!fns.isSafeInteger(userValue)) {\n    logger.warn(\n      LOG_MESSAGES.OUT_OF_BOUNDS, MODULE_NAME, JSON.stringify(condition), conditionName\n    );\n    return false;\n  }\n  return true;\n}\n\n/**\n * Evaluate the given greater than match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?boolean}              true if the user attribute value is greater than the condition value,\n *                                  false if the user attribute value is less than or equal to the condition value,\n *                                  null if the condition value isn't a number or the user attribute value\n *                                  isn't a number\n */\nfunction greaterThanEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const userValue = userAttributes[condition.name];\n  const conditionValue = condition.value;\n\n  if (!validateValuesForNumericCondition(condition, user) || conditionValue === null) {\n    return null;\n  }\n  return userValue! > conditionValue;\n}\n\n/**\n * Evaluate the given greater or equal than match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute value is greater or equal than the condition value,\n *                                  false if the user attribute value is less than to the condition value,\n *                                  null if the condition value isn't a number or the user attribute value isn't a\n *                                  number\n */\nfunction greaterThanOrEqualEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const userValue = userAttributes[condition.name];\n  const conditionValue = condition.value;\n\n  if (!validateValuesForNumericCondition(condition, user) || conditionValue === null) {\n    return null;\n  }\n\n  return userValue! >= conditionValue;\n}\n\n/**\n * Evaluate the given less than match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?boolean}              true if the user attribute value is less than the condition value,\n *                                  false if the user attribute value is greater than or equal to the condition value,\n *                                  null if the condition value isn't a number or the user attribute value isn't a\n *                                  number\n */\nfunction lessThanEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const userValue = userAttributes[condition.name];\n  const conditionValue = condition.value;\n\n  if (!validateValuesForNumericCondition(condition, user) || conditionValue === null) {\n    return null;\n  }\n\n  return userValue! < conditionValue;\n}\n\n/**\n * Evaluate the given less or equal than match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute value is less or equal than the condition value,\n *                                  false if the user attribute value is greater than to the condition value,\n *                                  null if the condition value isn't a number or the user attribute value isn't a\n *                                  number\n */\nfunction lessThanOrEqualEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const userValue = userAttributes[condition.name];\n  const conditionValue = condition.value;\n\n  if (!validateValuesForNumericCondition(condition, user) || conditionValue === null) {\n    return null;\n  }\n\n  return userValue! <= conditionValue;\n}\n\n/**\n * Evaluate the given substring match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the condition value is a substring of the user attribute value,\n *                                  false if the condition value is not a substring of the user attribute value,\n *                                  null if the condition value isn't a string or the user attribute value\n *                                  isn't a string\n */\nfunction substringEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const userAttributes = user.getAttributes();\n  const conditionName = condition.name;\n  const userValue = userAttributes[condition.name];\n  const userValueType = typeof userValue;\n  const conditionValue = condition.value;\n\n  if (typeof conditionValue !== 'string') {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_CONDITION_VALUE, MODULE_NAME, JSON.stringify(condition)\n    );\n    return null;\n  }\n\n  if (userValue === null) {\n    logger.debug(\n      LOG_MESSAGES.UNEXPECTED_TYPE_NULL, MODULE_NAME, JSON.stringify(condition), conditionName\n    );\n    return null;\n  }\n\n  if (typeof userValue !== 'string') {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_TYPE, MODULE_NAME, JSON.stringify(condition), userValueType, conditionName\n    );\n    return null;\n  }\n\n  return userValue.indexOf(conditionValue) !== -1;\n}\n\n/**\n * Evaluate the given semantic version match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?number}               returns compareVersion result\n *                                  null if the user attribute version has an invalid type\n */\nfunction evaluateSemanticVersion(condition: Condition, user: OptimizelyUserContext): number | null {\n  const userAttributes = user.getAttributes();\n  const conditionName = condition.name;\n  const userValue = userAttributes[conditionName];\n  const userValueType = typeof userValue;\n  const conditionValue = condition.value;\n\n  if (typeof conditionValue !== 'string') {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_CONDITION_VALUE, MODULE_NAME, JSON.stringify(condition)\n    );\n    return null;\n  }\n\n  if (userValue === null) {\n    logger.debug(\n      LOG_MESSAGES.UNEXPECTED_TYPE_NULL, MODULE_NAME, JSON.stringify(condition), conditionName\n    );\n    return null;\n  }\n\n  if (typeof userValue !== 'string') {\n    logger.warn(\n      LOG_MESSAGES.UNEXPECTED_TYPE, MODULE_NAME, JSON.stringify(condition), userValueType, conditionName\n    );\n    return null;\n  }\n\n  return compareVersion(conditionValue, userValue);\n}\n\n/**\n * Evaluate the given version match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute version is equal (===) to the condition version,\n *                                  false if the user attribute version is not equal (!==) to the condition version,\n *                                  null if the user attribute version has an invalid type\n */\nfunction semverEqualEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const result = evaluateSemanticVersion(condition, user);\n  if (result === null) {\n    return null;\n  }\n  return result === 0;\n}\n\n/**\n * Evaluate the given version match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute version is greater (>) than the condition version,\n *                                  false if the user attribute version is not greater than the condition version,\n *                                  null if the user attribute version has an invalid type\n */\nfunction semverGreaterThanEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const result = evaluateSemanticVersion(condition, user);\n  if (result === null) {\n    return null;\n  }\n  return result > 0;\n}\n\n/**\n * Evaluate the given version match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute version is less (<) than the condition version,\n *                                  false if the user attribute version is not less than the condition version,\n *                                  null if the user attribute version has an invalid type\n */\nfunction semverLessThanEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const result = evaluateSemanticVersion(condition, user);\n  if (result === null) {\n    return null;\n  }\n  return result < 0;\n}\n\n/**\n * Evaluate the given version match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute version is greater than or equal (>=) to the condition version,\n *                                  false if the user attribute version is not greater than or equal to the condition version,\n *                                  null if the user attribute version has an invalid type\n */\nfunction semverGreaterThanOrEqualEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const result = evaluateSemanticVersion(condition, user);\n  if (result === null) {\n    return null;\n  }\n  return result >= 0;\n}\n\n/**\n * Evaluate the given version match condition for the given user attributes\n * @param  {Condition}              condition\n * @param  {OptimizelyUserContext}  user\n * @returns {?Boolean}              true if the user attribute version is less than or equal (<=) to the condition version,\n *                                  false if the user attribute version is not less than or equal to the condition version,\n *                                  null if the user attribute version has an invalid type\n */\nfunction semverLessThanOrEqualEvaluator(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const result = evaluateSemanticVersion(condition, user);\n  if (result === null) {\n    return null;\n  }\n  return result <= 0;\n\n}\n","/****************************************************************************\n * Copyright 2022 Optimizely, Inc. and contributors              *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\nimport { getLogger } from '../../../modules/logging';\nimport { Condition, OptimizelyUserContext } from '../../../shared_types';\n\nimport { LOG_MESSAGES } from '../../../utils/enums';\n\nconst MODULE_NAME = 'ODP_SEGMENT_CONDITION_EVALUATOR';\n\nconst logger = getLogger();\n\nconst QUALIFIED_MATCH_TYPE = 'qualified';\n\nconst MATCH_TYPES = [\n  QUALIFIED_MATCH_TYPE,\n];\n\ntype ConditionEvaluator = (condition: Condition, user: OptimizelyUserContext) => boolean | null;\n\nconst EVALUATORS_BY_MATCH_TYPE: { [conditionType: string]: ConditionEvaluator | undefined } = {};\nEVALUATORS_BY_MATCH_TYPE[QUALIFIED_MATCH_TYPE] = qualifiedEvaluator;\n\n/**\n * Given a custom attribute audience condition and user attributes, evaluate the\n * condition against the attributes.\n * @param  {Condition}        condition\n * @param  {OptimizelyUserContext} user\n * @return {?boolean}         true/false if the given user attributes match/don't match the given condition,\n *                            null if the given user attributes and condition can't be evaluated\n * TODO: Change to accept and object with named properties\n */\nexport function evaluate(condition: Condition, user: OptimizelyUserContext): boolean | null {\n  const conditionMatch = condition.match;\n  if (typeof conditionMatch !== 'undefined' && MATCH_TYPES.indexOf(conditionMatch) === -1) {\n    logger.warn(LOG_MESSAGES.UNKNOWN_MATCH_TYPE, MODULE_NAME, JSON.stringify(condition));\n    return null;\n  }\n\n  let evaluator;\n  if (!conditionMatch) {\n    evaluator = qualifiedEvaluator;\n  } else {\n    evaluator = EVALUATORS_BY_MATCH_TYPE[conditionMatch] || qualifiedEvaluator;\n  }\n\n  return evaluator(condition, user);\n}\n\nfunction qualifiedEvaluator(condition: Condition, user: OptimizelyUserContext): boolean {\n  return user.isQualifiedFor(condition.value as string);\n}\n","/**\n * Copyright 2016, 2018-2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLogger } from '../../modules/logging';\n\nimport fns from '../../utils/fns';\nimport {\n  LOG_LEVEL,\n  LOG_MESSAGES,\n  ERROR_MESSAGES,\n} from '../../utils/enums';\nimport * as conditionTreeEvaluator from '../condition_tree_evaluator';\nimport * as customAttributeConditionEvaluator from '../custom_attribute_condition_evaluator';\nimport * as odpSegmentsConditionEvaluator from './odp_segment_condition_evaluator';\nimport { Audience, Condition, OptimizelyUserContext } from '../../shared_types';\n\nconst logger = getLogger();\nconst MODULE_NAME = 'AUDIENCE_EVALUATOR';\n\nexport class AudienceEvaluator {\n  private typeToEvaluatorMap: {\n    [key: string]: {\n      [key: string]: (condition: Condition, user: OptimizelyUserContext) => boolean | null\n    };\n  };\n\n  /**\n   * Construct an instance of AudienceEvaluator with given options\n   * @param {Object=} UNSTABLE_conditionEvaluators     A map of condition evaluators provided by the consumer. This enables matching\n   *                                                   condition types which are not supported natively by the SDK. Note that built in\n   *                                                   Optimizely evaluators cannot be overridden.\n   * @constructor\n   */\n  constructor(UNSTABLE_conditionEvaluators: unknown) {\n    this.typeToEvaluatorMap = fns.assign({}, UNSTABLE_conditionEvaluators, {\n      custom_attribute: customAttributeConditionEvaluator,\n      third_party_dimension: odpSegmentsConditionEvaluator,\n    });\n  }\n\n  /**\n   * Determine if the given user attributes satisfy the given audience conditions\n   * @param  {Array<string|string[]}        audienceConditions    Audience conditions to match the user attributes against - can be an array\n   *                                                              of audience IDs, a nested array of conditions, or a single leaf condition.\n   *                                                              Examples: [\"5\", \"6\"], [\"and\", [\"or\", \"1\", \"2\"], \"3\"], \"1\"\n   * @param  {[id: string]: Audience}       audiencesById         Object providing access to full audience objects for audience IDs\n   *                                                              contained in audienceConditions. Keys should be audience IDs, values\n   *                                                              should be full audience objects with conditions properties\n   * @param  {OptimizelyUserContext}        userAttributes        User context which contains the attributes and segments which will be used in \n   *                                                              determining if audience conditions are met.\n   * @return {boolean}                                            true if the user attributes match the given audience conditions, false\n   *                                                              otherwise\n   */\n  evaluate(\n    audienceConditions: Array<string | string[]>,\n    audiencesById: { [id: string]: Audience },\n    user: OptimizelyUserContext,\n  ): boolean {\n    // if there are no audiences, return true because that means ALL users are included in the experiment\n    if (!audienceConditions || audienceConditions.length === 0) {\n      return true;\n    }\n\n    const evaluateAudience = (audienceId: string) => {\n      const audience = audiencesById[audienceId];\n      if (audience) {\n        logger.log(\n          LOG_LEVEL.DEBUG,\n          LOG_MESSAGES.EVALUATING_AUDIENCE, MODULE_NAME, audienceId, JSON.stringify(audience.conditions)\n        );\n        const result = conditionTreeEvaluator.evaluate(\n          audience.conditions as unknown[] ,\n          this.evaluateConditionWithUserAttributes.bind(this, user)\n        );\n        const resultText = result === null ? 'UNKNOWN' : result.toString().toUpperCase();\n        logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.AUDIENCE_EVALUATION_RESULT, MODULE_NAME, audienceId, resultText);\n        return result;\n      }\n      return null;\n    };\n\n    return !!conditionTreeEvaluator.evaluate(audienceConditions, evaluateAudience);\n  }\n\n  /**\n   * Wrapper around evaluator.evaluate that is passed to the conditionTreeEvaluator.\n   * Evaluates the condition provided given the user attributes if an evaluator has been defined for the condition type.\n   * @param  {OptimizelyUserContext}  user             Optimizely user context containing attributes and segments\n   * @param  {Condition}              condition        A single condition object to evaluate.\n   * @return {boolean|null}                            true if the condition is satisfied, null if a matcher is not found.\n   */\n  evaluateConditionWithUserAttributes(user: OptimizelyUserContext, condition: Condition): boolean | null {\n    const evaluator = this.typeToEvaluatorMap[condition.type];\n    if (!evaluator) {\n      logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.UNKNOWN_CONDITION_TYPE, MODULE_NAME, JSON.stringify(condition));\n      return null;\n    }\n    try {\n      return evaluator.evaluate(condition, user);\n    } catch (err: any) {\n      logger.log(\n        LOG_LEVEL.ERROR,\n        ERROR_MESSAGES.CONDITION_EVALUATOR_ERROR, MODULE_NAME, condition.type, err.message\n      );\n    }\n\n    return null;\n  }\n}\n\nexport default AudienceEvaluator;\n\nexport const createAudienceEvaluator = function(UNSTABLE_conditionEvaluators: unknown): AudienceEvaluator {\n  return new AudienceEvaluator(UNSTABLE_conditionEvaluators);\n};\n","/**\n * Copyright 2018, 2020, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Validates provided value is a non-empty string\n * @param  {unknown}  input\n * @return {boolean}  true for non-empty string, false otherwise\n */\nexport function validate(input: unknown): boolean {\n  return typeof input === 'string' && input !== '';\n}\n","/****************************************************************************\n * Copyright 2017-2022 Optimizely, Inc. and contributors                    *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\nimport { LogHandler } from '../../modules/logging';\nimport { sprintf } from '../../utils/fns';\n\nimport fns from '../../utils/fns';\nimport { bucket } from '../bucketer';\nimport {\n  AUDIENCE_EVALUATION_TYPES,\n  CONTROL_ATTRIBUTES,\n  DECISION_SOURCES,\n  ERROR_MESSAGES,\n  LOG_LEVEL,\n  LOG_MESSAGES,\n} from '../../utils/enums';\nimport {\n  getAudiencesById,\n  getExperimentAudienceConditions,\n  getExperimentFromId,\n  getExperimentFromKey,\n  getFlagVariationByKey,\n  getTrafficAllocation,\n  getVariationIdFromExperimentAndVariationKey,\n  getVariationFromId,\n  getVariationKeyFromId,\n  isActive,\n  ProjectConfig,\n} from '../project_config';\nimport { AudienceEvaluator, createAudienceEvaluator } from '../audience_evaluator';\nimport * as stringValidator from '../../utils/string_value_validator';\nimport {\n  BucketerParams,\n  DecisionResponse,\n  Experiment,\n  ExperimentBucketMap,\n  FeatureFlag,\n  OptimizelyDecideOption,\n  OptimizelyUserContext,\n  UserAttributes,\n  UserProfile,\n  UserProfileService,\n  Variation,\n} from '../../shared_types';\n\nconst MODULE_NAME = 'DECISION_SERVICE';\n\nexport interface DecisionObj {\n  experiment: Experiment | null;\n  variation: Variation | null;\n  decisionSource: string;\n}\n\ninterface DecisionServiceOptions {\n  userProfileService: UserProfileService | null;\n  logger: LogHandler;\n  UNSTABLE_conditionEvaluators: unknown;\n}\n\ninterface DeliveryRuleResponse<T, K> extends DecisionResponse<T> {\n  skipToEveryoneElse: K;\n}\n\n/**\n * Optimizely's decision service that determines which variation of an experiment the user will be allocated to.\n *\n * The decision service contains all logic around how a user decision is made. This includes all of the following (in order):\n *   1. Checking experiment status\n *   2. Checking forced bucketing\n *   3. Checking whitelisting\n *   4. Checking user profile service for past bucketing decisions (sticky bucketing)\n *   5. Checking audience targeting\n *   6. Using Murmurhash3 to bucket the user.\n *\n * @constructor\n * @param   {DecisionServiceOptions}      options\n * @returns {DecisionService}\n */\nexport class DecisionService {\n  private logger: LogHandler;\n  private audienceEvaluator: AudienceEvaluator;\n  private forcedVariationMap: { [key: string]: { [id: string]: string } };\n  private userProfileService: UserProfileService | null;\n\n  constructor(options: DecisionServiceOptions) {\n    this.audienceEvaluator = createAudienceEvaluator(options.UNSTABLE_conditionEvaluators);\n    this.forcedVariationMap = {};\n    this.logger = options.logger;\n    this.userProfileService = options.userProfileService || null;\n  }\n\n  /**\n   * Gets variation where visitor will be bucketed.\n   * @param  {ProjectConfig}                          configObj         The parsed project configuration object\n   * @param  {Experiment}                             experiment\n   * @param  {OptimizelyUserContext}                  user              A user context\n   * @param  {[key: string]: boolean}                 options           Optional map of decide options\n   * @return {DecisionResponse<string|null>}          DecisionResponse containing the variation the user is bucketed into\n   *                                                                    and the decide reasons.\n   */\n  getVariation(\n    configObj: ProjectConfig,\n    experiment: Experiment,\n    user: OptimizelyUserContext,\n    options: { [key: string]: boolean } = {}\n  ): DecisionResponse<string | null> {\n    const userId = user.getUserId();\n    const attributes = user.getAttributes();\n    // by default, the bucketing ID should be the user ID\n    const bucketingId = this.getBucketingId(userId, attributes);\n    const decideReasons: (string | number)[][] = [];\n    const experimentKey = experiment.key;\n    if (!this.checkIfExperimentIsActive(configObj, experimentKey)) {\n      this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.EXPERIMENT_NOT_RUNNING, MODULE_NAME, experimentKey);\n      decideReasons.push([LOG_MESSAGES.EXPERIMENT_NOT_RUNNING, MODULE_NAME, experimentKey]);\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n    const decisionForcedVariation = this.getForcedVariation(configObj, experimentKey, userId);\n    decideReasons.push(...decisionForcedVariation.reasons);\n    const forcedVariationKey = decisionForcedVariation.result;\n\n    if (forcedVariationKey) {\n      return {\n        result: forcedVariationKey,\n        reasons: decideReasons,\n      };\n    }\n    const decisionWhitelistedVariation = this.getWhitelistedVariation(experiment, userId);\n    decideReasons.push(...decisionWhitelistedVariation.reasons);\n    let variation = decisionWhitelistedVariation.result;\n    if (variation) {\n      return {\n        result: variation.key,\n        reasons: decideReasons,\n      };\n    }\n\n    const shouldIgnoreUPS = options[OptimizelyDecideOption.IGNORE_USER_PROFILE_SERVICE];\n    const experimentBucketMap = this.resolveExperimentBucketMap(userId, attributes);\n\n    // check for sticky bucketing if decide options do not include shouldIgnoreUPS\n    if (!shouldIgnoreUPS) {\n      variation = this.getStoredVariation(configObj, experiment, userId, experimentBucketMap);\n      if (variation) {\n        this.logger.log(\n          LOG_LEVEL.INFO,\n          LOG_MESSAGES.RETURNING_STORED_VARIATION,\n          MODULE_NAME,\n          variation.key,\n          experimentKey,\n          userId,\n        );\n        decideReasons.push([\n          LOG_MESSAGES.RETURNING_STORED_VARIATION,\n          MODULE_NAME,\n          variation.key,\n          experimentKey,\n          userId,\n        ]);\n        return {\n          result: variation.key,\n          reasons: decideReasons,\n        };\n      }\n    }\n\n    // Perform regular targeting and bucketing\n    const decisionifUserIsInAudience = this.checkIfUserIsInAudience(\n      configObj,\n      experiment,\n      AUDIENCE_EVALUATION_TYPES.EXPERIMENT,\n      user,\n      ''\n    );\n    decideReasons.push(...decisionifUserIsInAudience.reasons);\n    if (!decisionifUserIsInAudience.result) {\n      this.logger.log(\n        LOG_LEVEL.INFO,\n        LOG_MESSAGES.USER_NOT_IN_EXPERIMENT,\n        MODULE_NAME,\n        userId,\n        experimentKey,\n      );\n      decideReasons.push([\n        LOG_MESSAGES.USER_NOT_IN_EXPERIMENT,\n        MODULE_NAME,\n        userId,\n        experimentKey,\n      ]);\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n\n    const bucketerParams = this.buildBucketerParams(configObj, experiment, bucketingId, userId);\n    const decisionVariation = bucket(bucketerParams);\n    decideReasons.push(...decisionVariation.reasons);\n    const variationId = decisionVariation.result;\n    if (variationId) {\n      variation = configObj.variationIdMap[variationId];\n    }\n    if (!variation) {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_HAS_NO_VARIATION,\n        MODULE_NAME,\n        userId,\n        experimentKey,\n      );\n      decideReasons.push([\n        LOG_MESSAGES.USER_HAS_NO_VARIATION,\n        MODULE_NAME,\n        userId,\n        experimentKey,\n      ]);\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n\n    this.logger.log(\n      LOG_LEVEL.INFO,\n      LOG_MESSAGES.USER_HAS_VARIATION,\n      MODULE_NAME,\n      userId,\n      variation.key,\n      experimentKey,\n    );\n    decideReasons.push([\n      LOG_MESSAGES.USER_HAS_VARIATION,\n      MODULE_NAME,\n      userId,\n      variation.key,\n      experimentKey,\n    ]);\n    // persist bucketing if decide options do not include shouldIgnoreUPS\n    if (!shouldIgnoreUPS) {\n      this.saveUserProfile(experiment, variation, userId, experimentBucketMap);\n    }\n\n    return {\n      result: variation.key,\n      reasons: decideReasons,\n    };\n  }\n\n  /**\n   * Merges attributes from attributes[STICKY_BUCKETING_KEY] and userProfileService\n   * @param  {string}               userId\n   * @param  {UserAttributes}       attributes\n   * @return {ExperimentBucketMap}  finalized copy of experiment_bucket_map\n   */\n  private resolveExperimentBucketMap(\n    userId: string,\n    attributes?: UserAttributes\n  ): ExperimentBucketMap {\n    attributes = attributes || {};\n\n    const userProfile = this.getUserProfile(userId) || {} as UserProfile;\n    const attributeExperimentBucketMap = attributes[CONTROL_ATTRIBUTES.STICKY_BUCKETING_KEY];\n    return fns.assign({}, userProfile.experiment_bucket_map, attributeExperimentBucketMap);\n  }\n\n  /**\n   * Checks whether the experiment is running\n   * @param  {ProjectConfig}  configObj     The parsed project configuration object\n   * @param  {string}         experimentKey Key of experiment being validated\n   * @return {boolean}        True if experiment is running\n   */\n  private checkIfExperimentIsActive(configObj: ProjectConfig, experimentKey: string): boolean {\n    return isActive(configObj, experimentKey);\n  }\n\n  /**\n   * Checks if user is whitelisted into any variation and return that variation if so\n   * @param  {Experiment}                                 experiment\n   * @param  {string}                                     userId\n   * @return {DecisionResponse<Variation|null>}           DecisionResponse containing the forced variation if it exists\n   *                                                      or user ID and the decide reasons.\n   */\n  private getWhitelistedVariation(\n    experiment: Experiment,\n    userId: string\n  ): DecisionResponse<Variation | null> {\n    const decideReasons: (string | number)[][] = [];\n    if (experiment.forcedVariations && experiment.forcedVariations.hasOwnProperty(userId)) {\n      const forcedVariationKey = experiment.forcedVariations[userId];\n      if (experiment.variationKeyMap.hasOwnProperty(forcedVariationKey)) {\n        this.logger.log(\n          LOG_LEVEL.INFO,\n          LOG_MESSAGES.USER_FORCED_IN_VARIATION,\n          MODULE_NAME,\n          userId,\n          forcedVariationKey,\n        );\n        decideReasons.push([\n          LOG_MESSAGES.USER_FORCED_IN_VARIATION,\n          MODULE_NAME,\n          userId,\n          forcedVariationKey,\n        ]);\n        return {\n          result: experiment.variationKeyMap[forcedVariationKey],\n          reasons: decideReasons,\n        };\n      } else {\n        this.logger.log(\n          LOG_LEVEL.ERROR,\n          LOG_MESSAGES.FORCED_BUCKETING_FAILED,\n          MODULE_NAME,\n          forcedVariationKey,\n          userId,\n        );\n        decideReasons.push([\n          LOG_MESSAGES.FORCED_BUCKETING_FAILED,\n          MODULE_NAME,\n          forcedVariationKey,\n          userId,\n        ]);\n        return {\n          result: null,\n          reasons: decideReasons,\n        };\n      }\n    }\n\n    return {\n      result: null,\n      reasons: decideReasons,\n    };\n  }\n\n  /**\n   * Checks whether the user is included in experiment audience\n   * @param  {ProjectConfig}                configObj            The parsed project configuration object\n   * @param  {string}                       experimentKey        Key of experiment being validated\n   * @param  {string}                       evaluationAttribute  String representing experiment key or rule\n   * @param  {string}                       userId               ID of user\n   * @param  {UserAttributes}               attributes           Optional parameter for user's attributes\n   * @param  {string}                       loggingKey           String representing experiment key or rollout rule. To be used in log messages only.\n   * @return {DecisionResponse<boolean>}    DecisionResponse     DecisionResponse containing result true if user meets audience conditions and\n   *                                                             the decide reasons.\n   */\n  private checkIfUserIsInAudience(\n    configObj: ProjectConfig,\n    experiment: Experiment,\n    evaluationAttribute: string,\n    user: OptimizelyUserContext,\n    loggingKey?: string | number,\n  ): DecisionResponse<boolean> {\n    const decideReasons: (string | number)[][] = [];\n    const experimentAudienceConditions = getExperimentAudienceConditions(configObj, experiment.id);\n    const audiencesById = getAudiencesById(configObj);\n    this.logger.log(\n      LOG_LEVEL.DEBUG,\n      LOG_MESSAGES.EVALUATING_AUDIENCES_COMBINED,\n      MODULE_NAME,\n      evaluationAttribute,\n      loggingKey || experiment.key,\n      JSON.stringify(experimentAudienceConditions),\n    );\n    decideReasons.push([\n      LOG_MESSAGES.EVALUATING_AUDIENCES_COMBINED,\n      MODULE_NAME,\n      evaluationAttribute,\n      loggingKey || experiment.key,\n      JSON.stringify(experimentAudienceConditions),\n    ]);\n    const result = this.audienceEvaluator.evaluate(experimentAudienceConditions, audiencesById, user);\n    this.logger.log(\n      LOG_LEVEL.INFO,\n      LOG_MESSAGES.AUDIENCE_EVALUATION_RESULT_COMBINED,\n      MODULE_NAME,\n      evaluationAttribute,\n      loggingKey || experiment.key,\n      result.toString().toUpperCase(),\n    );\n    decideReasons.push([\n      LOG_MESSAGES.AUDIENCE_EVALUATION_RESULT_COMBINED,\n      MODULE_NAME,\n      evaluationAttribute,\n      loggingKey || experiment.key,\n      result.toString().toUpperCase(),\n    ]);\n\n    return {\n      result: result,\n      reasons: decideReasons,\n    };\n  }\n\n  /**\n   * Given an experiment key and user ID, returns params used in bucketer call\n   * @param  {ProjectConfig}         configObj     The parsed project configuration object\n   * @param  {string}                experimentKey Experiment key used for bucketer\n   * @param  {string}                bucketingId   ID to bucket user into\n   * @param  {string}                userId        ID of user to be bucketed\n   * @return {BucketerParams}\n   */\n  private buildBucketerParams(\n    configObj: ProjectConfig,\n    experiment: Experiment,\n    bucketingId: string,\n    userId: string\n  ): BucketerParams {\n    return {\n      bucketingId,\n      experimentId: experiment.id,\n      experimentKey: experiment.key,\n      experimentIdMap: configObj.experimentIdMap,\n      experimentKeyMap: configObj.experimentKeyMap,\n      groupIdMap: configObj.groupIdMap,\n      logger: this.logger,\n      trafficAllocationConfig: getTrafficAllocation(configObj, experiment.id),\n      userId,\n      variationIdMap: configObj.variationIdMap,\n    }\n  }\n\n  /**\n   * Pull the stored variation out of the experimentBucketMap for an experiment/userId\n   * @param  {ProjectConfig}        configObj            The parsed project configuration object\n   * @param  {Experiment}           experiment\n   * @param  {string}               userId\n   * @param  {ExperimentBucketMap}  experimentBucketMap  mapping experiment => { variation_id: <variationId> }\n   * @return {Variation|null}       the stored variation or null if the user profile does not have one for the given experiment\n   */\n  private getStoredVariation(\n    configObj: ProjectConfig,\n    experiment: Experiment,\n    userId: string,\n    experimentBucketMap: ExperimentBucketMap\n  ): Variation | null {\n    if (experimentBucketMap.hasOwnProperty(experiment.id)) {\n      const decision = experimentBucketMap[experiment.id];\n      const variationId = decision.variation_id;\n      if (configObj.variationIdMap.hasOwnProperty(variationId)) {\n        return configObj.variationIdMap[decision.variation_id];\n      } else {\n        this.logger.log(\n          LOG_LEVEL.INFO,\n          LOG_MESSAGES.SAVED_VARIATION_NOT_FOUND,\n          MODULE_NAME, userId,\n          variationId,\n          experiment.key,\n        );\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the user profile with the given user ID\n   * @param  {string} userId\n   * @return {UserProfile|null} the stored user profile or null if one isn't found\n   */\n  private getUserProfile(userId: string): UserProfile | null {\n    const userProfile = {\n      user_id: userId,\n      experiment_bucket_map: {},\n    };\n\n    if (!this.userProfileService) {\n      return userProfile;\n    }\n\n    try {\n      return this.userProfileService.lookup(userId);\n    } catch (ex: any) {\n      this.logger.log(\n        LOG_LEVEL.ERROR,\n        ERROR_MESSAGES.USER_PROFILE_LOOKUP_ERROR,\n        MODULE_NAME,\n        userId,\n        ex.message,\n      );\n    }\n\n    return null;\n  }\n\n  /**\n   * Saves the bucketing decision to the user profile\n   * @param {Experiment}          experiment\n   * @param {Variation}           variation\n   * @param {string}              userId\n   * @param {ExperimentBucketMap} experimentBucketMap\n   */\n  private saveUserProfile(\n    experiment: Experiment,\n    variation: Variation,\n    userId: string,\n    experimentBucketMap: ExperimentBucketMap\n  ): void {\n    if (!this.userProfileService) {\n      return;\n    }\n\n    try {\n      experimentBucketMap[experiment.id] = {\n        variation_id: variation.id\n      };\n\n      this.userProfileService.save({\n        user_id: userId,\n        experiment_bucket_map: experimentBucketMap,\n      });\n\n      this.logger.log(\n        LOG_LEVEL.INFO,\n        LOG_MESSAGES.SAVED_VARIATION,\n        MODULE_NAME,\n        variation.key,\n        experiment.key,\n        userId,\n      );\n    } catch (ex: any) {\n      this.logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.USER_PROFILE_SAVE_ERROR, MODULE_NAME, userId, ex.message);\n    }\n  }\n\n  /**\n   * Given a feature, user ID, and attributes, returns a decision response containing \n   * an object representing a decision and decide reasons. If the user was bucketed into\n   * a variation for the given feature and attributes, the decision object will have variation and\n   * experiment properties (both objects), as well as a decisionSource property.\n   * decisionSource indicates whether the decision was due to a rollout or an\n   * experiment.\n   * @param   {ProjectConfig}               configObj         The parsed project configuration object\n   * @param   {FeatureFlag}                 feature           A feature flag object from project configuration\n   * @param   {OptimizelyUserContext}       user              A user context\n   * @param   {[key: string]: boolean}      options           Map of decide options\n   * @return  {DecisionResponse}            DecisionResponse  DecisionResponse containing an object with experiment, variation, and decisionSource\n   *                                                          properties and decide reasons. If the user was not bucketed into a variation, the variation\n   *                                                          property in decision object is null.\n   */\n  getVariationForFeature(\n    configObj: ProjectConfig,\n    feature: FeatureFlag,\n    user: OptimizelyUserContext,\n    options: { [key: string]: boolean } = {}\n  ): DecisionResponse<DecisionObj> {\n\n    const decideReasons: (string | number)[][] = [];\n    const decisionVariation = this.getVariationForFeatureExperiment(configObj, feature, user, options);\n    decideReasons.push(...decisionVariation.reasons);\n    const experimentDecision = decisionVariation.result;\n\n    if (experimentDecision.variation !== null) {\n      return {\n        result: experimentDecision,\n        reasons: decideReasons,\n      };\n    }\n\n    const decisionRolloutVariation = this.getVariationForRollout(configObj, feature, user);\n    decideReasons.push(...decisionRolloutVariation.reasons);\n    const rolloutDecision = decisionRolloutVariation.result;\n    const userId = user.getUserId();\n    if (rolloutDecision.variation) {\n      this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.USER_IN_ROLLOUT, MODULE_NAME, userId, feature.key);\n      decideReasons.push([LOG_MESSAGES.USER_IN_ROLLOUT, MODULE_NAME, userId, feature.key]);\n      return {\n        result: rolloutDecision,\n        reasons: decideReasons,\n      };\n    }\n\n    this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.USER_NOT_IN_ROLLOUT, MODULE_NAME, userId, feature.key);\n    decideReasons.push([LOG_MESSAGES.USER_NOT_IN_ROLLOUT, MODULE_NAME, userId, feature.key]);\n    return {\n      result: rolloutDecision,\n      reasons: decideReasons,\n    };\n  }\n\n  private getVariationForFeatureExperiment(\n    configObj: ProjectConfig,\n    feature: FeatureFlag,\n    user: OptimizelyUserContext,\n    options: { [key: string]: boolean } = {}\n  ): DecisionResponse<DecisionObj> {\n\n    const decideReasons: (string | number)[][] = [];\n    let variationKey = null;\n    let decisionVariation;\n    let index;\n    let variationForFeatureExperiment;\n\n    // Check if the feature flag is under an experiment and the the user is bucketed into one of these experiments\n    if (feature.experimentIds.length > 0) {\n      // Evaluate each experiment ID and return the first bucketed experiment variation\n      for (index = 0; index < feature.experimentIds.length; index++) {\n        const experiment = getExperimentFromId(configObj, feature.experimentIds[index], this.logger);\n        if (experiment) {\n          decisionVariation = this.getVariationFromExperimentRule(configObj, feature.key, experiment, user, options);\n          decideReasons.push(...decisionVariation.reasons);\n          variationKey = decisionVariation.result;\n          if (variationKey) {\n            let variation = null;\n            variation = experiment.variationKeyMap[variationKey];\n            if (!variation) {\n              variation = getFlagVariationByKey(configObj, feature.key, variationKey);\n            }\n            variationForFeatureExperiment = {\n              experiment: experiment,\n              variation: variation,\n              decisionSource: DECISION_SOURCES.FEATURE_TEST,\n            };\n\n            return {\n              result: variationForFeatureExperiment,\n              reasons: decideReasons,\n            }\n          }\n        }\n      }\n    } else {\n      this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.FEATURE_HAS_NO_EXPERIMENTS, MODULE_NAME, feature.key);\n      decideReasons.push([LOG_MESSAGES.FEATURE_HAS_NO_EXPERIMENTS, MODULE_NAME, feature.key]);\n    }\n\n    variationForFeatureExperiment = {\n      experiment: null,\n      variation: null,\n      decisionSource: DECISION_SOURCES.FEATURE_TEST,\n    };\n\n    return {\n      result: variationForFeatureExperiment,\n      reasons: decideReasons,\n    };\n  }\n\n  private getVariationForRollout(\n    configObj: ProjectConfig,\n    feature: FeatureFlag,\n    user: OptimizelyUserContext,\n  ): DecisionResponse<DecisionObj> {\n    const decideReasons: (string | number)[][] = [];\n    let decisionObj: DecisionObj;\n    if (!feature.rolloutId) {\n      this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.NO_ROLLOUT_EXISTS, MODULE_NAME, feature.key);\n      decideReasons.push([LOG_MESSAGES.NO_ROLLOUT_EXISTS, MODULE_NAME, feature.key]);\n      decisionObj = {\n        experiment: null,\n        variation: null,\n        decisionSource: DECISION_SOURCES.ROLLOUT,\n      };\n\n      return {\n        result: decisionObj,\n        reasons: decideReasons,\n      };\n    }\n\n    const rollout = configObj.rolloutIdMap[feature.rolloutId];\n    if (!rollout) {\n      this.logger.log(\n        LOG_LEVEL.ERROR,\n        ERROR_MESSAGES.INVALID_ROLLOUT_ID,\n        MODULE_NAME,\n        feature.rolloutId,\n        feature.key,\n      );\n      decideReasons.push([ERROR_MESSAGES.INVALID_ROLLOUT_ID, MODULE_NAME, feature.rolloutId, feature.key]);\n      decisionObj = {\n        experiment: null,\n        variation: null,\n        decisionSource: DECISION_SOURCES.ROLLOUT,\n      };\n      return {\n        result: decisionObj,\n        reasons: decideReasons,\n      };\n    }\n\n    const rolloutRules = rollout.experiments;\n    if (rolloutRules.length === 0) {\n      this.logger.log(\n        LOG_LEVEL.ERROR,\n        LOG_MESSAGES.ROLLOUT_HAS_NO_EXPERIMENTS,\n        MODULE_NAME,\n        feature.rolloutId,\n      );\n      decideReasons.push([LOG_MESSAGES.ROLLOUT_HAS_NO_EXPERIMENTS, MODULE_NAME, feature.rolloutId]);\n      decisionObj = {\n        experiment: null,\n        variation: null,\n        decisionSource: DECISION_SOURCES.ROLLOUT,\n      };\n      return {\n        result: decisionObj,\n        reasons: decideReasons,\n      };\n    }\n    let decisionVariation;\n    let skipToEveryoneElse;\n    let variation;\n    let rolloutRule;\n    let index = 0;\n    while (index < rolloutRules.length) {\n      decisionVariation = this.getVariationFromDeliveryRule(configObj, feature.key, rolloutRules, index, user);\n      decideReasons.push(...decisionVariation.reasons);\n      variation = decisionVariation.result;\n      skipToEveryoneElse = decisionVariation.skipToEveryoneElse;\n      if (variation) {\n        rolloutRule = configObj.experimentIdMap[rolloutRules[index].id];\n        decisionObj = {\n          experiment: rolloutRule,\n          variation: variation,\n          decisionSource: DECISION_SOURCES.ROLLOUT\n        };\n        return {\n          result: decisionObj,\n          reasons: decideReasons,\n        };\n      }\n      // the last rule is special for \"Everyone Else\"\n      index = skipToEveryoneElse ? (rolloutRules.length - 1) : (index + 1);\n    }\n\n    decisionObj = {\n      experiment: null,\n      variation: null,\n      decisionSource: DECISION_SOURCES.ROLLOUT,\n    };\n\n    return {\n      result: decisionObj,\n      reasons: decideReasons,\n    };\n  }\n\n  /**\n   * Get bucketing Id from user attributes.\n   * @param   {string}          userId\n   * @param   {UserAttributes}  attributes\n   * @returns {string}          Bucketing Id if it is a string type in attributes, user Id otherwise.\n   */\n  private getBucketingId(userId: string, attributes?: UserAttributes): string {\n    let bucketingId = userId;\n\n    // If the bucketing ID key is defined in attributes, than use that in place of the userID for the murmur hash key\n    if (\n      attributes != null &&\n      typeof attributes === 'object' &&\n      attributes.hasOwnProperty(CONTROL_ATTRIBUTES.BUCKETING_ID)\n    ) {\n      if (typeof attributes[CONTROL_ATTRIBUTES.BUCKETING_ID] === 'string') {\n        bucketingId = String(attributes[CONTROL_ATTRIBUTES.BUCKETING_ID]);\n        this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.VALID_BUCKETING_ID, MODULE_NAME, bucketingId);\n      } else {\n        this.logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.BUCKETING_ID_NOT_STRING, MODULE_NAME);\n      }\n    }\n\n    return bucketingId;\n  }\n\n  /**\n   * Finds a validated forced decision for specific flagKey and optional ruleKey.\n   * @param     {ProjectConfig}         config               A projectConfig.\n   * @param     {OptimizelyUserContext} user                 A Optimizely User Context.\n   * @param     {string}                flagKey              A flagKey.\n   * @param     {ruleKey}               ruleKey              A ruleKey (optional).\n   * @return    {DecisionResponse<Variation|null>}  DecisionResponse object containing valid variation object and decide reasons.\n   */\n  findValidatedForcedDecision(\n    config: ProjectConfig,\n    user: OptimizelyUserContext,\n    flagKey: string,\n    ruleKey?: string\n  ): DecisionResponse<Variation | null> {\n\n    const decideReasons: (string | number)[][] = [];\n    const forcedDecision = user.getForcedDecision({ flagKey, ruleKey });\n    let variation = null;\n    let variationKey;\n    const userId = user.getUserId()\n    if (config && forcedDecision) {\n      variationKey = forcedDecision.variationKey;\n      variation = getFlagVariationByKey(config, flagKey, variationKey);\n      if (variation) {\n        if (ruleKey) {\n          this.logger.log(\n            LOG_LEVEL.INFO,\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED,\n            variationKey,\n            flagKey,\n            ruleKey,\n            userId\n          );\n          decideReasons.push([\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED,\n            variationKey,\n            flagKey,\n            ruleKey,\n            userId\n          ]);\n        } else {\n          this.logger.log(\n            LOG_LEVEL.INFO,\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED,\n            variationKey,\n            flagKey,\n            userId\n          );\n          decideReasons.push([\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED,\n            variationKey,\n            flagKey,\n            userId\n          ])\n        }\n      } else {\n        if (ruleKey) {\n          this.logger.log(\n            LOG_LEVEL.INFO,\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED_BUT_INVALID,\n            flagKey,\n            ruleKey,\n            userId\n          );\n          decideReasons.push([\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED_BUT_INVALID,\n            flagKey,\n            ruleKey,\n            userId\n          ]);\n        } else {\n          this.logger.log(\n            LOG_LEVEL.INFO,\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED_BUT_INVALID,\n            flagKey,\n            userId\n          );\n          decideReasons.push([\n            LOG_MESSAGES.USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED_BUT_INVALID,\n            flagKey,\n            userId\n          ])\n        }\n      }\n    }\n\n    return {\n      result: variation,\n      reasons: decideReasons,\n    }\n  }\n\n  /**\n   * Removes forced variation for given userId and experimentKey\n   * @param  {string} userId         String representing the user id\n   * @param  {string} experimentId   Number representing the experiment id\n   * @param  {string} experimentKey  Key representing the experiment id\n   * @throws If the user id is not valid or not in the forced variation map\n   */\n  removeForcedVariation(userId: string, experimentId: string, experimentKey: string): void {\n    if (!userId) {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_USER_ID, MODULE_NAME));\n    }\n\n    if (this.forcedVariationMap.hasOwnProperty(userId)) {\n      delete this.forcedVariationMap[userId][experimentId];\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.VARIATION_REMOVED_FOR_USER,\n        MODULE_NAME,\n        experimentKey,\n        userId,\n      );\n    } else {\n      throw new Error(sprintf(ERROR_MESSAGES.USER_NOT_IN_FORCED_VARIATION, MODULE_NAME, userId));\n    }\n  }\n\n  /**\n   * Sets forced variation for given userId and experimentKey\n   * @param  {string} userId        String representing the user id\n   * @param  {string} experimentId  Number representing the experiment id\n   * @param  {number} variationId   Number representing the variation id\n   * @throws If the user id is not valid\n   */\n  private setInForcedVariationMap(userId: string, experimentId: string, variationId: string): void {\n    if (this.forcedVariationMap.hasOwnProperty(userId)) {\n      this.forcedVariationMap[userId][experimentId] = variationId;\n    } else {\n      this.forcedVariationMap[userId] = {};\n      this.forcedVariationMap[userId][experimentId] = variationId;\n    }\n\n    this.logger.log(\n      LOG_LEVEL.DEBUG,\n      LOG_MESSAGES.USER_MAPPED_TO_FORCED_VARIATION,\n      MODULE_NAME,\n      variationId,\n      experimentId,\n      userId,\n    );\n  }\n\n  /**\n   * Gets the forced variation key for the given user and experiment.\n   * @param  {ProjectConfig}                  configObj         Object representing project configuration\n   * @param  {string}                         experimentKey     Key for experiment.\n   * @param  {string}                         userId            The user Id.\n   * @return {DecisionResponse<string|null>}                    DecisionResponse containing variation which the given user and experiment\n   *                                                            should be forced into and the decide reasons.\n   */\n  getForcedVariation(\n    configObj: ProjectConfig,\n    experimentKey: string,\n    userId: string\n  ): DecisionResponse<string | null> {\n    const decideReasons: (string | number)[][] = [];\n    const experimentToVariationMap = this.forcedVariationMap[userId];\n    if (!experimentToVariationMap) {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_HAS_NO_FORCED_VARIATION,\n        MODULE_NAME,\n        userId,\n      );\n\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n\n    let experimentId;\n    try {\n      const experiment = getExperimentFromKey(configObj, experimentKey);\n      if (experiment.hasOwnProperty('id')) {\n        experimentId = experiment['id'];\n      } else {\n        // catching improperly formatted experiments\n        this.logger.log(\n          LOG_LEVEL.ERROR,\n          ERROR_MESSAGES.IMPROPERLY_FORMATTED_EXPERIMENT,\n          MODULE_NAME,\n          experimentKey,\n        );\n        decideReasons.push([\n          ERROR_MESSAGES.IMPROPERLY_FORMATTED_EXPERIMENT,\n          MODULE_NAME,\n          experimentKey,\n        ]);\n\n        return {\n          result: null,\n          reasons: decideReasons,\n        };\n      }\n    } catch (ex: any) {\n      // catching experiment not in datafile\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      decideReasons.push(ex.message);\n\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n\n    const variationId = experimentToVariationMap[experimentId];\n    if (!variationId) {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_HAS_NO_FORCED_VARIATION_FOR_EXPERIMENT,\n        MODULE_NAME,\n        experimentKey,\n        userId,\n      );\n      return {\n        result: null,\n        reasons: decideReasons,\n      };\n    }\n\n    const variationKey = getVariationKeyFromId(configObj, variationId);\n    if (variationKey) {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_HAS_FORCED_VARIATION,\n        MODULE_NAME,\n        variationKey,\n        experimentKey,\n        userId,\n      );\n      decideReasons.push([\n        LOG_MESSAGES.USER_HAS_FORCED_VARIATION,\n        MODULE_NAME,\n        variationKey,\n        experimentKey,\n        userId,\n      ]);\n    } else {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_HAS_NO_FORCED_VARIATION_FOR_EXPERIMENT,\n        MODULE_NAME,\n        experimentKey,\n        userId,\n      );\n    }\n\n    return {\n      result: variationKey,\n      reasons: decideReasons,\n    };\n  }\n\n  /**\n   * Sets the forced variation for a user in a given experiment\n   * @param  {ProjectConfig}  configObj      Object representing project configuration\n   * @param  {string}         experimentKey  Key for experiment.\n   * @param  {string}         userId         The user Id.\n   * @param  {string|null}    variationKey   Key for variation. If null, then clear the existing experiment-to-variation mapping\n   * @return {boolean}     A boolean value that indicates if the set completed successfully.\n   */\n  setForcedVariation(\n    configObj: ProjectConfig,\n    experimentKey: string,\n    userId: string,\n    variationKey: string | null\n  ): boolean {\n    if (variationKey != null && !stringValidator.validate(variationKey)) {\n      this.logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.INVALID_VARIATION_KEY, MODULE_NAME);\n      return false;\n    }\n\n    let experimentId;\n    try {\n      const experiment = getExperimentFromKey(configObj, experimentKey);\n      if (experiment.hasOwnProperty('id')) {\n        experimentId = experiment['id'];\n      } else {\n        // catching improperly formatted experiments\n        this.logger.log(\n          LOG_LEVEL.ERROR,\n          ERROR_MESSAGES.IMPROPERLY_FORMATTED_EXPERIMENT,\n          MODULE_NAME,\n          experimentKey,\n        );\n        return false;\n      }\n    } catch (ex: any) {\n      // catching experiment not in datafile\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      return false;\n    }\n\n    if (variationKey == null) {\n      try {\n        this.removeForcedVariation(userId, experimentId, experimentKey);\n        return true;\n      } catch (ex: any) {\n        this.logger.log(LOG_LEVEL.ERROR, ex.message);\n        return false;\n      }\n    }\n\n    const variationId = getVariationIdFromExperimentAndVariationKey(configObj, experimentKey, variationKey);\n\n    if (!variationId) {\n      this.logger.log(\n        LOG_LEVEL.ERROR,\n        ERROR_MESSAGES.NO_VARIATION_FOR_EXPERIMENT_KEY,\n        MODULE_NAME,\n        variationKey,\n        experimentKey,\n      );\n      return false;\n    }\n\n    try {\n      this.setInForcedVariationMap(userId, experimentId, variationId);\n      return true;\n    } catch (ex: any) {\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      return false;\n    }\n  }\n\n  getVariationFromExperimentRule(\n    configObj: ProjectConfig,\n    flagKey: string,\n    rule: Experiment,\n    user: OptimizelyUserContext,\n    options: { [key: string]: boolean } = {}\n  ): DecisionResponse<string | null> {\n    const decideReasons: (string | number)[][] = [];\n\n    // check forced decision first\n    const forcedDecisionResponse = this.findValidatedForcedDecision(configObj, user, flagKey, rule.key);\n    decideReasons.push(...forcedDecisionResponse.reasons);\n\n    const forcedVariation = forcedDecisionResponse.result;\n    if (forcedVariation) {\n      return {\n        result: forcedVariation.key,\n        reasons: decideReasons,\n      };\n    }\n    const decisionVariation = this.getVariation(configObj, rule, user, options);\n    decideReasons.push(...decisionVariation.reasons);\n    const variationKey = decisionVariation.result;\n\n    return {\n      result: variationKey,\n      reasons: decideReasons,\n    };\n  }\n\n  getVariationFromDeliveryRule(\n    configObj: ProjectConfig,\n    flagKey: string,\n    rules: Experiment[],\n    ruleIndex: number,\n    user: OptimizelyUserContext\n  ): DeliveryRuleResponse<Variation | null, boolean> {\n    const decideReasons: (string | number)[][] = [];\n    let skipToEveryoneElse = false;\n\n    // check forced decision first\n    const rule = rules[ruleIndex];\n    const forcedDecisionResponse = this.findValidatedForcedDecision(configObj, user, flagKey, rule.key);\n    decideReasons.push(...forcedDecisionResponse.reasons);\n\n    const forcedVariation = forcedDecisionResponse.result;\n    if (forcedVariation) {\n      return {\n        result: forcedVariation,\n        reasons: decideReasons,\n        skipToEveryoneElse,\n      };\n    }\n\n    const userId = user.getUserId();\n    const attributes = user.getAttributes();\n    const bucketingId = this.getBucketingId(userId, attributes);\n    const everyoneElse = ruleIndex === rules.length - 1;\n    const loggingKey = everyoneElse ? \"Everyone Else\" : ruleIndex + 1;\n\n    let bucketedVariation = null;\n    let bucketerVariationId;\n    let bucketerParams;\n    let decisionVariation;\n    const decisionifUserIsInAudience = this.checkIfUserIsInAudience(\n      configObj,\n      rule,\n      AUDIENCE_EVALUATION_TYPES.RULE,\n      user,\n      loggingKey\n    );\n    decideReasons.push(...decisionifUserIsInAudience.reasons);\n    if (decisionifUserIsInAudience.result) {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_MEETS_CONDITIONS_FOR_TARGETING_RULE,\n        MODULE_NAME,\n        userId,\n        loggingKey\n      );\n      decideReasons.push([\n        LOG_MESSAGES.USER_MEETS_CONDITIONS_FOR_TARGETING_RULE,\n        MODULE_NAME,\n        userId,\n        loggingKey\n      ]);\n\n      bucketerParams = this.buildBucketerParams(configObj, rule, bucketingId, userId);\n      decisionVariation = bucket(bucketerParams);\n      decideReasons.push(...decisionVariation.reasons);\n      bucketerVariationId = decisionVariation.result;\n      if (bucketerVariationId) {\n        bucketedVariation = getVariationFromId(configObj, bucketerVariationId);\n      }\n      if (bucketedVariation) {\n        this.logger.log(\n          LOG_LEVEL.DEBUG,\n          LOG_MESSAGES.USER_BUCKETED_INTO_TARGETING_RULE,\n          MODULE_NAME,\n          userId,\n          loggingKey\n        );\n        decideReasons.push([\n          LOG_MESSAGES.USER_BUCKETED_INTO_TARGETING_RULE,\n          MODULE_NAME,\n          userId,\n          loggingKey]);\n      } else if (!everyoneElse) {\n        // skip this logging for EveryoneElse since this has a message not for EveryoneElse\n        this.logger.log(\n          LOG_LEVEL.DEBUG,\n          LOG_MESSAGES.USER_NOT_BUCKETED_INTO_TARGETING_RULE,\n          MODULE_NAME,\n          userId,\n          loggingKey\n        );\n        decideReasons.push([\n          LOG_MESSAGES.USER_NOT_BUCKETED_INTO_TARGETING_RULE,\n          MODULE_NAME,\n          userId,\n          loggingKey\n        ]);\n\n        // skip the rest of rollout rules to the everyone-else rule if audience matches but not bucketed\n        skipToEveryoneElse = true;\n      }\n    } else {\n      this.logger.log(\n        LOG_LEVEL.DEBUG,\n        LOG_MESSAGES.USER_DOESNT_MEET_CONDITIONS_FOR_TARGETING_RULE,\n        MODULE_NAME,\n        userId,\n        loggingKey\n      );\n      decideReasons.push([\n        LOG_MESSAGES.USER_DOESNT_MEET_CONDITIONS_FOR_TARGETING_RULE,\n        MODULE_NAME,\n        userId,\n        loggingKey\n      ]);\n    }\n\n    return {\n      result: bucketedVariation,\n      reasons: decideReasons,\n      skipToEveryoneElse,\n    };\n  }\n}\n\n/**\n * Creates an instance of the DecisionService.\n * @param  {DecisionServiceOptions}     options       Configuration options\n * @return {Object}                     An instance of the DecisionService\n */\nexport function createDecisionService(options: DecisionServiceOptions): DecisionService {\n  return new DecisionService(options);\n}\n","/**\n * Copyright 2017, 2019-2020, 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventTags } from '../../modules/event_processor';\nimport { LoggerFacade } from '../../modules/logging';\n\nimport {\n  LOG_LEVEL,\n  LOG_MESSAGES,\n  RESERVED_EVENT_KEYWORDS,\n} from '../enums';\n\n/**\n * Provides utility method for parsing event tag values\n */\nconst MODULE_NAME = 'EVENT_TAG_UTILS';\nconst REVENUE_EVENT_METRIC_NAME = RESERVED_EVENT_KEYWORDS.REVENUE;\nconst VALUE_EVENT_METRIC_NAME = RESERVED_EVENT_KEYWORDS.VALUE;\n\n/**\n * Grab the revenue value from the event tags. \"revenue\" is a reserved keyword.\n * @param {EventTags} eventTags\n * @param {LoggerFacade} logger\n * @return {number|null}\n */\nexport function getRevenueValue(eventTags: EventTags, logger: LoggerFacade): number | null {\n  const rawValue = eventTags[REVENUE_EVENT_METRIC_NAME];\n\n  if (rawValue == null) { // null or undefined event values\n    return null;\n  }\n\n  const parsedRevenueValue = typeof rawValue === 'string' ? parseInt(rawValue) : rawValue;\n\n  if (isFinite(parsedRevenueValue)) {\n    logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.PARSED_REVENUE_VALUE, MODULE_NAME, parsedRevenueValue);\n    return parsedRevenueValue;\n  } else { // NaN, +/- infinity values\n    logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.FAILED_TO_PARSE_REVENUE, MODULE_NAME, rawValue);\n    return null;\n  }\n}\n\n/**\n * Grab the event value from the event tags. \"value\" is a reserved keyword.\n * @param {EventTags} eventTags\n * @param {LoggerFacade} logger\n * @return {number|null}\n */\nexport function getEventValue(eventTags: EventTags, logger: LoggerFacade): number | null {\n  const rawValue = eventTags[VALUE_EVENT_METRIC_NAME];\n\n  if (rawValue == null) { // null or undefined event values\n    return null;\n  }\n\n  const parsedEventValue = typeof rawValue === 'string' ? parseFloat(rawValue) : rawValue;\n\n  if (isFinite(parsedEventValue)) {\n    logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.PARSED_NUMERIC_VALUE, MODULE_NAME, parsedEventValue);\n    return parsedEventValue;\n  } else { // NaN, +/- infinity values\n    logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.FAILED_TO_PARSE_VALUE, MODULE_NAME, rawValue);\n    return null;\n  }\n}","/**\n * Copyright 2016, 2018-2020, 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { sprintf } from '../../utils/fns';\nimport { ObjectWithUnknownProperties } from '../../shared_types';\n\nimport fns from '../../utils/fns';\nimport { ERROR_MESSAGES } from '../enums';\n\nconst MODULE_NAME = 'ATTRIBUTES_VALIDATOR';\n\n/**\n * Validates user's provided attributes\n * @param  {unknown}  attributes\n * @return {boolean}  true if the attributes are valid\n * @throws If the attributes are not valid\n */\n\nexport function validate(attributes: unknown): boolean {\n  if (typeof attributes === 'object' && !Array.isArray(attributes) && attributes !== null) {\n    Object.keys(attributes).forEach(function(key) {\n      if (typeof (attributes as ObjectWithUnknownProperties)[key] === 'undefined') {\n        throw new Error(sprintf(ERROR_MESSAGES.UNDEFINED_ATTRIBUTE, MODULE_NAME, key));\n      }\n    });\n    return true;\n  } else {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_ATTRIBUTES, MODULE_NAME));\n  }\n}\n\n/**\n * Validates user's provided attribute\n * @param  {unknown}  attributeKey\n * @param  {unknown}  attributeValue\n * @return {boolean}  true if the attribute is valid\n */\nexport function isAttributeValid(attributeKey: unknown, attributeValue: unknown): boolean {\n  return (\n    typeof attributeKey === 'string' &&\n    (typeof attributeValue === 'string' ||\n      typeof attributeValue === 'boolean' ||\n      (fns.isNumber(attributeValue) && fns.isSafeInteger(attributeValue)))\n  );\n}\n","/**\n * Copyright 2016-2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LoggerFacade } from '../../modules/logging';\nimport { EventV1 as CommonEventParams } from '../../modules/event_processor';\n\nimport fns from '../../utils/fns';\nimport { CONTROL_ATTRIBUTES, RESERVED_EVENT_KEYWORDS } from '../../utils/enums';\nimport {\n  getAttributeId,\n  getEventId,\n  getLayerId,\n  getVariationKeyFromId,\n  ProjectConfig,\n} from '../project_config';\nimport * as eventTagUtils from '../../utils/event_tag_utils';\nimport { isAttributeValid } from '../../utils/attributes_validator';\nimport { EventTags, UserAttributes, Event as EventLoggingEndpoint } from '../../shared_types';\n\nconst ACTIVATE_EVENT_KEY = 'campaign_activated';\nconst CUSTOM_ATTRIBUTE_FEATURE_TYPE = 'custom';\nconst ENDPOINT = 'https://logx.optimizely.com/v1/events';\nconst HTTP_VERB = 'POST';\n\ninterface ImpressionOptions {\n  // Object representing user attributes and values which need to be recorded\n  attributes?: UserAttributes;\n  // The client we are using: node or javascript\n  clientEngine: string;\n  // The version of the client\n  clientVersion: string;\n  // Object representing project configuration, including datafile information and mappings for quick lookup\n  configObj: ProjectConfig;\n  // Experiment for which impression needs to be recorded\n  experimentId: string | null;\n  // Key of an experiment for which impression needs to be recorded\n  ruleKey: string;\n  // Key for a feature flag\n  flagKey: string;\n  // Boolean representing if feature is enabled\n  enabled: boolean;\n  // Type for the decision source\n  ruleType: string;\n  // Event key representing the event which needs to be recorded\n  eventKey?: string;\n  // ID for variation which would be presented to user\n  variationId: string | null;\n  // Logger object\n  logger: LoggerFacade;\n  // ID for user\n  userId: string;\n}\n\ninterface ConversionEventOptions {\n  // Object representing user attributes and values which need to be recorded\n  attributes?: UserAttributes;\n  // The client we are using: node or javascript\n  clientEngine: string;\n  // The version of the client\n  clientVersion: string;\n  // Object representing project configuration, including datafile information and mappings for quick lookup\n  configObj: ProjectConfig;\n  // Event key representing the event which needs to be recorded\n  eventKey: string;\n  // Logger object\n  logger: LoggerFacade;\n  // ID for user\n  userId: string;\n  // Object with event-specific tags\n  eventTags?: EventTags;\n}\n\ntype Metadata = {\n  flag_key: string;\n  rule_key: string;\n  rule_type: string;\n  variation_key: string;\n  enabled: boolean;\n}\n\ntype Decision = {\n  campaign_id: string | null;\n  experiment_id: string | null;\n  variation_id: string | null;\n  metadata: Metadata;\n}\n\ntype SnapshotEvent = {\n  entity_id: string | null;\n  timestamp: number;\n  uuid: string;\n  key: string;\n  revenue?: number;\n  value?: number;\n  tags?: EventTags;\n}\n\ninterface Snapshot {\n  decisions?: Decision[];\n  events: SnapshotEvent[];\n}\n\n/**\n * Get params which are used same in both conversion and impression events\n * @param  {ImpressionOptions|ConversionEventOptions} options    Object containing values needed to build impression/conversion event\n * @return {CommonEventParams}                                   Common params with properties that are used in both conversion and impression events\n */\nfunction getCommonEventParams({\n  attributes,\n  userId,\n  clientEngine,\n  clientVersion,\n  configObj,\n  logger,\n}: ImpressionOptions | ConversionEventOptions): CommonEventParams {\n\n  const anonymize_ip = configObj.anonymizeIP ? configObj.anonymizeIP : false;\n  const botFiltering = configObj.botFiltering;\n\n  const visitor = {\n    snapshots: [],\n    visitor_id: userId,\n    attributes: [],\n  };\n\n  const commonParams: CommonEventParams = {\n    account_id: configObj.accountId,\n    project_id: configObj.projectId,\n    visitors: [visitor],\n    revision: configObj.revision,\n    client_name: clientEngine,\n    client_version: clientVersion,\n    anonymize_ip: anonymize_ip,\n    enrich_decisions: true,\n  };\n\n  if (attributes) {\n    // Omit attribute values that are not supported by the log endpoint.\n    Object.keys(attributes || {}).forEach(function(attributeKey) {\n      const attributeValue = attributes[attributeKey];\n      if (isAttributeValid(attributeKey, attributeValue)) {\n        const attributeId = getAttributeId(configObj, attributeKey, logger);\n        if (attributeId) {\n          commonParams.visitors[0].attributes.push({\n            entity_id: attributeId,\n            key: attributeKey,\n            type: CUSTOM_ATTRIBUTE_FEATURE_TYPE,\n            value: attributeValue!,\n          });\n        }\n      }\n    });\n  }\n\n\n  if (typeof botFiltering === 'boolean') {\n    commonParams.visitors[0].attributes.push({\n      entity_id: CONTROL_ATTRIBUTES.BOT_FILTERING,\n      key: CONTROL_ATTRIBUTES.BOT_FILTERING,\n      type: CUSTOM_ATTRIBUTE_FEATURE_TYPE,\n      value: botFiltering,\n    });\n  }\n\n  return commonParams;\n}\n\n/**\n * Creates object of params specific to impression events\n * @param  {ProjectConfig}       configObj    Object representing project configuration\n * @param  {string|null}         experimentId ID of experiment for which impression needs to be recorded\n * @param  {string|null}         variationId  ID for variation which would be presented to user\n * @param  {string}              ruleKey      Key of experiment for which impression needs to be recorded\n * @param  {string}              ruleType     Type for the decision source\n * @param  {string}              flagKey      Key for a feature flag\n * @param  {boolean}             enabled      Boolean representing if feature is enabled\n * @return {Snapshot}                         Impression event params\n */\nfunction getImpressionEventParams(\n  configObj: ProjectConfig,\n  experimentId: string | null,\n  variationId: string | null,\n  ruleKey: string,\n  ruleType: string,\n  flagKey: string,\n  enabled: boolean\n): Snapshot {\n\n  const campaignId = experimentId ? getLayerId(configObj, experimentId) : null;\n\n  let variationKey = variationId ? getVariationKeyFromId(configObj, variationId) : null;\n  variationKey = variationKey || '';\n\n  const impressionEventParams = {\n    decisions: [\n      {\n        campaign_id: campaignId,\n        experiment_id: experimentId,\n        variation_id: variationId,\n        metadata: {\n          flag_key: flagKey,\n          rule_key: ruleKey,\n          rule_type: ruleType,\n          variation_key: variationKey,\n          enabled: enabled,\n        }\n      },\n    ],\n    events: [\n      {\n        entity_id: campaignId,\n        timestamp: fns.currentTimestamp(),\n        key: ACTIVATE_EVENT_KEY,\n        uuid: fns.uuid(),\n      },\n    ],\n  };\n\n  return impressionEventParams;\n}\n\n/**\n * Creates object of params specific to conversion events\n * @param  {ProjectConfig} configObj                 Object representing project configuration\n * @param  {string}        eventKey                  Event key representing the event which needs to be recorded\n * @param  {LoggerFacade}  logger                    Logger object\n * @param  {EventTags}     eventTags                 Values associated with the event.\n * @return {Snapshot}                                Conversion event params\n */\nfunction getVisitorSnapshot(\n  configObj: ProjectConfig,\n  eventKey: string,\n  logger: LoggerFacade,\n  eventTags?: EventTags,\n): Snapshot {\n  const snapshot: Snapshot = {\n    events: [],\n  };\n\n  const eventDict: SnapshotEvent = {\n    entity_id: getEventId(configObj, eventKey),\n    timestamp: fns.currentTimestamp(),\n    uuid: fns.uuid(),\n    key: eventKey,\n  };\n\n  if (eventTags) {\n    const revenue = eventTagUtils.getRevenueValue(eventTags, logger);\n    if (revenue !== null) {\n      eventDict[RESERVED_EVENT_KEYWORDS.REVENUE] = revenue;\n    }\n\n    const eventValue = eventTagUtils.getEventValue(eventTags, logger);\n    if (eventValue !== null) {\n      eventDict[RESERVED_EVENT_KEYWORDS.VALUE] = eventValue;\n    }\n\n    eventDict['tags'] = eventTags;\n  }\n  snapshot.events.push(eventDict);\n\n  return snapshot;\n}\n\n/**\n * Create impression event params to be sent to the logging endpoint\n * @param  {ImpressionOptions}    options    Object containing values needed to build impression event\n * @return {EventLoggingEndpoint}            Params to be used in impression event logging endpoint call\n */\nexport function getImpressionEvent(options: ImpressionOptions): EventLoggingEndpoint {\n  const commonParams = getCommonEventParams(options);\n  const impressionEventParams = getImpressionEventParams(\n    options.configObj,\n    options.experimentId,\n    options.variationId,\n    options.ruleKey,\n    options.ruleType,\n    options.flagKey,\n    options.enabled,\n  );\n  commonParams.visitors[0].snapshots.push(impressionEventParams);\n\n  const impressionEvent: EventLoggingEndpoint = {\n    httpVerb: HTTP_VERB,\n    url: ENDPOINT,\n    params: commonParams,\n  }\n\n  return impressionEvent;\n}\n\n/**\n * Create conversion event params to be sent to the logging endpoint\n * @param  {ConversionEventOptions}  options   Object containing values needed to build conversion event\n * @return {EventLoggingEndpoint}              Params to be used in conversion event logging endpoint call\n */\nexport function getConversionEvent(options: ConversionEventOptions): EventLoggingEndpoint {\n\n  const commonParams = getCommonEventParams(options);\n  const snapshot = getVisitorSnapshot(options.configObj, options.eventKey, options.logger, options.eventTags);\n  commonParams.visitors[0].snapshots = [snapshot];\n\n  const conversionEvent: EventLoggingEndpoint = {\n    httpVerb: HTTP_VERB,\n    url: ENDPOINT,\n    params: commonParams,\n  }\n\n  return conversionEvent;\n}\n","/**\n * Copyright 2020, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DecisionObj } from '../decision_service';\n\n/**\n * Get experiment key from the provided decision object\n * @param   {DecisionObj} decisionObj       Object representing decision\n * @returns {string}                        Experiment key or empty string if experiment is null\n */\nexport function getExperimentKey(decisionObj: DecisionObj): string {\n  return decisionObj.experiment?.key ?? '';\n}\n\n/**\n * Get variation key from the provided decision object\n * @param   {DecisionObj} decisionObj       Object representing decision\n * @returns {string}                        Variation key or empty string if variation is null\n */\nexport function getVariationKey(decisionObj: DecisionObj): string {\n  return decisionObj.variation?.key ?? '';\n}\n\n/**\n * Get featureEnabled from variation in the provided decision object\n * @param   {DecisionObj} decisionObj       Object representing decision\n * @returns {boolean}                       featureEnabled boolean or false if variation is null\n */\nexport function getFeatureEnabledFromVariation(decisionObj: DecisionObj): boolean {\n  return decisionObj.variation?.featureEnabled ?? false;\n}\n\n/**\n * Get experiment id from the provided decision object\n * @param   {DecisionObj} decisionObj       Object representing decision\n * @returns {string}                        Experiment id or null if experiment is null\n */\nexport function getExperimentId(decisionObj: DecisionObj): string | null {\n  return decisionObj.experiment?.id ?? null;\n}\n\n/**\n * Get variation id from the provided decision object\n * @param   {DecisionObj} decisionObj       Object representing decision\n * @returns {string}                        Variation id or null if variation is null\n */\nexport function getVariationId(decisionObj: DecisionObj): string | null {\n  return decisionObj.variation?.id ?? null;\n}\n","/**\n * Copyright 2019-2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLogger } from '../../modules/logging';\n\nimport fns from '../../utils/fns';\nimport * as eventTagUtils from '../../utils/event_tag_utils';\nimport * as attributesValidator from '../../utils/attributes_validator';\nimport * as decision from '../decision';\n\nimport { EventTags, UserAttributes } from '../../shared_types';\nimport { DecisionObj } from '../decision_service';\nimport {\n  getAttributeId,\n  getEventId,\n  getLayerId,\n  ProjectConfig,\n} from '../project_config';\n\nconst logger = getLogger('EVENT_BUILDER');\n\ninterface ImpressionConfig {\n  decisionObj: DecisionObj;\n  userId: string;\n  flagKey: string;\n  enabled: boolean;\n  userAttributes?: UserAttributes;\n  clientEngine: string;\n  clientVersion: string;\n  configObj: ProjectConfig;\n}\n\ntype VisitorAttribute = {\n  entityId: string;\n  key: string;\n  value: string | number | boolean;\n}\n\ninterface ImpressionEvent {\n  type: 'impression';\n  timestamp: number;\n  uuid: string;\n  user: {\n    id: string;\n    attributes: VisitorAttribute[];\n  };\n  context: EventContext;\n  layer: {\n    id: string | null;\n  };\n  experiment: {\n    id: string | null;\n    key: string;\n  } | null;\n  variation: {\n    id: string | null;\n    key: string;\n  } | null;\n\n  ruleKey: string,\n  flagKey: string,\n  ruleType: string,\n  enabled: boolean,\n}\n\ntype EventContext = {\n  accountId: string;\n  projectId: string;\n  revision: string;\n  clientName: string;\n  clientVersion: string;\n  anonymizeIP: boolean;\n  botFiltering: boolean | undefined;\n}\n\ninterface ConversionConfig {\n  eventKey: string;\n  eventTags?: EventTags;\n  userId: string;\n  userAttributes?: UserAttributes;\n  clientEngine: string;\n  clientVersion: string;\n  configObj: ProjectConfig;\n}\n\ninterface ConversionEvent {\n  type: 'conversion';\n  timestamp: number;\n  uuid: string;\n  user: {\n    id: string;\n    attributes: VisitorAttribute[];\n  };\n  context: EventContext;\n  event: {\n    id: string | null;\n    key: string;\n  };\n  revenue: number | null;\n  value: number | null;\n  tags: EventTags | undefined;\n}\n\n\n/**\n * Creates an ImpressionEvent object from decision data\n * @param  {ImpressionConfig}  config\n * @return {ImpressionEvent}   an ImpressionEvent object\n */\nexport const buildImpressionEvent = function({\n  configObj,\n  decisionObj,\n  userId,\n  flagKey,\n  enabled,\n  userAttributes,\n  clientEngine,\n  clientVersion,\n}: ImpressionConfig): ImpressionEvent {\n\n  const ruleType = decisionObj.decisionSource;\n  const experimentKey = decision.getExperimentKey(decisionObj);\n  const experimentId = decision.getExperimentId(decisionObj);\n  const variationKey = decision.getVariationKey(decisionObj);\n  const variationId = decision.getVariationId(decisionObj);\n\n  const layerId = experimentId !== null ? getLayerId(configObj, experimentId) : null;\n\n  return {\n    type: 'impression',\n    timestamp: fns.currentTimestamp(),\n    uuid: fns.uuid(),\n\n    user: {\n      id: userId,\n      attributes: buildVisitorAttributes(configObj, userAttributes),\n    },\n\n    context: {\n      accountId: configObj.accountId,\n      projectId: configObj.projectId,\n      revision: configObj.revision,\n      clientName: clientEngine,\n      clientVersion: clientVersion,\n      anonymizeIP: configObj.anonymizeIP || false,\n      botFiltering: configObj.botFiltering,\n    },\n\n    layer: {\n      id: layerId,\n    },\n\n    experiment: {\n      id: experimentId,\n      key: experimentKey,\n    },\n\n    variation: {\n      id: variationId,\n      key: variationKey,\n    },\n\n    ruleKey: experimentKey,\n    flagKey: flagKey,\n    ruleType: ruleType,\n    enabled: enabled,\n  };\n};\n\n/**\n * Creates a ConversionEvent object from track\n * @param  {ConversionConfig} config\n * @return {ConversionEvent}  a ConversionEvent object\n */\nexport const buildConversionEvent = function({\n  configObj,\n  userId,\n  userAttributes,\n  clientEngine,\n  clientVersion,\n  eventKey,\n  eventTags,\n}: ConversionConfig): ConversionEvent {\n\n  const eventId = getEventId(configObj, eventKey);\n\n  const revenue = eventTags ? eventTagUtils.getRevenueValue(eventTags, logger) : null;\n  const eventValue = eventTags ? eventTagUtils.getEventValue(eventTags, logger) : null;\n\n  return {\n    type: 'conversion',\n    timestamp: fns.currentTimestamp(),\n    uuid: fns.uuid(),\n\n    user: {\n      id: userId,\n      attributes: buildVisitorAttributes(configObj, userAttributes),\n    },\n\n    context: {\n      accountId: configObj.accountId,\n      projectId: configObj.projectId,\n      revision: configObj.revision,\n      clientName: clientEngine,\n      clientVersion: clientVersion,\n      anonymizeIP: configObj.anonymizeIP || false,\n      botFiltering: configObj.botFiltering,\n    },\n\n    event: {\n      id: eventId,\n      key: eventKey,\n    },\n\n    revenue: revenue,\n    value: eventValue,\n    tags: eventTags,\n  };\n};\n\nfunction buildVisitorAttributes(\n  configObj: ProjectConfig,\n  attributes?: UserAttributes\n): VisitorAttribute[] {\n  const builtAttributes: VisitorAttribute[] = [];\n  // Omit attribute values that are not supported by the log endpoint.\n  if (attributes) {\n    Object.keys(attributes || {}).forEach(function(attributeKey) {\n      const attributeValue = attributes[attributeKey];\n      if (attributesValidator.isAttributeValid(attributeKey, attributeValue)) {\n        const attributeId = getAttributeId(configObj, attributeKey, logger);\n        if (attributeId) {\n          builtAttributes.push({\n            entityId: attributeId,\n            key: attributeKey,\n            value: attributeValue!,\n          });\n        }\n      }\n    });\n  }\n\n  return builtAttributes;\n}\n","/**\n * Copyright 2020, 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LogHandler, ErrorHandler } from '../../modules/logging';\nimport { objectValues } from '../../utils/fns';\nimport { NotificationListener, ListenerPayload } from '../../shared_types';\n\nimport {\n  LOG_LEVEL,\n  LOG_MESSAGES,\n  NOTIFICATION_TYPES,\n} from '../../utils/enums';\n\nconst MODULE_NAME = 'NOTIFICATION_CENTER';\n\ninterface NotificationCenterOptions {\n  logger: LogHandler;\n  errorHandler: ErrorHandler;\n}\n\ninterface ListenerEntry {\n  id: number;\n  // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n  callback: (notificationData: any) => void;\n}\n\ntype NotificationListeners = {\n  [key: string]: ListenerEntry[];\n}\n\n/**\n * NotificationCenter allows registration and triggering of callback functions using\n * notification event types defined in NOTIFICATION_TYPES of utils/enums/index.js:\n * - ACTIVATE: An impression event will be sent to Optimizely.\n * - TRACK a conversion event will be sent to Optimizely\n */\nexport class NotificationCenter {\n  private logger: LogHandler;\n  private errorHandler: ErrorHandler;\n  private notificationListeners: NotificationListeners;\n  private listenerId: number;\n\n  /**\n   * @constructor\n   * @param   {NotificationCenterOptions}  options\n   * @param   {LogHandler}                 options.logger       An instance of a logger to log messages with\n   * @param   {ErrorHandler}               options.errorHandler An instance of errorHandler to handle any unexpected error\n   */\n  constructor(options: NotificationCenterOptions) {\n    this.logger = options.logger;\n    this.errorHandler = options.errorHandler;\n    this.notificationListeners = {};\n    objectValues(NOTIFICATION_TYPES).forEach(\n      (notificationTypeEnum) => {\n        this.notificationListeners[notificationTypeEnum] = [];\n      }\n    );\n    this.listenerId = 1;\n  }\n\n  /**\n   * Add a notification callback to the notification center\n   * @param   {string}                   notificationType     One of the values from NOTIFICATION_TYPES in utils/enums/index.js\n   * @param   {NotificationListener<T>}  callback             Function that will be called when the event is triggered\n   * @returns {number}                   If the callback was successfully added, returns a listener ID which can be used\n   * to remove the callback by calling removeNotificationListener. The ID is a number greater than 0.\n   * If there was an error and the listener was not added, addNotificationListener returns -1. This\n   * can happen if the first argument is not a valid notification type, or if the same callback\n   * function was already added as a listener by a prior call to this function.\n   */\n  addNotificationListener<T extends ListenerPayload>(\n    notificationType: string,\n    callback: NotificationListener<T>\n  ): number {\n    try {\n      const notificationTypeValues: string[] = objectValues(NOTIFICATION_TYPES);\n      const isNotificationTypeValid = notificationTypeValues.indexOf(notificationType) > -1;\n      if (!isNotificationTypeValid) {\n        return -1;\n      }\n  \n      if (!this.notificationListeners[notificationType]) {\n        this.notificationListeners[notificationType] = [];\n      }\n  \n      let callbackAlreadyAdded = false;\n      (this.notificationListeners[notificationType] || []).forEach(\n        (listenerEntry) => {\n          if (listenerEntry.callback === callback) {\n            callbackAlreadyAdded = true;\n            return;\n          }\n        });\n\n      if (callbackAlreadyAdded) {\n        return -1;\n      }\n  \n      this.notificationListeners[notificationType].push({\n        id: this.listenerId,\n        callback: callback,\n      });\n  \n      const returnId = this.listenerId;\n      this.listenerId += 1;\n      return returnId;\n    } catch (e: any) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return -1;\n    }\n  }\n\n  /**\n   * Remove a previously added notification callback\n   * @param   {number}                 listenerId ID of listener to be removed\n   * @returns {boolean}                Returns true if the listener was found and removed, and false\n   * otherwise.\n   */\n  removeNotificationListener(listenerId: number): boolean {\n    try {\n      let indexToRemove: number | undefined;\n      let typeToRemove: string | undefined;\n  \n      Object.keys(this.notificationListeners).some(\n        (notificationType) => {\n          const listenersForType = this.notificationListeners[notificationType];\n          (listenersForType || []).every((listenerEntry, i) => {\n            if (listenerEntry.id === listenerId) {\n              indexToRemove = i;\n              typeToRemove = notificationType;\n              return false;\n            }\n\n            return true;\n          });\n\n          if (indexToRemove !== undefined && typeToRemove !== undefined) {\n            return true;\n          }\n\n          return false;\n        }\n      );\n  \n      if (indexToRemove !== undefined && typeToRemove !== undefined) {\n        this.notificationListeners[typeToRemove].splice(indexToRemove, 1);\n        return true;\n      }\n    } catch (e: any) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all previously added notification listeners, for all notification types\n   */\n  clearAllNotificationListeners(): void {\n    try {\n      objectValues(NOTIFICATION_TYPES).forEach(\n        (notificationTypeEnum) => {\n          this.notificationListeners[notificationTypeEnum] = [];\n        }\n      );\n    } catch (e: any) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n    }\n  }\n\n  /**\n   * Remove all previously added notification listeners for the argument type\n   * @param   {NOTIFICATION_TYPES}    notificationType One of NOTIFICATION_TYPES\n   */\n  clearNotificationListeners(notificationType: NOTIFICATION_TYPES): void {\n    try {\n      this.notificationListeners[notificationType] = [];\n    } catch (e: any) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n    }\n  }\n\n  /**\n   * Fires notifications for the argument type. All registered callbacks for this type will be\n   * called. The notificationData object will be passed on to callbacks called.\n   * @param {string} notificationType One of NOTIFICATION_TYPES\n   * @param {Object} notificationData Will be passed to callbacks called\n   */\n  sendNotifications<T extends ListenerPayload>(\n    notificationType: string,\n    notificationData?: T\n  ): void {\n    try {\n      (this.notificationListeners[notificationType] || []).forEach(\n        (listenerEntry) => {\n          const callback = listenerEntry.callback;\n          try {\n            callback(notificationData);\n          } catch (ex: any) {\n            this.logger.log(\n              LOG_LEVEL.ERROR,\n              LOG_MESSAGES.NOTIFICATION_LISTENER_EXCEPTION,\n              MODULE_NAME,\n              notificationType,\n              ex.message,\n            );\n          }\n        }\n      );\n    } catch (e: any) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n    }\n  }\n}\n\n/**\n * Create an instance of NotificationCenter\n * @param   {NotificationCenterOptions}   options\n * @returns {NotificationCenter}          An instance of NotificationCenter\n */\nexport function createNotificationCenter(options: NotificationCenterOptions): NotificationCenter {\n  return new NotificationCenter(options);\n}\n\nexport interface NotificationSender {\n  // TODO[OASIS-6649]: Don't use any type\n  // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n  sendNotifications(notificationType: NOTIFICATION_TYPES, notificationData?: any): void\n}\n","/**\n * Copyright 2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getLogger, LogHandler, LogLevel } from '../../modules/logging';\nimport { NotificationCenter, createNotificationCenter } from '../../core/notification_center';\n\n/**\n * Internal notification center registry for managing multiple notification centers.\n */\nexport class NotificationRegistry {\n  private static _notificationCenters = new Map<string, NotificationCenter>();\n\n  constructor() {}\n\n  /**\n   * Retrieves an SDK Key's corresponding notification center in the registry if it exists, otherwise it creates one\n   * @param sdkKey SDK Key to be used for the notification center tied to the ODP Manager\n   * @param logger Logger to be used for the corresponding notification center\n   * @returns {NotificationCenter | undefined} a notification center instance for ODP Manager if a valid SDK Key is provided, otherwise undefined\n   */\n  static getNotificationCenter(sdkKey?: string, logger: LogHandler = getLogger()): NotificationCenter | undefined {\n    if (!sdkKey) {\n      logger.log(LogLevel.ERROR, 'No SDK key provided to getNotificationCenter.');\n      return undefined;\n    }\n\n    let notificationCenter;\n    if (this._notificationCenters.has(sdkKey)) {\n      notificationCenter = this._notificationCenters.get(sdkKey);\n    } else {\n      notificationCenter = createNotificationCenter({\n        logger,\n        errorHandler: { handleError: () => {} },\n      });\n      this._notificationCenters.set(sdkKey, notificationCenter);\n    }\n\n    return notificationCenter;\n  }\n\n  static removeNotificationCenter(sdkKey?: string): void {\n    if (!sdkKey) {\n      return;\n    }\n\n    const notificationCenter = this._notificationCenters.get(sdkKey);\n    if (notificationCenter) {\n      notificationCenter.clearAllNotificationListeners();\n      this._notificationCenters.delete(sdkKey);\n    }\n  }\n}\n","/****************************************************************************\n * Copyright 2017, 2020, 2022, Optimizely, Inc. and contributors                  *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\n\n/**\n * Provides utility method for validating that the given user profile service implementation is valid.\n */\n\nimport { sprintf } from '../../utils/fns';\nimport { ObjectWithUnknownProperties } from '../../shared_types';\n\nimport { ERROR_MESSAGES } from '../enums';\n\nconst MODULE_NAME = 'USER_PROFILE_SERVICE_VALIDATOR';\n\n/**\n * Validates user's provided user profile service instance\n * @param  {unknown}  userProfileServiceInstance\n * @return {boolean} true if the instance is valid\n * @throws If the instance is not valid\n */\n\nexport function validate(userProfileServiceInstance: unknown): boolean {\n  if (typeof userProfileServiceInstance === 'object' && userProfileServiceInstance !== null) {\n    if (typeof (userProfileServiceInstance as ObjectWithUnknownProperties)['lookup'] !== 'function') {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_USER_PROFILE_SERVICE, MODULE_NAME, \"Missing function 'lookup'\"));\n    } else if (typeof (userProfileServiceInstance as ObjectWithUnknownProperties)['save'] !== 'function') {\n      throw new Error(sprintf(ERROR_MESSAGES.INVALID_USER_PROFILE_SERVICE, MODULE_NAME, \"Missing function 'save'\"));\n    }\n    return true;\n  }\n  throw new Error(sprintf(ERROR_MESSAGES.INVALID_USER_PROFILE_SERVICE, MODULE_NAME));\n}\n","/****************************************************************************\n * Copyright 2020-2024, Optimizely, Inc. and contributors                   *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    https://www.apache.org/licenses/LICENSE-2.0                           *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\n\nimport { LoggerFacade, ErrorHandler } from '../modules/logging';\nimport { sprintf, objectValues } from '../utils/fns';\nimport { NotificationCenter } from '../core/notification_center';\nimport { EventProcessor } from '../modules/event_processor';\n\nimport { IOdpManager } from '../core/odp/odp_manager';\nimport { OdpConfig } from '../core/odp/odp_config';\nimport { OdpEvent } from '../core/odp/odp_event';\nimport { OptimizelySegmentOption } from '../core/odp/optimizely_segment_option';\n\nimport {\n  UserAttributes,\n  EventTags,\n  OptimizelyConfig,\n  OnReadyResult,\n  UserProfileService,\n  Variation,\n  FeatureFlag,\n  FeatureVariable,\n  OptimizelyOptions,\n  OptimizelyDecideOption,\n  FeatureVariableValue,\n  OptimizelyDecision,\n  Client,\n} from '../shared_types';\nimport { newErrorDecision } from '../optimizely_decision';\nimport OptimizelyUserContext from '../optimizely_user_context';\nimport { createProjectConfigManager, ProjectConfigManager } from '../core/project_config/project_config_manager';\nimport { createDecisionService, DecisionService, DecisionObj } from '../core/decision_service';\nimport { getImpressionEvent, getConversionEvent } from '../core/event_builder';\nimport { buildImpressionEvent, buildConversionEvent } from '../core/event_builder/event_helpers';\nimport { NotificationRegistry } from '../core/notification_center/notification_registry';\nimport fns from '../utils/fns';\nimport { validate } from '../utils/attributes_validator';\nimport * as eventTagsValidator from '../utils/event_tags_validator';\nimport * as projectConfig from '../core/project_config';\nimport * as userProfileServiceValidator from '../utils/user_profile_service_validator';\nimport * as stringValidator from '../utils/string_value_validator';\nimport * as decision from '../core/decision';\n\nimport {\n  ERROR_MESSAGES,\n  LOG_LEVEL,\n  LOG_MESSAGES,\n  DECISION_SOURCES,\n  DECISION_MESSAGES,\n  FEATURE_VARIABLE_TYPES,\n  DECISION_NOTIFICATION_TYPES,\n  NOTIFICATION_TYPES,\n  NODE_CLIENT_ENGINE,\n  CLIENT_VERSION,\n  ODP_DEFAULT_EVENT_TYPE,\n  FS_USER_ID_ALIAS,\n  ODP_USER_KEY,\n} from '../utils/enums';\n\nconst MODULE_NAME = 'OPTIMIZELY';\n\nconst DEFAULT_ONREADY_TIMEOUT = 30000;\n\n// TODO: Make feature_key, user_id, variable_key, experiment_key, event_key camelCase\ntype InputKey = 'feature_key' | 'user_id' | 'variable_key' | 'experiment_key' | 'event_key' | 'variation_id';\n\ntype StringInputs = Partial<Record<InputKey, unknown>>;\n\nexport default class Optimizely implements Client {\n  private isOptimizelyConfigValid: boolean;\n  private disposeOnUpdate: (() => void) | null;\n  private readyPromise: Promise<{ success: boolean; reason?: string }>;\n  // readyTimeout is specified as any to make this work in both browser & Node\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private readyTimeouts: { [key: string]: { readyTimeout: any; onClose: () => void } };\n  private nextReadyTimeoutId: number;\n  private clientEngine: string;\n  private clientVersion: string;\n  private errorHandler: ErrorHandler;\n  protected logger: LoggerFacade;\n  private projectConfigManager: ProjectConfigManager;\n  private decisionService: DecisionService;\n  private eventProcessor: EventProcessor;\n  private defaultDecideOptions: { [key: string]: boolean };\n  protected odpManager?: IOdpManager;\n  public notificationCenter: NotificationCenter;\n\n  constructor(config: OptimizelyOptions) {\n    let clientEngine = config.clientEngine;\n    if (!clientEngine) {\n      config.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.INVALID_CLIENT_ENGINE, MODULE_NAME, clientEngine);\n      clientEngine = NODE_CLIENT_ENGINE;\n    }\n\n    this.clientEngine = clientEngine;\n    this.clientVersion = config.clientVersion || CLIENT_VERSION;\n    this.errorHandler = config.errorHandler;\n    this.isOptimizelyConfigValid = config.isValidInstance;\n    this.logger = config.logger;\n    this.odpManager = config.odpManager;\n\n    let decideOptionsArray = config.defaultDecideOptions ?? [];\n    if (!Array.isArray(decideOptionsArray)) {\n      this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.INVALID_DEFAULT_DECIDE_OPTIONS, MODULE_NAME);\n      decideOptionsArray = [];\n    }\n\n    const defaultDecideOptions: { [key: string]: boolean } = {};\n    decideOptionsArray.forEach(option => {\n      // Filter out all provided default decide options that are not in OptimizelyDecideOption[]\n      if (OptimizelyDecideOption[option]) {\n        defaultDecideOptions[option] = true;\n      } else {\n        this.logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.UNRECOGNIZED_DECIDE_OPTION, MODULE_NAME, option);\n      }\n    });\n    this.defaultDecideOptions = defaultDecideOptions;\n    this.projectConfigManager = createProjectConfigManager({\n      datafile: config.datafile,\n      jsonSchemaValidator: config.jsonSchemaValidator,\n      sdkKey: config.sdkKey,\n      datafileManager: config.datafileManager,\n    });\n\n    this.disposeOnUpdate = this.projectConfigManager.onUpdate((configObj: projectConfig.ProjectConfig) => {\n      this.logger.log(\n        LOG_LEVEL.INFO,\n        LOG_MESSAGES.UPDATED_OPTIMIZELY_CONFIG,\n        MODULE_NAME,\n        configObj.revision,\n        configObj.projectId\n      );\n\n      this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.OPTIMIZELY_CONFIG_UPDATE);\n\n      this.updateOdpSettings();\n    });\n\n    const projectConfigManagerReadyPromise = this.projectConfigManager.onReady();\n\n    let userProfileService: UserProfileService | null = null;\n    if (config.userProfileService) {\n      try {\n        if (userProfileServiceValidator.validate(config.userProfileService)) {\n          userProfileService = config.userProfileService;\n          this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.VALID_USER_PROFILE_SERVICE, MODULE_NAME);\n        }\n      } catch (ex) {\n        this.logger.log(LOG_LEVEL.WARNING, ex.message);\n      }\n    }\n\n    this.decisionService = createDecisionService({\n      userProfileService: userProfileService,\n      logger: this.logger,\n      UNSTABLE_conditionEvaluators: config.UNSTABLE_conditionEvaluators,\n    });\n\n    this.notificationCenter = config.notificationCenter;\n\n    this.eventProcessor = config.eventProcessor;\n\n    const eventProcessorStartedPromise = this.eventProcessor.start();\n\n    this.readyPromise = Promise.all([\n      projectConfigManagerReadyPromise,\n      eventProcessorStartedPromise,\n      config.odpManager ? config.odpManager.onReady() : Promise.resolve(),\n    ]).then(promiseResults => {\n      // Only return status from project config promise because event processor promise does not return any status.\n      return promiseResults[0];\n    });\n\n    this.readyTimeouts = {};\n    this.nextReadyTimeoutId = 0;\n  }\n\n  /**\n   * Returns the project configuration retrieved from projectConfigManager\n   * @return {projectConfig.ProjectConfig}\n   */\n  getProjectConfig(): projectConfig.ProjectConfig | null {\n    return this.projectConfigManager.getConfig();\n  }\n\n  /**\n   * Returns a truthy value if this instance currently has a valid project config\n   * object, and the initial configuration object that was passed into the\n   * constructor was also valid.\n   * @return {boolean}\n   */\n  isValidInstance(): boolean {\n    return this.isOptimizelyConfigValid && !!this.projectConfigManager.getConfig();\n  }\n\n  /**\n   * Buckets visitor and sends impression event to Optimizely.\n   * @param  {string}             experimentKey\n   * @param  {string}             userId\n   * @param  {UserAttributes}     attributes\n   * @return {string|null}        variation key\n   */\n  activate(experimentKey: string, userId: string, attributes?: UserAttributes): string | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'activate');\n        return null;\n      }\n\n      if (!this.validateInputs({ experiment_key: experimentKey, user_id: userId }, attributes)) {\n        return this.notActivatingExperiment(experimentKey, userId);\n      }\n\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return null;\n      }\n\n      try {\n        const variationKey = this.getVariation(experimentKey, userId, attributes);\n        if (variationKey === null) {\n          return this.notActivatingExperiment(experimentKey, userId);\n        }\n\n        // If experiment is not set to 'Running' status, log accordingly and return variation key\n        if (!projectConfig.isRunning(configObj, experimentKey)) {\n          this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.SHOULD_NOT_DISPATCH_ACTIVATE, MODULE_NAME, experimentKey);\n          return variationKey;\n        }\n\n        const experiment = projectConfig.getExperimentFromKey(configObj, experimentKey);\n        const variation = experiment.variationKeyMap[variationKey];\n        const decisionObj = {\n          experiment: experiment,\n          variation: variation,\n          decisionSource: DECISION_SOURCES.EXPERIMENT,\n        };\n\n        this.sendImpressionEvent(decisionObj, '', userId, true, attributes);\n        return variationKey;\n      } catch (ex) {\n        this.logger.log(LOG_LEVEL.ERROR, ex.message);\n        this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.NOT_ACTIVATING_USER, MODULE_NAME, userId, experimentKey);\n        this.errorHandler.handleError(ex);\n        return null;\n      }\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Create an impression event and call the event dispatcher's dispatch method to\n   * send this event to Optimizely. Then use the notification center to trigger\n   * any notification listeners for the ACTIVATE notification type.\n   * @param {DecisionObj}    decisionObj    Decision Object\n   * @param {string}         flagKey        Key for a feature flag\n   * @param {string}         userId         ID of user to whom the variation was shown\n   * @param {UserAttributes} attributes     Optional user attributes\n   * @param {boolean}        enabled        Boolean representing if feature is enabled\n   */\n  private sendImpressionEvent(\n    decisionObj: DecisionObj,\n    flagKey: string,\n    userId: string,\n    enabled: boolean,\n    attributes?: UserAttributes\n  ): void {\n    const configObj = this.projectConfigManager.getConfig();\n    if (!configObj) {\n      return;\n    }\n    const impressionEvent = buildImpressionEvent({\n      decisionObj: decisionObj,\n      flagKey: flagKey,\n      enabled: enabled,\n      userId: userId,\n      userAttributes: attributes,\n      clientEngine: this.clientEngine,\n      clientVersion: this.clientVersion,\n      configObj: configObj,\n    });\n    // TODO is it okay to not pass a projectConfig as second argument\n    this.eventProcessor.process(impressionEvent);\n    this.emitNotificationCenterActivate(decisionObj, flagKey, userId, enabled, attributes);\n  }\n\n  /**\n   * Emit the ACTIVATE notification on the notificationCenter\n   * @param  {DecisionObj}    decisionObj    Decision object\n   * @param  {string}         flagKey        Key for a feature flag\n   * @param  {string}         userId         ID of user to whom the variation was shown\n   * @param  {boolean}        enabled        Boolean representing if feature is enabled\n   * @param  {UserAttributes} attributes     Optional user attributes\n   */\n  private emitNotificationCenterActivate(\n    decisionObj: DecisionObj,\n    flagKey: string,\n    userId: string,\n    enabled: boolean,\n    attributes?: UserAttributes\n  ): void {\n    const configObj = this.projectConfigManager.getConfig();\n    if (!configObj) {\n      return;\n    }\n\n    const ruleType = decisionObj.decisionSource;\n    const experimentKey = decision.getExperimentKey(decisionObj);\n    const experimentId = decision.getExperimentId(decisionObj);\n    const variationKey = decision.getVariationKey(decisionObj);\n    const variationId = decision.getVariationId(decisionObj);\n\n    let experiment;\n\n    if (experimentId !== null && variationKey !== '') {\n      experiment = configObj.experimentIdMap[experimentId];\n    }\n\n    const impressionEventOptions = {\n      attributes: attributes,\n      clientEngine: this.clientEngine,\n      clientVersion: this.clientVersion,\n      configObj: configObj,\n      experimentId: experimentId,\n      ruleKey: experimentKey,\n      flagKey: flagKey,\n      ruleType: ruleType,\n      userId: userId,\n      enabled: enabled,\n      variationId: variationId,\n      logger: this.logger,\n    };\n    const impressionEvent = getImpressionEvent(impressionEventOptions);\n    let variation;\n    if (experiment && experiment.variationKeyMap && variationKey !== '') {\n      variation = experiment.variationKeyMap[variationKey];\n    }\n    this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.ACTIVATE, {\n      experiment: experiment,\n      userId: userId,\n      attributes: attributes,\n      variation: variation,\n      logEvent: impressionEvent,\n    });\n  }\n\n  /**\n   * Sends conversion event to Optimizely.\n   * @param  {string}         eventKey\n   * @param  {string}         userId\n   * @param  {UserAttributes} attributes\n   * @param  {EventTags}      eventTags Values associated with the event.\n   */\n  track(eventKey: string, userId: string, attributes?: UserAttributes, eventTags?: EventTags): void {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'track');\n        return;\n      }\n\n      if (!this.validateInputs({ user_id: userId, event_key: eventKey }, attributes, eventTags)) {\n        return;\n      }\n\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return;\n      }\n\n      if (!projectConfig.eventWithKeyExists(configObj, eventKey)) {\n        this.logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.EVENT_KEY_NOT_FOUND, MODULE_NAME, eventKey);\n        this.logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.NOT_TRACKING_USER, MODULE_NAME, userId);\n        return;\n      }\n\n      // remove null values from eventTags\n      eventTags = this.filterEmptyValues(eventTags);\n      const conversionEvent = buildConversionEvent({\n        eventKey: eventKey,\n        eventTags: eventTags,\n        userId: userId,\n        userAttributes: attributes,\n        clientEngine: this.clientEngine,\n        clientVersion: this.clientVersion,\n        configObj: configObj,\n      });\n      this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.TRACK_EVENT, MODULE_NAME, eventKey, userId);\n      // TODO is it okay to not pass a projectConfig as second argument\n      this.eventProcessor.process(conversionEvent);\n      this.emitNotificationCenterTrack(eventKey, userId, attributes, eventTags);\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.NOT_TRACKING_USER, MODULE_NAME, userId);\n    }\n  }\n  /**\n   * Send TRACK event to notificationCenter\n   * @param  {string}         eventKey\n   * @param  {string}         userId\n   * @param  {UserAttributes} attributes\n   * @param  {EventTags}      eventTags Values associated with the event.\n   */\n  private emitNotificationCenterTrack(\n    eventKey: string,\n    userId: string,\n    attributes?: UserAttributes,\n    eventTags?: EventTags\n  ): void {\n    try {\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return;\n      }\n\n      const conversionEventOptions = {\n        attributes: attributes,\n        clientEngine: this.clientEngine,\n        clientVersion: this.clientVersion,\n        configObj: configObj,\n        eventKey: eventKey,\n        eventTags: eventTags,\n        logger: this.logger,\n        userId: userId,\n      };\n      const conversionEvent = getConversionEvent(conversionEventOptions);\n\n      this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.TRACK, {\n        eventKey: eventKey,\n        userId: userId,\n        attributes: attributes,\n        eventTags: eventTags,\n        logEvent: conversionEvent,\n      });\n    } catch (ex) {\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      this.errorHandler.handleError(ex);\n    }\n  }\n\n  /**\n   * Gets variation where visitor will be bucketed.\n   * @param  {string}              experimentKey\n   * @param  {string}              userId\n   * @param  {UserAttributes}      attributes\n   * @return {string|null}         variation key\n   */\n  getVariation(experimentKey: string, userId: string, attributes?: UserAttributes): string | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getVariation');\n        return null;\n      }\n\n      try {\n        if (!this.validateInputs({ experiment_key: experimentKey, user_id: userId }, attributes)) {\n          return null;\n        }\n\n        const configObj = this.projectConfigManager.getConfig();\n        if (!configObj) {\n          return null;\n        }\n\n        const experiment = configObj.experimentKeyMap[experimentKey];\n        if (!experiment) {\n          this.logger.log(LOG_LEVEL.DEBUG, ERROR_MESSAGES.INVALID_EXPERIMENT_KEY, MODULE_NAME, experimentKey);\n          return null;\n        }\n\n        const variationKey = this.decisionService.getVariation(\n          configObj,\n          experiment,\n          this.createInternalUserContext(userId, attributes) as OptimizelyUserContext\n        ).result;\n        const decisionNotificationType = projectConfig.isFeatureExperiment(configObj, experiment.id)\n          ? DECISION_NOTIFICATION_TYPES.FEATURE_TEST\n          : DECISION_NOTIFICATION_TYPES.AB_TEST;\n\n        this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.DECISION, {\n          type: decisionNotificationType,\n          userId: userId,\n          attributes: attributes || {},\n          decisionInfo: {\n            experimentKey: experimentKey,\n            variationKey: variationKey,\n          },\n        });\n\n        return variationKey;\n      } catch (ex) {\n        this.logger.log(LOG_LEVEL.ERROR, ex.message);\n        this.errorHandler.handleError(ex);\n        return null;\n      }\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Force a user into a variation for a given experiment.\n   * @param  {string}      experimentKey\n   * @param  {string}      userId\n   * @param  {string|null} variationKey   user will be forced into. If null,\n   *                                      then clear the existing experiment-to-variation mapping.\n   * @return {boolean}                    A boolean value that indicates if the set completed successfully.\n   */\n  setForcedVariation(experimentKey: string, userId: string, variationKey: string | null): boolean {\n    if (!this.validateInputs({ experiment_key: experimentKey, user_id: userId })) {\n      return false;\n    }\n\n    const configObj = this.projectConfigManager.getConfig();\n    if (!configObj) {\n      return false;\n    }\n\n    try {\n      return this.decisionService.setForcedVariation(configObj, experimentKey, userId, variationKey);\n    } catch (ex) {\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      this.errorHandler.handleError(ex);\n      return false;\n    }\n  }\n\n  /**\n   * Gets the forced variation for a given user and experiment.\n   * @param  {string}      experimentKey\n   * @param  {string}      userId\n   * @return {string|null} The forced variation key.\n   */\n  getForcedVariation(experimentKey: string, userId: string): string | null {\n    if (!this.validateInputs({ experiment_key: experimentKey, user_id: userId })) {\n      return null;\n    }\n\n    const configObj = this.projectConfigManager.getConfig();\n    if (!configObj) {\n      return null;\n    }\n\n    try {\n      return this.decisionService.getForcedVariation(configObj, experimentKey, userId).result;\n    } catch (ex) {\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      this.errorHandler.handleError(ex);\n      return null;\n    }\n  }\n\n  /**\n   * Validate string inputs, user attributes and event tags.\n   * @param  {StringInputs}  stringInputs   Map of string keys and associated values\n   * @param  {unknown}       userAttributes Optional parameter for user's attributes\n   * @param  {unknown}       eventTags      Optional parameter for event tags\n   * @return {boolean}                      True if inputs are valid\n   *\n   */\n  protected validateInputs(stringInputs: StringInputs, userAttributes?: unknown, eventTags?: unknown): boolean {\n    try {\n      if (stringInputs.hasOwnProperty('user_id')) {\n        const userId = stringInputs['user_id'];\n        if (typeof userId !== 'string' || userId === null || userId === 'undefined') {\n          throw new Error(sprintf(ERROR_MESSAGES.INVALID_INPUT_FORMAT, MODULE_NAME, 'user_id'));\n        }\n\n        delete stringInputs['user_id'];\n      }\n      Object.keys(stringInputs).forEach(key => {\n        if (!stringValidator.validate(stringInputs[key as InputKey])) {\n          throw new Error(sprintf(ERROR_MESSAGES.INVALID_INPUT_FORMAT, MODULE_NAME, key));\n        }\n      });\n      if (userAttributes) {\n        validate(userAttributes);\n      }\n      if (eventTags) {\n        eventTagsValidator.validate(eventTags);\n      }\n      return true;\n    } catch (ex) {\n      this.logger.log(LOG_LEVEL.ERROR, ex.message);\n      this.errorHandler.handleError(ex);\n      return false;\n    }\n  }\n\n  /**\n   * Shows failed activation log message and returns null when user is not activated in experiment\n   * @param  {string} experimentKey\n   * @param  {string} userId\n   * @return {null}\n   */\n  private notActivatingExperiment(experimentKey: string, userId: string): null {\n    this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.NOT_ACTIVATING_USER, MODULE_NAME, userId, experimentKey);\n    return null;\n  }\n\n  /**\n   * Filters out attributes/eventTags with null or undefined values\n   * @param   {EventTags | undefined} map\n   * @returns {EventTags | undefined}\n   */\n  private filterEmptyValues(map: EventTags | undefined): EventTags | undefined {\n    for (const key in map) {\n      if (map.hasOwnProperty(key) && (map[key] === null || map[key] === undefined)) {\n        delete map[key];\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Returns true if the feature is enabled for the given user.\n   * @param  {string}         featureKey   Key of feature which will be checked\n   * @param  {string}         userId       ID of user which will be checked\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {boolean}                     true if the feature is enabled for the user, false otherwise\n   */\n  isFeatureEnabled(featureKey: string, userId: string, attributes?: UserAttributes): boolean {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'isFeatureEnabled');\n        return false;\n      }\n\n      if (!this.validateInputs({ feature_key: featureKey, user_id: userId }, attributes)) {\n        return false;\n      }\n\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return false;\n      }\n\n      const feature = projectConfig.getFeatureFromKey(configObj, featureKey, this.logger);\n      if (!feature) {\n        return false;\n      }\n\n      let sourceInfo = {};\n      const user = this.createInternalUserContext(userId, attributes) as OptimizelyUserContext;\n      const decisionObj = this.decisionService.getVariationForFeature(configObj, feature, user).result;\n      const decisionSource = decisionObj.decisionSource;\n      const experimentKey = decision.getExperimentKey(decisionObj);\n      const variationKey = decision.getVariationKey(decisionObj);\n\n      let featureEnabled = decision.getFeatureEnabledFromVariation(decisionObj);\n\n      if (decisionSource === DECISION_SOURCES.FEATURE_TEST) {\n        sourceInfo = {\n          experimentKey: experimentKey,\n          variationKey: variationKey,\n        };\n      }\n\n      if (\n        decisionSource === DECISION_SOURCES.FEATURE_TEST ||\n        (decisionSource === DECISION_SOURCES.ROLLOUT && projectConfig.getSendFlagDecisionsValue(configObj))\n      ) {\n        this.sendImpressionEvent(decisionObj, feature.key, userId, featureEnabled, attributes);\n      }\n\n      if (featureEnabled === true) {\n        this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.FEATURE_ENABLED_FOR_USER, MODULE_NAME, featureKey, userId);\n      } else {\n        this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.FEATURE_NOT_ENABLED_FOR_USER, MODULE_NAME, featureKey, userId);\n        featureEnabled = false;\n      }\n\n      const featureInfo = {\n        featureKey: featureKey,\n        featureEnabled: featureEnabled,\n        source: decisionObj.decisionSource,\n        sourceInfo: sourceInfo,\n      };\n\n      this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.DECISION, {\n        type: DECISION_NOTIFICATION_TYPES.FEATURE,\n        userId: userId,\n        attributes: attributes || {},\n        decisionInfo: featureInfo,\n      });\n\n      return featureEnabled;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return false;\n    }\n  }\n\n  /**\n   * Returns an Array containing the keys of all features in the project that are\n   * enabled for the given user.\n   * @param  {string}         userId\n   * @param  {UserAttributes} attributes\n   * @return {string[]}       Array of feature keys (strings)\n   */\n  getEnabledFeatures(userId: string, attributes?: UserAttributes): string[] {\n    try {\n      const enabledFeatures: string[] = [];\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getEnabledFeatures');\n        return enabledFeatures;\n      }\n\n      if (!this.validateInputs({ user_id: userId })) {\n        return enabledFeatures;\n      }\n\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return enabledFeatures;\n      }\n\n      objectValues(configObj.featureKeyMap).forEach((feature: FeatureFlag) => {\n        if (this.isFeatureEnabled(feature.key, userId, attributes)) {\n          enabledFeatures.push(feature.key);\n        }\n      });\n\n      return enabledFeatures;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return [];\n    }\n  }\n\n  /**\n   * Returns dynamically-typed value of the variable attached to the given\n   * feature flag. Returns null if the feature key or variable key is invalid.\n   *\n   * @param  {string}          featureKey           Key of the feature whose variable's\n   *                                                value is being accessed\n   * @param  {string}          variableKey          Key of the variable whose value is\n   *                                                being accessed\n   * @param  {string}          userId               ID for the user\n   * @param  {UserAttributes}  attributes           Optional user attributes\n   * @return {unknown}                              Value of the variable cast to the appropriate\n   *                                                type, or null if the feature key is invalid or\n   *                                                the variable key is invalid\n   */\n  getFeatureVariable(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): FeatureVariableValue {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getFeatureVariable');\n        return null;\n      }\n      return this.getFeatureVariableForType(featureKey, variableKey, null, userId, attributes);\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Helper method to get the value for a variable of a certain type attached to a\n   * feature flag. Returns null if the feature key is invalid, the variable key is\n   * invalid, the given variable type does not match the variable's actual type,\n   * or the variable value cannot be cast to the required type. If the given variable\n   * type is null, the value of the variable cast to the appropriate type is returned.\n   *\n   * @param   {string}         featureKey           Key of the feature whose variable's value is\n   *                                                being accessed\n   * @param   {string}         variableKey          Key of the variable whose value is being\n   *                                                accessed\n   * @param   {string|null}    variableType         Type of the variable whose value is being\n   *                                                accessed (must be one of FEATURE_VARIABLE_TYPES\n   *                                                in lib/utils/enums/index.js), or null to return the\n   *                                                value of the variable cast to the appropriate type\n   * @param   {string}         userId               ID for the user\n   * @param   {UserAttributes} attributes           Optional user attributes\n   * @return  {unknown}                             Value of the variable cast to the appropriate\n   *                                                type, or null if the feature key is invalid, thevariable\n   *                                                key is invalid, or there is a mismatch with the type of\n   *                                                the variable\n   */\n  private getFeatureVariableForType(\n    featureKey: string,\n    variableKey: string,\n    variableType: string | null,\n    userId: string,\n    attributes?: UserAttributes\n  ): FeatureVariableValue {\n    if (!this.validateInputs({ feature_key: featureKey, variable_key: variableKey, user_id: userId }, attributes)) {\n      return null;\n    }\n\n    const configObj = this.projectConfigManager.getConfig();\n    if (!configObj) {\n      return null;\n    }\n\n    const featureFlag = projectConfig.getFeatureFromKey(configObj, featureKey, this.logger);\n    if (!featureFlag) {\n      return null;\n    }\n\n    const variable = projectConfig.getVariableForFeature(configObj, featureKey, variableKey, this.logger);\n    if (!variable) {\n      return null;\n    }\n\n    if (variableType && variable.type !== variableType) {\n      this.logger.log(\n        LOG_LEVEL.WARNING,\n        LOG_MESSAGES.VARIABLE_REQUESTED_WITH_WRONG_TYPE,\n        MODULE_NAME,\n        variableType,\n        variable.type\n      );\n      return null;\n    }\n\n    const user = this.createInternalUserContext(userId, attributes) as OptimizelyUserContext;\n    const decisionObj = this.decisionService.getVariationForFeature(configObj, featureFlag, user).result;\n    const featureEnabled = decision.getFeatureEnabledFromVariation(decisionObj);\n    const variableValue = this.getFeatureVariableValueFromVariation(\n      featureKey,\n      featureEnabled,\n      decisionObj.variation,\n      variable,\n      userId\n    );\n    let sourceInfo = {};\n    if (\n      decisionObj.decisionSource === DECISION_SOURCES.FEATURE_TEST &&\n      decisionObj.experiment !== null &&\n      decisionObj.variation !== null\n    ) {\n      sourceInfo = {\n        experimentKey: decisionObj.experiment.key,\n        variationKey: decisionObj.variation.key,\n      };\n    }\n\n    this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.DECISION, {\n      type: DECISION_NOTIFICATION_TYPES.FEATURE_VARIABLE,\n      userId: userId,\n      attributes: attributes || {},\n      decisionInfo: {\n        featureKey: featureKey,\n        featureEnabled: featureEnabled,\n        source: decisionObj.decisionSource,\n        variableKey: variableKey,\n        variableValue: variableValue,\n        variableType: variable.type,\n        sourceInfo: sourceInfo,\n      },\n    });\n    return variableValue;\n  }\n\n  /**\n   * Helper method to get the non type-casted value for a variable attached to a\n   * feature flag. Returns appropriate variable value depending on whether there\n   * was a matching variation, feature was enabled or not or varible was part of the\n   * available variation or not. Also logs the appropriate message explaining how it\n   * evaluated the value of the variable.\n   *\n   * @param  {string}          featureKey           Key of the feature whose variable's value is\n   *                                                being accessed\n   * @param  {boolean}         featureEnabled       Boolean indicating if feature is enabled or not\n   * @param  {Variation}       variation            variation returned by decision service\n   * @param  {FeatureVariable} variable             varible whose value is being evaluated\n   * @param  {string}          userId               ID for the user\n   * @return {unknown}                              Value of the variable or null if the\n   *                                                config Obj is null\n   */\n  private getFeatureVariableValueFromVariation(\n    featureKey: string,\n    featureEnabled: boolean,\n    variation: Variation | null,\n    variable: FeatureVariable,\n    userId: string\n  ): FeatureVariableValue {\n    const configObj = this.projectConfigManager.getConfig();\n    if (!configObj) {\n      return null;\n    }\n\n    let variableValue = variable.defaultValue;\n    if (variation !== null) {\n      const value = projectConfig.getVariableValueForVariation(configObj, variable, variation, this.logger);\n      if (value !== null) {\n        if (featureEnabled) {\n          variableValue = value;\n          this.logger.log(\n            LOG_LEVEL.INFO,\n            LOG_MESSAGES.USER_RECEIVED_VARIABLE_VALUE,\n            MODULE_NAME,\n            variableValue,\n            variable.key,\n            featureKey\n          );\n        } else {\n          this.logger.log(\n            LOG_LEVEL.INFO,\n            LOG_MESSAGES.FEATURE_NOT_ENABLED_RETURN_DEFAULT_VARIABLE_VALUE,\n            MODULE_NAME,\n            featureKey,\n            userId,\n            variableValue\n          );\n        }\n      } else {\n        this.logger.log(\n          LOG_LEVEL.INFO,\n          LOG_MESSAGES.VARIABLE_NOT_USED_RETURN_DEFAULT_VARIABLE_VALUE,\n          MODULE_NAME,\n          variable.key,\n          variation.key\n        );\n      }\n    } else {\n      this.logger.log(\n        LOG_LEVEL.INFO,\n        LOG_MESSAGES.USER_RECEIVED_DEFAULT_VARIABLE_VALUE,\n        MODULE_NAME,\n        userId,\n        variable.key,\n        featureKey\n      );\n    }\n\n    return projectConfig.getTypeCastValue(variableValue, variable.type, this.logger);\n  }\n\n  /**\n   * Returns value for the given boolean variable attached to the given feature\n   * flag.\n   * @param  {string}         featureKey   Key of the feature whose variable's value is\n   *                                       being accessed\n   * @param  {string}         variableKey  Key of the variable whose value is being\n   *                                       accessed\n   * @param  {string}         userId       ID for the user\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {boolean|null}                Boolean value of the variable, or null if the\n   *                                       feature key is invalid, the variable key is invalid,\n   *                                       or there is a mismatch with the type of the variable.\n   */\n  getFeatureVariableBoolean(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): boolean | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getFeatureVariableBoolean');\n        return null;\n      }\n      return this.getFeatureVariableForType(\n        featureKey,\n        variableKey,\n        FEATURE_VARIABLE_TYPES.BOOLEAN,\n        userId,\n        attributes\n      ) as boolean | null;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Returns value for the given double variable attached to the given feature\n   * flag.\n   * @param  {string} featureKey           Key of the feature whose variable's value is\n   *                                       being accessed\n   * @param  {string} variableKey          Key of the variable whose value is being\n   *                                       accessed\n   * @param  {string} userId               ID for the user\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {number|null}                 Number value of the variable, or null if the\n   *                                       feature key is invalid, the variable key is\n   *                                       invalid, or there is a mismatch with the type\n   *                                       of the variable\n   */\n  getFeatureVariableDouble(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): number | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getFeatureVariableDouble');\n        return null;\n      }\n      return this.getFeatureVariableForType(\n        featureKey,\n        variableKey,\n        FEATURE_VARIABLE_TYPES.DOUBLE,\n        userId,\n        attributes\n      ) as number | null;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Returns value for the given integer variable attached to the given feature\n   * flag.\n   * @param  {string}         featureKey   Key of the feature whose variable's value is\n   *                                       being accessed\n   * @param  {string}         variableKey  Key of the variable whose value is being\n   *                                       accessed\n   * @param  {string}         userId       ID for the user\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {number|null}                 Number value of the variable, or null if the\n   *                                       feature key is invalid, the variable key is\n   *                                       invalid, or there is a mismatch with the type\n   *                                       of the variable\n   */\n  getFeatureVariableInteger(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): number | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getFeatureVariableInteger');\n        return null;\n      }\n      return this.getFeatureVariableForType(\n        featureKey,\n        variableKey,\n        FEATURE_VARIABLE_TYPES.INTEGER,\n        userId,\n        attributes\n      ) as number | null;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Returns value for the given string variable attached to the given feature\n   * flag.\n   * @param  {string}         featureKey   Key of the feature whose variable's value is\n   *                                       being accessed\n   * @param  {string}         variableKey  Key of the variable whose value is being\n   *                                       accessed\n   * @param  {string}         userId       ID for the user\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {string|null}                 String value of the variable, or null if the\n   *                                       feature key is invalid, the variable key is\n   *                                       invalid, or there is a mismatch with the type\n   *                                       of the variable\n   */\n  getFeatureVariableString(\n    featureKey: string,\n    variableKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): string | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getFeatureVariableString');\n        return null;\n      }\n      return this.getFeatureVariableForType(\n        featureKey,\n        variableKey,\n        FEATURE_VARIABLE_TYPES.STRING,\n        userId,\n        attributes\n      ) as string | null;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Returns value for the given json variable attached to the given feature\n   * flag.\n   * @param  {string}         featureKey   Key of the feature whose variable's value is\n   *                                       being accessed\n   * @param  {string}         variableKey  Key of the variable whose value is being\n   *                                       accessed\n   * @param  {string}         userId       ID for the user\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {unknown}                     Object value of the variable, or null if the\n   *                                       feature key is invalid, the variable key is\n   *                                       invalid, or there is a mismatch with the type\n   *                                       of the variable\n   */\n  getFeatureVariableJSON(featureKey: string, variableKey: string, userId: string, attributes: UserAttributes): unknown {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getFeatureVariableJSON');\n        return null;\n      }\n      return this.getFeatureVariableForType(featureKey, variableKey, FEATURE_VARIABLE_TYPES.JSON, userId, attributes);\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Returns values for all the variables attached to the given feature\n   * flag.\n   * @param  {string}         featureKey   Key of the feature whose variables are being\n   *                                       accessed\n   * @param  {string}         userId       ID for the user\n   * @param  {UserAttributes} attributes   Optional user attributes\n   * @return {object|null}                 Object containing all the variables, or null if the\n   *                                       feature key is invalid\n   */\n  getAllFeatureVariables(\n    featureKey: string,\n    userId: string,\n    attributes?: UserAttributes\n  ): { [variableKey: string]: unknown } | null {\n    try {\n      if (!this.isValidInstance()) {\n        this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'getAllFeatureVariables');\n        return null;\n      }\n\n      if (!this.validateInputs({ feature_key: featureKey, user_id: userId }, attributes)) {\n        return null;\n      }\n\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return null;\n      }\n\n      const featureFlag = projectConfig.getFeatureFromKey(configObj, featureKey, this.logger);\n      if (!featureFlag) {\n        return null;\n      }\n\n      const user = this.createInternalUserContext(userId, attributes) as OptimizelyUserContext;\n\n      const decisionObj = this.decisionService.getVariationForFeature(configObj, featureFlag, user).result;\n      const featureEnabled = decision.getFeatureEnabledFromVariation(decisionObj);\n      const allVariables: { [variableKey: string]: unknown } = {};\n\n      featureFlag.variables.forEach((variable: FeatureVariable) => {\n        allVariables[variable.key] = this.getFeatureVariableValueFromVariation(\n          featureKey,\n          featureEnabled,\n          decisionObj.variation,\n          variable,\n          userId\n        );\n      });\n\n      let sourceInfo = {};\n      if (\n        decisionObj.decisionSource === DECISION_SOURCES.FEATURE_TEST &&\n        decisionObj.experiment !== null &&\n        decisionObj.variation !== null\n      ) {\n        sourceInfo = {\n          experimentKey: decisionObj.experiment.key,\n          variationKey: decisionObj.variation.key,\n        };\n      }\n      this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.DECISION, {\n        type: DECISION_NOTIFICATION_TYPES.ALL_FEATURE_VARIABLES,\n        userId: userId,\n        attributes: attributes || {},\n        decisionInfo: {\n          featureKey: featureKey,\n          featureEnabled: featureEnabled,\n          source: decisionObj.decisionSource,\n          variableValues: allVariables,\n          sourceInfo: sourceInfo,\n        },\n      });\n\n      return allVariables;\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Returns OptimizelyConfig object containing experiments and features data\n   * @return {OptimizelyConfig|null}\n   *\n   * OptimizelyConfig Object Schema\n   * {\n   *   'experimentsMap': {\n   *     'my-fist-experiment': {\n   *       'id': '111111',\n   *       'key': 'my-fist-experiment'\n   *       'variationsMap': {\n   *         'variation_1': {\n   *           'id': '121212',\n   *           'key': 'variation_1',\n   *           'variablesMap': {\n   *             'age': {\n   *               'id': '222222',\n   *               'key': 'age',\n   *               'type': 'integer',\n   *               'value': '0',\n   *             }\n   *           }\n   *         }\n   *       }\n   *     }\n   *   },\n   *   'featuresMap': {\n   *     'awesome-feature': {\n   *       'id': '333333',\n   *       'key': 'awesome-feature',\n   *       'experimentsMap': Object,\n   *       'variationsMap': Object,\n   *     }\n   *   }\n   * }\n   */\n  getOptimizelyConfig(): OptimizelyConfig | null {\n    try {\n      const configObj = this.projectConfigManager.getConfig();\n      if (!configObj) {\n        return null;\n      }\n      return this.projectConfigManager.getOptimizelyConfig();\n    } catch (e) {\n      this.logger.log(LOG_LEVEL.ERROR, e.message);\n      this.errorHandler.handleError(e);\n      return null;\n    }\n  }\n\n  /**\n   * Stop background processes belonging to this instance, including:\n   *\n   * - Active datafile requests\n   * - Pending datafile requests\n   * - Pending event queue flushes\n   *\n   * In-flight datafile requests will be aborted. Any events waiting to be sent\n   * as part of a batched event request will be immediately flushed to the event\n   * dispatcher.\n   *\n   * Returns a Promise that fulfills after all in-flight event dispatcher requests\n   * (including any final request resulting from flushing the queue as described\n   * above) are complete. If there are no in-flight event dispatcher requests and\n   * no queued events waiting to be sent, returns an immediately-fulfilled Promise.\n   *\n   * Returned Promises are fulfilled with result objects containing these\n   * properties:\n   *    - success (boolean): true if the event dispatcher signaled completion of\n   *                         all in-flight and final requests, or if there were no\n   *                         queued events and no in-flight requests. false if an\n   *                         unexpected error was encountered during the close\n   *                         process.\n   *    - reason (string=):  If success is false, this is a string property with\n   *                         an explanatory message.\n   *\n   * NOTE: After close is called, this instance is no longer usable - any events\n   * generated will no longer be sent to the event dispatcher.\n   *\n   * @return {Promise}\n   */\n  close(): Promise<{ success: boolean; reason?: string }> {\n    try {\n      if (this.odpManager) {\n        this.odpManager.stop();\n      }\n\n      this.notificationCenter.clearAllNotificationListeners();\n      const sdkKey = this.projectConfigManager.getConfig()?.sdkKey;\n      if (sdkKey) {\n        NotificationRegistry.removeNotificationCenter(sdkKey);\n      }\n\n      const eventProcessorStoppedPromise = this.eventProcessor.stop();\n      if (this.disposeOnUpdate) {\n        this.disposeOnUpdate();\n        this.disposeOnUpdate = null;\n      }\n      if (this.projectConfigManager) {\n        this.projectConfigManager.stop();\n      }\n      Object.keys(this.readyTimeouts).forEach((readyTimeoutId: string) => {\n        const readyTimeoutRecord = this.readyTimeouts[readyTimeoutId];\n        clearTimeout(readyTimeoutRecord.readyTimeout);\n        readyTimeoutRecord.onClose();\n      });\n      this.readyTimeouts = {};\n      return eventProcessorStoppedPromise.then(\n        function() {\n          return {\n            success: true,\n          };\n        },\n        function(err) {\n          return {\n            success: false,\n            reason: String(err),\n          };\n        }\n      );\n    } catch (err) {\n      this.logger.log(LOG_LEVEL.ERROR, err.message);\n      this.errorHandler.handleError(err);\n      return Promise.resolve({\n        success: false,\n        reason: String(err),\n      });\n    }\n  }\n\n  /**\n   * Returns a Promise that fulfills when this instance is ready to use (meaning\n   * it has a valid datafile), or has failed to become ready within a period of\n   * time (configurable by the timeout property of the options argument), or when\n   * this instance is closed via the close method.\n   *\n   * If a valid datafile was provided in the constructor, the returned Promise is\n   * immediately fulfilled. If an sdkKey was provided, a manager will be used to\n   * fetch  a datafile, and the returned promise will fulfill if that fetch\n   * succeeds or fails before the timeout. The default timeout is 30 seconds,\n   * which will be used if no timeout is provided in the argument options object.\n   *\n   * The returned Promise is fulfilled with a result object containing these\n   * properties:\n   *    - success (boolean): True if this instance is ready to use with a valid\n   *                         datafile, or false if this instance failed to become\n   *                         ready or was closed prior to becoming ready.\n   *    - reason (string=):  If success is false, this is a string property with\n   *                         an explanatory message. Failure could be due to\n   *                         expiration of the timeout, network errors,\n   *                         unsuccessful responses, datafile parse errors,\n   *                         datafile validation errors, or the instance being\n   *                         closed\n   * @param  {Object=}          options\n   * @param  {number|undefined} options.timeout\n   * @return {Promise}\n   */\n  onReady(options?: { timeout?: number }): Promise<OnReadyResult> {\n    let timeoutValue: number | undefined;\n    if (typeof options === 'object' && options !== null) {\n      if (options.timeout !== undefined) {\n        timeoutValue = options.timeout;\n      }\n    }\n    if (!fns.isSafeInteger(timeoutValue)) {\n      timeoutValue = DEFAULT_ONREADY_TIMEOUT;\n    }\n\n    let resolveTimeoutPromise: (value: OnReadyResult) => void;\n    const timeoutPromise = new Promise<OnReadyResult>(resolve => {\n      resolveTimeoutPromise = resolve;\n    });\n\n    const timeoutId = this.nextReadyTimeoutId;\n    this.nextReadyTimeoutId++;\n\n    const onReadyTimeout = () => {\n      delete this.readyTimeouts[timeoutId];\n      resolveTimeoutPromise({\n        success: false,\n        reason: sprintf('onReady timeout expired after %s ms', timeoutValue),\n      });\n    };\n    const readyTimeout = setTimeout(onReadyTimeout, timeoutValue);\n    const onClose = function() {\n      resolveTimeoutPromise({\n        success: false,\n        reason: 'Instance closed',\n      });\n    };\n\n    this.readyTimeouts[timeoutId] = {\n      readyTimeout: readyTimeout,\n      onClose: onClose,\n    };\n\n    this.readyPromise.then(() => {\n      clearTimeout(readyTimeout);\n      delete this.readyTimeouts[timeoutId];\n      resolveTimeoutPromise({\n        success: true,\n      });\n    });\n\n    return Promise.race([this.readyPromise, timeoutPromise]);\n  }\n\n  //============ decide ============//\n\n  /**\n   * Creates a context of the user for which decision APIs will be called.\n   *\n   * A user context will be created successfully even when the SDK is not fully configured yet, so no\n   * this.isValidInstance() check is performed here.\n   *\n   * @param  {string}          userId      (Optional) The user ID to be used for bucketing.\n   * @param  {UserAttributes}  attributes  (Optional) user attributes.\n   * @return {OptimizelyUserContext|null}  An OptimizelyUserContext associated with this OptimizelyClient or\n   *                                       null if provided inputs are invalid\n   */\n  createUserContext(userId?: string, attributes?: UserAttributes): OptimizelyUserContext | null {\n    const userIdentifier = userId ?? this.odpManager?.getVuid();\n\n    if (userIdentifier === undefined || !this.validateInputs({ user_id: userIdentifier }, attributes)) {\n      return null;\n    }\n\n    return new OptimizelyUserContext({\n      optimizely: this,\n      userId: userIdentifier,\n      attributes,\n      shouldIdentifyUser: true,\n    });\n  }\n\n  /**\n   * Creates an internal context of the user for which decision APIs will be called.\n   *\n   * A user context will be created successfully even when the SDK is not fully configured yet, so no\n   * this.isValidInstance() check is performed here.\n   *\n   * @param  {string}          userId      The user ID to be used for bucketing.\n   * @param  {UserAttributes}  attributes  Optional user attributes.\n   * @return {OptimizelyUserContext|null}  An OptimizelyUserContext associated with this OptimizelyClient or\n   *                                       null if provided inputs are invalid\n   */\n  private createInternalUserContext(userId: string, attributes?: UserAttributes): OptimizelyUserContext | null {\n    return new OptimizelyUserContext({\n      optimizely: this,\n      userId,\n      attributes,\n      shouldIdentifyUser: false,\n    });\n  }\n\n  decide(user: OptimizelyUserContext, key: string, options: OptimizelyDecideOption[] = []): OptimizelyDecision {\n    const userId = user.getUserId();\n    const attributes = user.getAttributes();\n    const configObj = this.projectConfigManager.getConfig();\n    const reasons: (string | number)[][] = [];\n    let decisionObj: DecisionObj;\n    if (!this.isValidInstance() || !configObj) {\n      this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'decide');\n      return newErrorDecision(key, user, [DECISION_MESSAGES.SDK_NOT_READY]);\n    }\n\n    const feature = configObj.featureKeyMap[key];\n    if (!feature) {\n      this.logger.log(LOG_LEVEL.ERROR, ERROR_MESSAGES.FEATURE_NOT_IN_DATAFILE, MODULE_NAME, key);\n      return newErrorDecision(key, user, [sprintf(DECISION_MESSAGES.FLAG_KEY_INVALID, key)]);\n    }\n\n    const allDecideOptions = this.getAllDecideOptions(options);\n\n    const forcedDecisionResponse = this.decisionService.findValidatedForcedDecision(configObj, user, key);\n    reasons.push(...forcedDecisionResponse.reasons);\n    const variation = forcedDecisionResponse.result;\n    if (variation) {\n      decisionObj = {\n        experiment: null,\n        variation: variation,\n        decisionSource: DECISION_SOURCES.FEATURE_TEST,\n      };\n    } else {\n      const decisionVariation = this.decisionService.getVariationForFeature(configObj, feature, user, allDecideOptions);\n      reasons.push(...decisionVariation.reasons);\n      decisionObj = decisionVariation.result;\n    }\n    const decisionSource = decisionObj.decisionSource;\n    const experimentKey = decisionObj.experiment?.key ?? null;\n    const variationKey = decisionObj.variation?.key ?? null;\n    const flagEnabled: boolean = decision.getFeatureEnabledFromVariation(decisionObj);\n    if (flagEnabled === true) {\n      this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.FEATURE_ENABLED_FOR_USER, MODULE_NAME, key, userId);\n    } else {\n      this.logger.log(LOG_LEVEL.INFO, LOG_MESSAGES.FEATURE_NOT_ENABLED_FOR_USER, MODULE_NAME, key, userId);\n    }\n\n    const variablesMap: { [key: string]: unknown } = {};\n    let decisionEventDispatched = false;\n\n    if (!allDecideOptions[OptimizelyDecideOption.EXCLUDE_VARIABLES]) {\n      feature.variables.forEach(variable => {\n        variablesMap[variable.key] = this.getFeatureVariableValueFromVariation(\n          key,\n          flagEnabled,\n          decisionObj.variation,\n          variable,\n          userId\n        );\n      });\n    }\n\n    if (\n      !allDecideOptions[OptimizelyDecideOption.DISABLE_DECISION_EVENT] &&\n      (decisionSource === DECISION_SOURCES.FEATURE_TEST ||\n        (decisionSource === DECISION_SOURCES.ROLLOUT && projectConfig.getSendFlagDecisionsValue(configObj)))\n    ) {\n      this.sendImpressionEvent(decisionObj, key, userId, flagEnabled, attributes);\n      decisionEventDispatched = true;\n    }\n\n    const shouldIncludeReasons = allDecideOptions[OptimizelyDecideOption.INCLUDE_REASONS];\n\n    let reportedReasons: string[] = [];\n    if (shouldIncludeReasons) {\n      reportedReasons = reasons.map(reason => sprintf(reason[0] as string, ...reason.slice(1)));\n    }\n\n    const featureInfo = {\n      flagKey: key,\n      enabled: flagEnabled,\n      variationKey: variationKey,\n      ruleKey: experimentKey,\n      variables: variablesMap,\n      reasons: reportedReasons,\n      decisionEventDispatched: decisionEventDispatched,\n    };\n\n    this.notificationCenter.sendNotifications(NOTIFICATION_TYPES.DECISION, {\n      type: DECISION_NOTIFICATION_TYPES.FLAG,\n      userId: userId,\n      attributes: attributes,\n      decisionInfo: featureInfo,\n    });\n\n    return {\n      variationKey: variationKey,\n      enabled: flagEnabled,\n      variables: variablesMap,\n      ruleKey: experimentKey,\n      flagKey: key,\n      userContext: user,\n      reasons: reportedReasons,\n    };\n  }\n\n  /**\n   * Get all decide options.\n   * @param  {OptimizelyDecideOption[]}          options   decide options\n   * @return {[key: string]: boolean}             Map of all provided decide options including default decide options\n   */\n  private getAllDecideOptions(options: OptimizelyDecideOption[]): { [key: string]: boolean } {\n    const allDecideOptions = { ...this.defaultDecideOptions };\n    if (!Array.isArray(options)) {\n      this.logger.log(LOG_LEVEL.DEBUG, LOG_MESSAGES.INVALID_DECIDE_OPTIONS, MODULE_NAME);\n    } else {\n      options.forEach(option => {\n        // Filter out all provided decide options that are not in OptimizelyDecideOption[]\n        if (OptimizelyDecideOption[option]) {\n          allDecideOptions[option] = true;\n        } else {\n          this.logger.log(LOG_LEVEL.WARNING, LOG_MESSAGES.UNRECOGNIZED_DECIDE_OPTION, MODULE_NAME, option);\n        }\n      });\n    }\n\n    return allDecideOptions;\n  }\n\n  /**\n   * Returns an object of decision results for multiple flag keys and a user context.\n   * If the SDK finds an error for a key, the response will include a decision for the key showing reasons for the error.\n   * The SDK will always return an object of decisions. When it cannot process requests, it will return an empty object after logging the errors.\n   * @param     {OptimizelyUserContext}      user        A user context associated with this OptimizelyClient\n   * @param     {string[]}                   keys        An array of flag keys for which decisions will be made.\n   * @param     {OptimizelyDecideOption[]}  options     An array of options for decision-making.\n   * @return    {[key: string]: OptimizelyDecision}      An object of decision results mapped by flag keys.\n   */\n  decideForKeys(\n    user: OptimizelyUserContext,\n    keys: string[],\n    options: OptimizelyDecideOption[] = []\n  ): { [key: string]: OptimizelyDecision } {\n    const decisionMap: { [key: string]: OptimizelyDecision } = {};\n    if (!this.isValidInstance()) {\n      this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'decideForKeys');\n      return decisionMap;\n    }\n    if (keys.length === 0) {\n      return decisionMap;\n    }\n\n    const allDecideOptions = this.getAllDecideOptions(options);\n    keys.forEach(key => {\n      const optimizelyDecision: OptimizelyDecision = this.decide(user, key, options);\n      if (!allDecideOptions[OptimizelyDecideOption.ENABLED_FLAGS_ONLY] || optimizelyDecision.enabled) {\n        decisionMap[key] = optimizelyDecision;\n      }\n    });\n\n    return decisionMap;\n  }\n\n  /**\n   * Returns an object of decision results for all active flag keys.\n   * @param     {OptimizelyUserContext}      user        A user context associated with this OptimizelyClient\n   * @param     {OptimizelyDecideOption[]}  options     An array of options for decision-making.\n   * @return    {[key: string]: OptimizelyDecision}      An object of all decision results mapped by flag keys.\n   */\n  decideAll(\n    user: OptimizelyUserContext,\n    options: OptimizelyDecideOption[] = []\n  ): { [key: string]: OptimizelyDecision } {\n    const configObj = this.projectConfigManager.getConfig();\n    const decisionMap: { [key: string]: OptimizelyDecision } = {};\n    if (!this.isValidInstance() || !configObj) {\n      this.logger.log(LOG_LEVEL.ERROR, LOG_MESSAGES.INVALID_OBJECT, MODULE_NAME, 'decideAll');\n      return decisionMap;\n    }\n\n    const allFlagKeys = Object.keys(configObj.featureKeyMap);\n\n    return this.decideForKeys(user, allFlagKeys, options);\n  }\n\n  /**\n   * Updates ODP Config with most recent ODP key, host, pixelUrl, and segments from the project config\n   */\n  private updateOdpSettings(): void {\n    const projectConfig = this.projectConfigManager.getConfig();\n\n    if (!projectConfig) {\n      return;\n    }\n\n    if (this.odpManager) {\n      this.odpManager.updateSettings(projectConfig.odpIntegrationConfig);\n    }\n  }\n\n  /**\n   * Sends an action as an ODP Event with optional custom parameters including type, identifiers, and data\n   * Note: Since this depends on this.odpManager, it must await Optimizely client's onReady() promise resolution.\n   * @param {string}              action         Subcategory of the event type (i.e. \"client_initialized\", \"identified\", or a custom action)\n   * @param {string}              type           (Optional) Type of event (Defaults to \"fullstack\")\n   * @param {Map<string, string>} identifiers    (Optional) Key-value map of user identifiers\n   * @param {Map<string, string>} data           (Optional) Event data in a key-value map.\n   */\n  public sendOdpEvent(\n    action: string,\n    type?: string,\n    identifiers?: Map<string, string>,\n    data?: Map<string, unknown>\n  ): void {\n    if (!this.odpManager) {\n      this.logger.error(ERROR_MESSAGES.ODP_EVENT_FAILED_ODP_MANAGER_MISSING);\n      return;\n    }\n\n    const odpEventType = type ?? ODP_DEFAULT_EVENT_TYPE;\n\n    const odpIdentifiers = new Map(identifiers);\n\n    if (identifiers && identifiers.size > 0) {\n      try {\n        identifiers.forEach((identifier_value, identifier_key) => {\n          // Catch for fs-user-id, FS-USER-ID, and FS_USER_ID and assign value to fs_user_id identifier.\n          if (\n            FS_USER_ID_ALIAS === identifier_key.toLowerCase() ||\n            ODP_USER_KEY.FS_USER_ID === identifier_key.toLowerCase()\n          ) {\n            odpIdentifiers.delete(identifier_key);\n            odpIdentifiers.set(ODP_USER_KEY.FS_USER_ID, identifier_value);\n          }\n        });\n      } catch (e) {\n        this.logger.warn(LOG_MESSAGES.ODP_SEND_EVENT_IDENTIFIER_CONVERSION_FAILED);\n      }\n    }\n\n    try {\n      const odpEvent = new OdpEvent(odpEventType, action, odpIdentifiers, data);\n      this.odpManager.sendEvent(odpEvent);\n    } catch (e) {\n      this.logger.error(ERROR_MESSAGES.ODP_EVENT_FAILED, e);\n    }\n  }\n  /**\n   * Checks if ODP (Optimizely Data Platform) is integrated into the project.\n   * @returns { boolean } `true` if ODP settings were found in the datafile otherwise `false`\n   */\n  public isOdpIntegrated(): boolean {\n    return this.projectConfigManager.getConfig()?.odpIntegrationConfig?.integrated ?? false;\n  }\n\n  /**\n   * Identifies user with ODP server in a fire-and-forget manner.\n   * Should be called only after the instance is ready\n   * @param {string} userId\n   */\n  public identifyUser(userId: string): void {\n    if (this.odpManager && this.isOdpIntegrated()) {\n      this.odpManager.identifyUser(userId);\n    }\n  }\n\n  /**\n   * Fetches list of qualified segments from ODP for a particular userId.\n   * @param {string}                          userId\n   * @param {Array<OptimizelySegmentOption>}  options\n   * @returns {Promise<string[] | null>}\n   */\n  public async fetchQualifiedSegments(\n    userId: string,\n    options?: Array<OptimizelySegmentOption>\n  ): Promise<string[] | null> {\n    if (!this.odpManager) {\n      return null;\n    }\n\n    return await this.odpManager.fetchQualifiedSegments(userId, options);\n  }\n\n  /**\n   * @returns {string|undefined}    Currently provisioned VUID from local ODP Manager or undefined if\n   *                                ODP Manager has not been instantiated yet for any reason.\n   */\n  public getVuid(): string | undefined {\n    if (!this.odpManager) {\n      this.logger?.error('Unable to get VUID - ODP Manager is not instantiated yet.');\n      return undefined;\n    }\n\n    if (!this.odpManager.isVuidEnabled()) {\n      this.logger.log(LOG_LEVEL.WARNING, 'getVuid() unavailable for this platform', MODULE_NAME);\n      return undefined;\n    }\n\n    return this.odpManager.getVuid();\n  }\n}\n","/**\n * Copyright 2017, 2020, 2022 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides utility method for validating that event tags user has provided are valid\n */\nimport { sprintf } from '../../utils/fns';\n\nimport { ERROR_MESSAGES } from '../enums';\n\nconst MODULE_NAME = 'EVENT_TAGS_VALIDATOR';\n\n/**\n * Validates user's provided event tags\n * @param  {unknown}  eventTags\n * @return {boolean} true if event tags are valid\n * @throws If event tags are not valid\n */\nexport function validate(eventTags: unknown): boolean {\n  if (typeof eventTags === 'object' && !Array.isArray(eventTags) && eventTags !== null) {\n    return true;\n  } else {\n    throw new Error(sprintf(ERROR_MESSAGES.INVALID_EVENT_TAGS, MODULE_NAME));\n  }\n}\n","/**\n * Copyright 2016-2017, 2020-2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ConsoleLogHandler, LogLevel } from '../../modules/logging';\n\ntype ConsoleLogHandlerConfig = {\n  logLevel?: LogLevel | string;\n  logToConsole?: boolean;\n  prefix?: string;\n}\n\nexport class NoOpLogger {\n  log(): void { }\n}\n\nexport function createLogger(opts?: ConsoleLogHandlerConfig): ConsoleLogHandler {  \n  return new ConsoleLogHandler(opts);\n}\n\nexport function createNoOpLogger(): NoOpLogger {\n  return new NoOpLogger();\n}\n","/**\n * Copyright 2016, 2020-2021, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Default error handler implementation\n */\nexport function handleError(): void {\n  // no-op\n}\n\nexport default {\n  handleError,\n}\n","/**\n * Copyright 2016-2018, 2020-2021, 2024 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport http from 'http';\nimport https from 'https';\nimport url from 'url';\n\nimport { Event } from '../../shared_types';\n\n/**\n * Dispatch an HTTP request to the given url and the specified options\n * @param  {Event}    eventObj           Event object containing\n * @param  {string}   eventObj.url       the url to make the request to\n * @param  {Object}   eventObj.params    parameters to pass to the request (i.e. in the POST body)\n * @param  {string}   eventObj.httpVerb  the HTTP request method type. only POST is supported.\n * @param  {function} callback           callback to execute\n * @return {ClientRequest|undefined}     ClientRequest object which made the request, or undefined if no request was made (error)\n */\nexport const dispatchEvent = function(\n  eventObj: Event,\n  callback: (response: { statusCode: number }) => void\n): http.ClientRequest | void {\n  // Non-POST requests not supported\n  if (eventObj.httpVerb !== 'POST') {\n    return;\n  }\n\n  const parsedUrl = url.parse(eventObj.url);\n\n  const dataString = JSON.stringify(eventObj.params);\n\n  const requestOptions = {\n    host: parsedUrl.host,\n    path: parsedUrl.path,\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n      'content-length': dataString.length.toString(),\n    },\n  };\n\n  const reqWrapper: { req?: http.ClientRequest } = {};\n\n  const requestCallback = function(response?: { statusCode: number }): void {\n    if (response && response.statusCode && response.statusCode >= 200 && response.statusCode < 400) {\n      callback(response);\n    }\n    reqWrapper.req?.destroy();\n    reqWrapper.req = undefined;\n  };\n\n  reqWrapper.req = (parsedUrl.protocol === 'http:' ? http : https)\n    .request(requestOptions, requestCallback as (res: http.IncomingMessage) => void);\n  // Add no-op error listener to prevent this from throwing\n  reqWrapper.req.on('error', function() {\n    reqWrapper.req?.destroy();\n    reqWrapper.req = undefined;\n  });\n  reqWrapper.req.write(dataString);\n  reqWrapper.req.end();\n  return reqWrapper.req;\n};\n\nexport default {\n  dispatchEvent,\n};\n","/**\n * Copyright 2019-2020, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fns from '../fns';\n\n/**\n * Return true if the argument is a valid event batch size, false otherwise\n * @param {unknown}   eventBatchSize\n * @returns {boolean}\n */\nconst validateEventBatchSize = function(eventBatchSize: unknown): boolean {\n  if (typeof eventBatchSize === 'number' && fns.isSafeInteger(eventBatchSize)) {\n    return eventBatchSize >= 1;\n  }\n  return false;\n}\n\n/**\n * Return true if the argument is a valid event flush interval, false otherwise\n * @param {unknown}   eventFlushInterval\n * @returns {boolean}\n */\nconst validateEventFlushInterval = function(eventFlushInterval: unknown): boolean {\n  if (typeof eventFlushInterval === 'number' && fns.isSafeInteger(eventFlushInterval)) {\n    return eventFlushInterval > 0;\n  }\n  return false;\n}\n\nexport default {\n  validateEventBatchSize: validateEventBatchSize,\n  validateEventFlushInterval: validateEventFlushInterval,\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type VisitorAttribute = {\n  entityId: string\n  key: string\n  value: string | number | boolean\n}\n\nexport interface BaseEvent {\n  type: 'impression' | 'conversion'\n  timestamp: number\n  uuid: string\n\n  // projectConfig stuff\n  context: {\n    accountId: string\n    projectId: string\n    clientName: string\n    clientVersion: string\n    revision: string\n    anonymizeIP: boolean\n    botFiltering?: boolean\n  }\n}\n\nexport interface ImpressionEvent extends BaseEvent {\n  type: 'impression'\n\n  user: {\n    id: string\n    attributes: VisitorAttribute[]\n  }\n\n  layer: {\n    id: string | null\n  } | null\n\n  experiment: {\n    id: string | null\n    key: string\n  } | null\n\n  variation: {\n    id: string | null\n    key: string\n  } | null\n\n  ruleKey: string\n  flagKey: string\n  ruleType: string\n  enabled: boolean\n}\n\nexport interface ConversionEvent extends BaseEvent {\n  type: 'conversion'\n\n  user: {\n    id: string\n    attributes: VisitorAttribute[]\n  }\n\n  event: {\n    id: string | null\n    key: string\n  }\n\n  revenue: number | null\n  value: number | null\n  tags: EventTags | undefined\n}\n\nexport type EventTags = {\n  [key: string]: string | number | null\n}\n\nexport function areEventContextsEqual(eventA: BaseEvent, eventB: BaseEvent): boolean {\n  const contextA = eventA.context\n  const contextB = eventB.context\n  return (\n    contextA.accountId === contextB.accountId &&\n    contextA.projectId === contextB.projectId &&\n    contextA.clientName === contextB.clientName &&\n    contextA.clientVersion === contextB.clientVersion &&\n    contextA.revision === contextB.revision &&\n    contextA.anonymizeIP === contextB.anonymizeIP &&\n    contextA.botFiltering === contextB.botFiltering\n  )\n}\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getLogger } from '../logging';\n// TODO change this to use Managed from js-sdk-models when available\nimport { Managed } from './managed';\n\nconst logger = getLogger('EventProcessor');\n\nexport type EventQueueSink<K> = (buffer: K[]) => Promise<any>;\n\nexport interface EventQueue<K> extends Managed {\n  enqueue(event: K): void;\n}\n\nexport interface EventQueueFactory<K> {\n  createEventQueue(config: { sink: EventQueueSink<K>, flushInterval: number, maxQueueSize: number }): EventQueue<K>;\n}\n\nclass Timer {\n  private timeout: number;\n  private callback: () => void;\n  private timeoutId?: number;\n\n  constructor({ timeout, callback }: { timeout: number; callback: () => void }) {\n    this.timeout = Math.max(timeout, 0);\n    this.callback = callback;\n  }\n\n  start(): void {\n    this.timeoutId = setTimeout(this.callback, this.timeout) as any;\n  }\n\n  refresh(): void {\n    this.stop();\n    this.start();\n  }\n\n  stop(): void {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId as any);\n    }\n  }\n}\n\nexport class SingleEventQueue<K> implements EventQueue<K> {\n  private sink: EventQueueSink<K>;\n\n  constructor({ sink }: { sink: EventQueueSink<K> }) {\n    this.sink = sink;\n  }\n\n  start(): Promise<any> {\n    // no-op\n    return Promise.resolve();\n  }\n\n  stop(): Promise<any> {\n    // no-op\n    return Promise.resolve();\n  }\n\n  enqueue(event: K): void {\n    this.sink([event]);\n  }\n}\n\nexport class DefaultEventQueue<K> implements EventQueue<K> {\n  // expose for testing\n  public timer: Timer;\n  private buffer: K[];\n  private maxQueueSize: number;\n  private sink: EventQueueSink<K>;\n  private closingSink?: EventQueueSink<K>;\n  // batchComparator is called to determine whether two events can be included\n  // together in the same batch\n  private batchComparator: (eventA: K, eventB: K) => boolean;\n  private started: boolean;\n\n  constructor({\n    flushInterval,\n    maxQueueSize,\n    sink,\n    closingSink,\n    batchComparator,\n  }: {\n    flushInterval: number;\n    maxQueueSize: number;\n    sink: EventQueueSink<K>;\n    closingSink?: EventQueueSink<K>;\n    batchComparator: (eventA: K, eventB: K) => boolean;\n  }) {\n    this.buffer = [];\n    this.maxQueueSize = Math.max(maxQueueSize, 1);\n    this.sink = sink;\n    this.closingSink = closingSink;\n    this.batchComparator = batchComparator;\n    this.timer = new Timer({\n      callback: this.flush.bind(this),\n      timeout: flushInterval,\n    });\n    this.started = false;\n  }\n\n  start(): Promise<any> {\n    this.started = true;\n    // dont start the timer until the first event is enqueued\n\n    return Promise.resolve();\n  }\n\n  stop(): Promise<any> {\n    this.started = false;\n    const result = this.closingSink ? this.closingSink(this.buffer) : this.sink(this.buffer);\n    this.buffer = [];\n    this.timer.stop();\n    return result;\n  }\n\n  enqueue(event: K): void {\n    if (!this.started) {\n      logger.warn('Queue is stopped, not accepting event');\n      return;\n    }\n\n    // If new event cannot be included into the current batch, flush so it can\n    // be in its own new batch.\n    const bufferedEvent: K | undefined = this.buffer[0];\n    if (bufferedEvent && !this.batchComparator(bufferedEvent, event)) {\n      this.flush();\n    }\n\n    // start the timer when the first event is put in\n    if (this.buffer.length === 0) {\n      this.timer.refresh();\n    }\n    this.buffer.push(event);\n\n    if (this.buffer.length >= this.maxQueueSize) {\n      this.flush();\n    }\n  }\n\n  flush(): void {\n    this.sink(this.buffer);\n    this.buffer = [];\n    this.timer.stop();\n  }\n}\n","/**\n * Copyright 2022-2023 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO change this to use Managed from js-sdk-models when available\nimport { Managed } from './managed'\nimport { ConversionEvent, ImpressionEvent } from './events'\nimport { EventV1Request } from './eventDispatcher'\nimport { EventQueue, DefaultEventQueue, SingleEventQueue, EventQueueSink } from './eventQueue'\nimport { getLogger } from '../logging'\nimport { NOTIFICATION_TYPES } from '../../utils/enums'\nimport { NotificationSender } from '../../core/notification_center'\n\nexport const DEFAULT_FLUSH_INTERVAL = 30000 // Unit is ms - default flush interval is 30s\nexport const DEFAULT_BATCH_SIZE = 10\n\nconst logger = getLogger('EventProcessor')\n\nexport type ProcessableEvent = ConversionEvent | ImpressionEvent\n\nexport type EventDispatchResult = { result: boolean; event: ProcessableEvent }\n\nexport interface EventProcessor extends Managed {\n  process(event: ProcessableEvent): void\n}\n\nexport function validateAndGetFlushInterval(flushInterval: number): number {\n  if (flushInterval <= 0) {\n    logger.warn(\n      `Invalid flushInterval ${flushInterval}, defaulting to ${DEFAULT_FLUSH_INTERVAL}`,\n    )\n    flushInterval = DEFAULT_FLUSH_INTERVAL\n  }\n  return flushInterval\n}\n\nexport function validateAndGetBatchSize(batchSize: number): number {\n  batchSize = Math.floor(batchSize)\n  if (batchSize < 1) {\n    logger.warn(\n      `Invalid batchSize ${batchSize}, defaulting to ${DEFAULT_BATCH_SIZE}`,\n    )\n    batchSize = DEFAULT_BATCH_SIZE\n  }\n  batchSize = Math.max(1, batchSize)\n  return batchSize\n}\n\nexport function getQueue(\n  batchSize: number, \n  flushInterval: number, \n  batchComparator: (eventA: ProcessableEvent, eventB: ProcessableEvent) => boolean,\n  sink: EventQueueSink<ProcessableEvent>,\n  closingSink?: EventQueueSink<ProcessableEvent>\n): EventQueue<ProcessableEvent> {\n  let queue: EventQueue<ProcessableEvent>\n  if (batchSize > 1) {\n    queue = new DefaultEventQueue<ProcessableEvent>({\n      flushInterval,\n      maxQueueSize: batchSize,\n      sink,\n      closingSink,\n      batchComparator,\n    })\n  } else {\n    queue = new SingleEventQueue({ sink })\n  }\n  return queue\n}\n\nexport function sendEventNotification(notificationSender: NotificationSender | undefined, event: EventV1Request): void {\n  if (notificationSender) {\n    notificationSender.sendNotifications(\n      NOTIFICATION_TYPES.LOG_EVENT,\n      event,\n    )\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { objectValues } from '../../utils/fns'\nimport { getLogger } from '../logging';\n\nconst logger = getLogger('EventProcessor')\n\nexport interface PendingEventsStore<K> {\n  get(key: string): K | null\n\n  set(key: string, value: K): void\n\n  remove(key: string): void\n\n  values(): K[]\n\n  clear(): void\n\n  replace(newMap: { [key: string]: K }): void\n}\n\ninterface StoreEntry {\n  uuid: string\n  timestamp: number\n}\n\nexport class LocalStorageStore<K extends StoreEntry> implements PendingEventsStore<K> {\n  protected LS_KEY: string\n  protected maxValues: number\n\n  constructor({ key, maxValues = 1000 }: { key: string; maxValues?: number }) {\n    this.LS_KEY = key\n    this.maxValues = maxValues\n  }\n\n  get(key: string): K | null {\n    return this.getMap()[key] || null\n  }\n\n  set(key: string, value: K): void {\n    const map = this.getMap()\n    map[key] = value\n    this.replace(map)\n  }\n\n  remove(key: string): void {\n    const map = this.getMap()\n    delete map[key]\n    this.replace(map)\n  }\n\n  values(): K[] {\n    return objectValues(this.getMap())\n  }\n\n  clear(): void {\n    this.replace({})\n  }\n\n  replace(map: { [key: string]: K }): void {\n    try {\n      // This is a temporary fix to support React Native which does not have localStorage.\n      typeof window !== 'undefined' ? window && window.localStorage && localStorage.setItem(this.LS_KEY, JSON.stringify(map)) : localStorage.setItem(this.LS_KEY, JSON.stringify(map))\n      this.clean()\n    } catch (e) {\n      logger.error(String(e))\n    }\n  }\n\n  private clean() {\n    const map = this.getMap()\n    const keys = Object.keys(map)\n    const toRemove = keys.length - this.maxValues\n    if (toRemove < 1) {\n      return\n    }\n\n    const entries = keys.map(key => ({\n      key,\n      value: map[key]\n    }))\n\n    entries.sort((a, b) => a.value.timestamp - b.value.timestamp)\n\n    for (let i = 0; i < toRemove; i++) {\n      delete map[entries[i].key]\n    }\n\n    this.replace(map)\n  }\n\n  private getMap(): { [key: string]: K } {\n    try {\n      // This is a temporary fix to support React Native which does not have localStorage.\n      const data = typeof window !== 'undefined' ? window && window.localStorage && localStorage.getItem(this.LS_KEY): localStorage.getItem(this.LS_KEY);\n      if (data) {\n        return (JSON.parse(data) as { [key: string]: K }) || {}\n      }\n    } catch (e: any) {\n      logger.error(e)\n    }\n    return {}\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLogger } from '../logging'\nimport { EventDispatcher, EventV1Request, EventDispatcherCallback } from './eventDispatcher'\nimport { PendingEventsStore, LocalStorageStore } from './pendingEventsStore'\nimport { uuid, getTimestamp } from '../../utils/fns'\n\nconst logger = getLogger('EventProcessor')\n\nexport type DispatcherEntry = {\n  uuid: string\n  timestamp: number\n  request: EventV1Request\n}\n\nexport class PendingEventsDispatcher implements EventDispatcher {\n  protected dispatcher: EventDispatcher\n  protected store: PendingEventsStore<DispatcherEntry>\n\n  constructor({\n    eventDispatcher,\n    store,\n  }: {\n    eventDispatcher: EventDispatcher\n    store: PendingEventsStore<DispatcherEntry>\n  }) {\n    this.dispatcher = eventDispatcher\n    this.store = store\n  }\n\n  dispatchEvent(request: EventV1Request, callback: EventDispatcherCallback): void {\n    this.send(\n      {\n        uuid: uuid(),\n        timestamp: getTimestamp(),\n        request,\n      },\n      callback,\n    )\n  }\n\n  sendPendingEvents(): void {\n    const pendingEvents = this.store.values()\n\n    logger.debug('Sending %s pending events from previous page', pendingEvents.length)\n\n    pendingEvents.forEach(item => {\n      try {\n        this.send(item, () => {})\n      } catch (e)\n        {\n          logger.debug(String(e))\n        }\n    })\n  }\n\n  protected send(entry: DispatcherEntry, callback: EventDispatcherCallback): void {\n    this.store.set(entry.uuid, entry)\n\n    this.dispatcher.dispatchEvent(entry.request, response => {\n      this.store.remove(entry.uuid)\n      callback(response)\n    })\n  }\n}\n\nexport class LocalStoragePendingEventsDispatcher extends PendingEventsDispatcher {\n  constructor({ eventDispatcher }: { eventDispatcher: EventDispatcher }) {\n    super({\n      eventDispatcher,\n      store: new LocalStorageStore({\n        // TODO make this configurable\n        maxValues: 100,\n        key: 'fs_optly_pending_events',\n      }),\n    })\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventTags, ConversionEvent, ImpressionEvent, VisitorAttribute } from '../events'\nimport { ProcessableEvent } from '../eventProcessor'\nimport { EventV1Request } from '../eventDispatcher'\n\nconst ACTIVATE_EVENT_KEY = 'campaign_activated'\nconst CUSTOM_ATTRIBUTE_FEATURE_TYPE = 'custom'\nconst BOT_FILTERING_KEY = '$opt_bot_filtering'\n\nexport type EventV1 = {\n  account_id: string\n  project_id: string\n  revision: string\n  client_name: string\n  client_version: string\n  anonymize_ip: boolean\n  enrich_decisions: boolean\n  visitors: Visitor[]\n}\n\ntype Visitor = {\n  snapshots: Visitor.Snapshot[]\n  visitor_id: string\n  attributes: Visitor.Attribute[]\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace Visitor {\n  type AttributeType = 'custom'\n\n  export type Attribute = {\n    // attribute id\n    entity_id: string\n    // attribute key\n    key: string\n    type: AttributeType\n    value: string | number | boolean\n  }\n\n  export type Snapshot = {\n    decisions?: Decision[]\n    events: SnapshotEvent[]\n  }\n\n  type Decision = {\n    campaign_id: string | null\n    experiment_id: string | null\n    variation_id: string | null\n    metadata: Metadata\n  }\n\n  type Metadata = {\n    flag_key: string;\n    rule_key: string;\n    rule_type: string;\n    variation_key: string;\n    enabled: boolean;\n  }\n\n  export type SnapshotEvent = {\n    entity_id: string | null\n    timestamp: number\n    uuid: string\n    key: string\n    revenue?: number\n    value?: number\n    tags?: EventTags\n  }\n}\n\n\n\ntype Attributes = {\n  [key: string]: string | number | boolean\n}\n\n/**\n * Given an array of batchable Decision or ConversionEvent events it returns\n * a single EventV1 with proper batching\n *\n * @param {ProcessableEvent[]} events\n * @returns {EventV1}\n */\nexport function makeBatchedEventV1(events: ProcessableEvent[]): EventV1 {\n  const visitors: Visitor[] = []\n  const data = events[0]\n\n  events.forEach(event => {\n    if (event.type === 'conversion' || event.type === 'impression') {\n      const visitor = makeVisitor(event)\n\n      if (event.type === 'impression') {\n        visitor.snapshots.push(makeDecisionSnapshot(event))\n      } else if (event.type === 'conversion') {\n        visitor.snapshots.push(makeConversionSnapshot(event))\n      }\n\n      visitors.push(visitor)\n    }\n  })\n\n  return {\n    client_name: data.context.clientName,\n    client_version: data.context.clientVersion,\n\n    account_id: data.context.accountId,\n    project_id: data.context.projectId,\n    revision: data.context.revision,\n    anonymize_ip: data.context.anonymizeIP,\n    enrich_decisions: true,\n\n    visitors,\n  }\n}\n\nfunction makeConversionSnapshot(conversion: ConversionEvent): Visitor.Snapshot {\n  const tags: EventTags = {\n    ...conversion.tags,\n  }\n\n  delete tags['revenue']\n  delete tags['value']\n\n  const event: Visitor.SnapshotEvent = {\n    entity_id: conversion.event.id,\n    key: conversion.event.key,\n    timestamp: conversion.timestamp,\n    uuid: conversion.uuid,\n  }\n\n  if (conversion.tags) {\n    event.tags = conversion.tags\n  }\n\n  if (conversion.value != null) {\n    event.value = conversion.value\n  }\n\n  if (conversion.revenue != null) {\n    event.revenue = conversion.revenue\n  }\n\n  return {\n    events: [event],\n  }\n}\n\nfunction makeDecisionSnapshot(event: ImpressionEvent): Visitor.Snapshot {\n  const { layer, experiment, variation, ruleKey, flagKey, ruleType, enabled } = event\n  const layerId = layer ? layer.id : null\n  const experimentId = experiment?.id ?? ''\n  const variationId = variation?.id ?? ''\n  const variationKey = variation ? variation.key : ''\n\n  return {\n    decisions: [\n      {\n        campaign_id: layerId,\n        experiment_id: experimentId,\n        variation_id: variationId,\n        metadata: {\n          flag_key: flagKey,\n          rule_key: ruleKey,\n          rule_type: ruleType,\n          variation_key: variationKey,\n          enabled: enabled,\n        },\n      },\n    ],\n    events: [\n      {\n        entity_id: layerId,\n        timestamp: event.timestamp,\n        key: ACTIVATE_EVENT_KEY,\n        uuid: event.uuid,\n      },\n    ],\n  }\n}\n\nfunction makeVisitor(data: ImpressionEvent | ConversionEvent): Visitor {\n  const visitor: Visitor = {\n    snapshots: [],\n    visitor_id: data.user.id,\n    attributes: [],\n  }\n\n  const type = 'custom'\n  data.user.attributes.forEach(attr => {\n    visitor.attributes.push({\n      entity_id: attr.entityId,\n      key: attr.key,\n      type: type as 'custom', // tell the compiler this is always string \"custom\"\n      value: attr.value,\n    })\n  })\n\n  if (typeof data.context.botFiltering === 'boolean') {\n    visitor.attributes.push({\n      entity_id: BOT_FILTERING_KEY,\n      key: BOT_FILTERING_KEY,\n      type: CUSTOM_ATTRIBUTE_FEATURE_TYPE,\n      value: data.context.botFiltering,\n    })\n  }\n  return visitor\n}\n\n/**\n * Event for usage with v1 logtier\n *\n * @export\n * @interface EventBuilderV1\n */\n\nexport function buildImpressionEventV1(data: ImpressionEvent): EventV1 {\n  const visitor = makeVisitor(data)\n  visitor.snapshots.push(makeDecisionSnapshot(data))\n\n  return {\n    client_name: data.context.clientName,\n    client_version: data.context.clientVersion,\n\n    account_id: data.context.accountId,\n    project_id: data.context.projectId,\n    revision: data.context.revision,\n    anonymize_ip: data.context.anonymizeIP,\n    enrich_decisions: true,\n\n    visitors: [visitor],\n  }\n}\n\nexport function buildConversionEventV1(data: ConversionEvent): EventV1 {\n  const visitor = makeVisitor(data)\n  visitor.snapshots.push(makeConversionSnapshot(data))\n\n  return {\n    client_name: data.context.clientName,\n    client_version: data.context.clientVersion,\n\n    account_id: data.context.accountId,\n    project_id: data.context.projectId,\n    revision: data.context.revision,\n    anonymize_ip: data.context.anonymizeIP,\n    enrich_decisions: true,\n\n    visitors: [visitor],\n  }\n}\n\nexport function formatEvents(events: ProcessableEvent[]): EventV1Request {\n  return {\n    url: 'https://logx.optimizely.com/v1/events',\n    httpVerb: 'POST',\n    params: makeBatchedEventV1(events),\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * RequestTracker keeps track of in-flight requests for EventProcessor using\n * an internal counter. It exposes methods for adding a new request to be\n * tracked, and getting a Promise representing the completion of currently\n * tracked requests.\n */\nclass RequestTracker {\n  private reqsInFlightCount = 0\n  private reqsCompleteResolvers: Array<() => void> = []\n\n  /**\n   * Track the argument request (represented by a Promise). reqPromise will feed\n   * into the state of Promises returned by onRequestsComplete.\n   * @param {Promise<void>} reqPromise\n   */\n  public trackRequest(reqPromise: Promise<void>): void {\n    this.reqsInFlightCount++\n    const onReqComplete = () => {\n      this.reqsInFlightCount--\n      if (this.reqsInFlightCount === 0) {\n        this.reqsCompleteResolvers.forEach(resolver => resolver())\n        this.reqsCompleteResolvers = []\n      }\n    }\n    reqPromise.then(onReqComplete, onReqComplete)\n  }\n\n  /**\n   * Return a Promise that fulfills after all currently-tracked request promises\n   * are resolved.\n   * @return {Promise<void>}\n   */\n  public onRequestsComplete(): Promise<void> {\n    return new Promise(resolve => {\n      if (this.reqsInFlightCount === 0) {\n        resolve()\n      } else {\n        this.reqsCompleteResolvers.push(resolve)\n      }\n    })\n  }\n}\n\nexport default RequestTracker\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getLogger } from '../../logging'\nimport { NotificationSender } from '../../../core/notification_center'\n\nimport { EventDispatcher } from '../eventDispatcher'\nimport {\n  getQueue,\n  EventProcessor,\n  ProcessableEvent,\n  sendEventNotification,\n  validateAndGetBatchSize,\n  validateAndGetFlushInterval,\n  DEFAULT_BATCH_SIZE,\n  DEFAULT_FLUSH_INTERVAL,\n} from '../eventProcessor'\nimport { EventQueue } from '../eventQueue'\nimport RequestTracker from '../requestTracker'\nimport { areEventContextsEqual } from '../events'\nimport { formatEvents } from './buildEventV1'\n\nconst logger = getLogger('LogTierV1EventProcessor')\n\nexport class LogTierV1EventProcessor implements EventProcessor {\n  private dispatcher: EventDispatcher\n  private closingDispatcher?: EventDispatcher\n  private queue: EventQueue<ProcessableEvent>\n  private notificationCenter?: NotificationSender\n  private requestTracker: RequestTracker\n\n  constructor({\n    dispatcher,\n    closingDispatcher,\n    flushInterval = DEFAULT_FLUSH_INTERVAL,\n    batchSize = DEFAULT_BATCH_SIZE,\n    notificationCenter,\n  }: {\n    dispatcher: EventDispatcher\n    closingDispatcher?: EventDispatcher\n    flushInterval?: number\n    batchSize?: number\n    notificationCenter?: NotificationSender\n  }) {\n    this.dispatcher = dispatcher\n    this.closingDispatcher = closingDispatcher\n    this.notificationCenter = notificationCenter\n    this.requestTracker = new RequestTracker()\n    \n    flushInterval = validateAndGetFlushInterval(flushInterval)\n    batchSize = validateAndGetBatchSize(batchSize)\n    this.queue = getQueue(\n      batchSize,\n      flushInterval,\n      areEventContextsEqual,\n      this.drainQueue.bind(this, false),\n      this.drainQueue.bind(this, true),\n    );\n  }\n\n  private drainQueue(useClosingDispatcher: boolean, buffer: ProcessableEvent[]): Promise<void> {\n    const reqPromise = new Promise<void>(resolve => {\n      logger.debug('draining queue with %s events', buffer.length)\n\n      if (buffer.length === 0) {\n        resolve()\n        return\n      }\n\n      const formattedEvent = formatEvents(buffer)\n      const dispatcher = useClosingDispatcher && this.closingDispatcher\n        ? this.closingDispatcher : this.dispatcher;\n\n      dispatcher.dispatchEvent(formattedEvent, () => {\n        resolve()\n      })\n      sendEventNotification(this.notificationCenter, formattedEvent)\n    })\n    this.requestTracker.trackRequest(reqPromise)\n    return reqPromise\n  }\n\n  process(event: ProcessableEvent): void {\n    this.queue.enqueue(event)\n  }\n\n  // TODO[OASIS-6649]: Don't use any type\n  // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n  stop(): Promise<any> {\n    // swallow - an error stopping this queue shouldn't prevent this from stopping\n    try {\n      this.queue.stop()\n      return this.requestTracker.onRequestsComplete()\n    } catch (e) {\n      logger.error('Error stopping EventProcessor: \"%s\"', Object(e).message, String(e))\n    }\n    return Promise.resolve()\n  }\n\n  async start(): Promise<void> {\n    await this.queue.start()\n  }\n}\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst DEFAULT_UPDATE_INTERVAL_MINUTES = 5;\n/** Standard interval (5 minutes in milliseconds) for polling datafile updates.; */\nexport const DEFAULT_UPDATE_INTERVAL = DEFAULT_UPDATE_INTERVAL_MINUTES * 60 * 1000;\n\nconst MIN_UPDATE_INTERVAL_SECONDS = 30;\n/** Minimum allowed interval (30 seconds in milliseconds) for polling datafile updates. */\nexport const MIN_UPDATE_INTERVAL = MIN_UPDATE_INTERVAL_SECONDS * 1000;\n\nexport const UPDATE_INTERVAL_BELOW_MINIMUM_MESSAGE = `Polling intervals below ${MIN_UPDATE_INTERVAL_SECONDS} seconds are not recommended.`;\n\nexport const DEFAULT_URL_TEMPLATE = `https://cdn.optimizely.com/datafiles/%s.json`;\n\nexport const DEFAULT_AUTHENTICATED_URL_TEMPLATE = `https://config.optimizely.com/datafiles/auth/%s.json`;\n\nexport const BACKOFF_BASE_WAIT_SECONDS_BY_ERROR_COUNT = [0, 8, 16, 32, 64, 128, 256, 512];\n\nexport const REQUEST_TIMEOUT_MS = 60 * 1000; // 1 minute\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport http from 'http';\nimport https from 'https';\nimport url from 'url';\nimport { Headers, AbortableRequest, Response } from './http';\nimport { REQUEST_TIMEOUT_MS } from './config';\nimport decompressResponse from 'decompress-response';\n\n// Shared signature between http.request and https.request\ntype ClientRequestCreator = (options: http.RequestOptions) => http.ClientRequest;\n\nfunction getRequestOptionsFromUrl(url: url.UrlWithStringQuery): http.RequestOptions {\n  return {\n    hostname: url.hostname,\n    path: url.path,\n    port: url.port,\n    protocol: url.protocol,\n  };\n}\n\n/**\n * Convert incomingMessage.headers (which has type http.IncomingHttpHeaders) into our Headers type defined in src/http.ts.\n *\n * Our Headers type is simplified and can't represent mutliple values for the same header name.\n *\n * We don't currently need multiple values support, and the consumer code becomes simpler if it can assume at-most 1 value\n * per header name.\n *\n */\nfunction createHeadersFromNodeIncomingMessage(incomingMessage: http.IncomingMessage): Headers {\n  const headers: Headers = {};\n  Object.keys(incomingMessage.headers).forEach(headerName => {\n    const headerValue = incomingMessage.headers[headerName];\n    if (typeof headerValue === 'string') {\n      headers[headerName] = headerValue;\n    } else if (typeof headerValue === 'undefined') {\n      // no value provided for this header\n    } else {\n      // array\n      if (headerValue.length > 0) {\n        // We don't care about multiple values - just take the first one\n        headers[headerName] = headerValue[0];\n      }\n    }\n  });\n  return headers;\n}\n\nfunction getResponseFromRequest(request: http.ClientRequest): Promise<Response> {\n  // TODO: When we drop support for Node 6, consider using util.promisify instead of\n  // constructing own Promise\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      request.abort();\n      reject(new Error('Request timed out'));\n    }, REQUEST_TIMEOUT_MS);\n\n    request.once('response', (incomingMessage: http.IncomingMessage) => {\n      if (request.aborted) {\n        return;\n      }\n\n      const response = decompressResponse(incomingMessage);\n\n      response.setEncoding('utf8');\n\n      let responseData = '';\n      response.on('data', (chunk: string) => {\n        if (!request.aborted) {\n          responseData += chunk;\n        }\n      });\n\n      response.on('end', () => {\n        if (request.aborted) {\n          return;\n        }\n\n        clearTimeout(timeout);\n\n        resolve({\n          statusCode: incomingMessage.statusCode,\n          body: responseData,\n          headers: createHeadersFromNodeIncomingMessage(incomingMessage),\n        });\n      });\n    });\n\n    request.on('error', (err: any) => {\n      clearTimeout(timeout);\n\n      if (err instanceof Error) {\n        reject(err);\n      } else if (typeof err === 'string') {\n        reject(new Error(err));\n      } else {\n        reject(new Error('Request error'));\n      }\n    });\n  });\n}\n\nexport function makeGetRequest(reqUrl: string, headers: Headers): AbortableRequest {\n  // TODO: Use non-legacy URL parsing when we drop support for Node 6\n  const parsedUrl = url.parse(reqUrl);\n\n  let requester: ClientRequestCreator;\n  if (parsedUrl.protocol === 'http:') {\n    requester = http.request;\n  } else if (parsedUrl.protocol === 'https:') {\n    requester = https.request;\n  } else {\n    return {\n      responsePromise: Promise.reject(new Error(`Unsupported protocol: ${parsedUrl.protocol}`)),\n      abort(): void {},\n    };\n  }\n\n  const requestOptions: http.RequestOptions = {\n    ...getRequestOptionsFromUrl(parsedUrl),\n    method: 'GET',\n    headers: {\n      ...headers,\n      'accept-encoding': 'gzip,deflate',\n    },\n  };\n\n  const request = requester(requestOptions);\n  const responsePromise = getResponseFromRequest(request);\n\n  request.end();\n\n  return {\n    abort(): void {\n      request.abort();\n    },\n    responsePromise,\n  };\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatafileUpdate } from \"./datafileManager\";\n\nexport type Disposer = () => void;\n\nexport type Listener = (arg?: any) => void;\n\ninterface Listeners {\n  [index: string]: {\n    // index is event name\n    [index: string]: Listener; // index is listener id\n  };\n}\n\nexport default class EventEmitter {\n  private listeners: Listeners = {};\n\n  private listenerId = 1;\n\n  on(eventName: string, listener: Listener): Disposer {\n    if (!this.listeners[eventName]) {\n      this.listeners[eventName] = {};\n    }\n    const currentListenerId = String(this.listenerId);\n    this.listenerId++;\n    this.listeners[eventName][currentListenerId] = listener;\n    return (): void => {\n      if (this.listeners[eventName]) {\n        delete this.listeners[eventName][currentListenerId];\n      }\n    };\n  }\n\n  emit(eventName: string, arg?: DatafileUpdate): void {\n    const listeners = this.listeners[eventName];\n    if (listeners) {\n      Object.keys(listeners).forEach(listenerId => {\n        const listener = listeners[listenerId];\n        listener(arg);\n      });\n    }\n  }\n\n  removeAllListeners(): void {\n    this.listeners = {};\n  }\n}\n\n// TODO: Create a typed event emitter for use in TS only (not JS)\n","/**\n * Copyright 2019-2020, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BACKOFF_BASE_WAIT_SECONDS_BY_ERROR_COUNT } from './config';\n\nfunction randomMilliseconds(): number {\n  return Math.round(Math.random() * 1000);\n}\n\nexport default class BackoffController {\n  private errorCount = 0;\n\n  getDelay(): number {\n    if (this.errorCount === 0) {\n      return 0;\n    }\n    const baseWaitSeconds =\n      BACKOFF_BASE_WAIT_SECONDS_BY_ERROR_COUNT[\n        Math.min(BACKOFF_BASE_WAIT_SECONDS_BY_ERROR_COUNT.length - 1, this.errorCount)\n      ];\n    return baseWaitSeconds * 1000 + randomMilliseconds();\n  }\n\n  countError(): void {\n    if (this.errorCount < BACKOFF_BASE_WAIT_SECONDS_BY_ERROR_COUNT.length - 1) {\n      this.errorCount++;\n    }\n  }\n\n  reset(): void {\n    this.errorCount = 0;\n  }\n}\n","/**\n * Copyright 2022-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getLogger } from '../logging';\nimport { sprintf } from '../../utils/fns';\nimport { DatafileManager, DatafileManagerConfig, DatafileUpdate } from './datafileManager';\nimport EventEmitter, { Disposer } from './eventEmitter';\nimport { AbortableRequest, Response, Headers } from './http';\nimport { DEFAULT_UPDATE_INTERVAL, MIN_UPDATE_INTERVAL, DEFAULT_URL_TEMPLATE, UPDATE_INTERVAL_BELOW_MINIMUM_MESSAGE } from './config';\nimport BackoffController from './backoffController';\nimport PersistentKeyValueCache from '../../plugins/key_value_cache/persistentKeyValueCache';\n\nimport { NotificationRegistry } from './../../core/notification_center/notification_registry';\nimport { NOTIFICATION_TYPES } from '../../utils/enums';\n\nconst logger = getLogger('DatafileManager');\n\nconst UPDATE_EVT = 'update';\n\nfunction isSuccessStatusCode(statusCode: number): boolean {\n  return statusCode >= 200 && statusCode < 400;\n}\n\nconst noOpKeyValueCache: PersistentKeyValueCache = {\n  get(): Promise<string | undefined> {\n    return Promise.resolve(undefined);\n  },\n\n  set(): Promise<void> {\n    return Promise.resolve();\n  },\n\n  contains(): Promise<boolean> {\n    return Promise.resolve(false);\n  },\n\n  remove(): Promise<boolean> {\n    return Promise.resolve(false);\n  },\n};\n\nexport default abstract class HttpPollingDatafileManager implements DatafileManager {\n  // Make an HTTP get request to the given URL with the given headers\n  // Return an AbortableRequest, which has a promise for a Response.\n  // If we can't get a response, the promise is rejected.\n  // The request will be aborted if the manager is stopped while the request is in flight.\n  protected abstract makeGetRequest(reqUrl: string, headers: Headers): AbortableRequest;\n\n  // Return any default configuration options that should be applied\n  protected abstract getConfigDefaults(): Partial<DatafileManagerConfig>;\n\n  private currentDatafile: string;\n\n  private readonly readyPromise: Promise<void>;\n\n  private isReadyPromiseSettled: boolean;\n\n  private readyPromiseResolver: () => void;\n\n  private readyPromiseRejecter: (err: Error) => void;\n\n  private readonly emitter: EventEmitter;\n\n  private readonly autoUpdate: boolean;\n\n  private readonly updateInterval: number;\n\n  private currentTimeout: any;\n\n  private isStarted: boolean;\n\n  private lastResponseLastModified?: string;\n\n  private datafileUrl: string;\n\n  private currentRequest: AbortableRequest | null;\n\n  private backoffController: BackoffController;\n\n  private cacheKey: string;\n\n  private cache: PersistentKeyValueCache;\n\n  private sdkKey: string;\n\n  // When true, this means the update interval timeout fired before the current\n  // sync completed. In that case, we should sync again immediately upon\n  // completion of the current request, instead of waiting another update\n  // interval.\n  private syncOnCurrentRequestComplete: boolean;\n\n  constructor(config: DatafileManagerConfig) {\n    const configWithDefaultsApplied: DatafileManagerConfig = {\n      ...this.getConfigDefaults(),\n      ...config,\n    };\n    const {\n      datafile,\n      autoUpdate = false,\n      sdkKey,\n      updateInterval = DEFAULT_UPDATE_INTERVAL,\n      urlTemplate = DEFAULT_URL_TEMPLATE,\n      cache = noOpKeyValueCache,\n    } = configWithDefaultsApplied;\n\n    this.cache = cache;\n    this.cacheKey = 'opt-datafile-' + sdkKey;\n    this.sdkKey = sdkKey;\n    this.isReadyPromiseSettled = false;\n    this.readyPromiseResolver = (): void => { };\n    this.readyPromiseRejecter = (): void => { };\n    this.readyPromise = new Promise((resolve, reject) => {\n      this.readyPromiseResolver = resolve;\n      this.readyPromiseRejecter = reject;\n    });\n\n    if (datafile) {\n      this.currentDatafile = datafile;\n      if (!sdkKey) {\n        this.resolveReadyPromise();\n      }\n    } else {\n      this.currentDatafile = '';\n    }\n\n    this.isStarted = false;\n\n    this.datafileUrl = sprintf(urlTemplate, sdkKey);\n\n    this.emitter = new EventEmitter();\n\n    this.autoUpdate = autoUpdate;\n\n    this.updateInterval = updateInterval;\n    if (this.updateInterval < MIN_UPDATE_INTERVAL) {\n      logger.warn(UPDATE_INTERVAL_BELOW_MINIMUM_MESSAGE);\n    }\n\n    this.currentTimeout = null;\n\n    this.currentRequest = null;\n\n    this.backoffController = new BackoffController();\n\n    this.syncOnCurrentRequestComplete = false;\n  }\n\n  get(): string {\n    return this.currentDatafile;\n  }\n\n  start(): void {\n    if (!this.isStarted) {\n      logger.debug('Datafile manager started');\n      this.isStarted = true;\n      this.backoffController.reset();\n      this.setDatafileFromCacheIfAvailable();\n      this.syncDatafile();\n    }\n  }\n\n  stop(): Promise<void> {\n    logger.debug('Datafile manager stopped');\n    this.isStarted = false;\n    if (this.currentTimeout) {\n      clearTimeout(this.currentTimeout);\n      this.currentTimeout = null;\n    }\n\n    this.emitter.removeAllListeners();\n\n    if (this.currentRequest) {\n      this.currentRequest.abort();\n      this.currentRequest = null;\n    }\n\n    return Promise.resolve();\n  }\n\n  onReady(): Promise<void> {\n    return this.readyPromise;\n  }\n\n  on(eventName: string, listener: (datafileUpdate: DatafileUpdate) => void): Disposer {\n    return this.emitter.on(eventName, listener);\n  }\n\n  private onRequestRejected(err: any): void {\n    if (!this.isStarted) {\n      return;\n    }\n\n    this.backoffController.countError();\n\n    if (err instanceof Error) {\n      logger.error('Error fetching datafile: %s', err.message, err);\n    } else if (typeof err === 'string') {\n      logger.error('Error fetching datafile: %s', err);\n    } else {\n      logger.error('Error fetching datafile');\n    }\n  }\n\n  private onRequestResolved(response: Response): void {\n    if (!this.isStarted) {\n      return;\n    }\n\n    if (typeof response.statusCode !== 'undefined' && isSuccessStatusCode(response.statusCode)) {\n      this.backoffController.reset();\n    } else {\n      this.backoffController.countError();\n    }\n\n    this.trySavingLastModified(response.headers);\n\n    const datafile = this.getNextDatafileFromResponse(response);\n    if (datafile !== '') {\n      logger.info('Updating datafile from response');\n      this.currentDatafile = datafile;\n      this.cache.set(this.cacheKey, datafile);\n      if (!this.isReadyPromiseSettled) {\n        this.resolveReadyPromise();\n      } else {\n        const datafileUpdate: DatafileUpdate = {\n          datafile,\n        };\n        NotificationRegistry.getNotificationCenter(this.sdkKey, logger)?.sendNotifications(\n          NOTIFICATION_TYPES.OPTIMIZELY_CONFIG_UPDATE\n        );\n        this.emitter.emit(UPDATE_EVT, datafileUpdate);\n      }\n    }\n  }\n\n  private onRequestComplete(this: HttpPollingDatafileManager): void {\n    if (!this.isStarted) {\n      return;\n    }\n\n    this.currentRequest = null;\n\n    if (!this.isReadyPromiseSettled && !this.autoUpdate) {\n      // We will never resolve ready, so reject it\n      this.rejectReadyPromise(new Error('Failed to become ready'));\n    }\n\n    if (this.autoUpdate && this.syncOnCurrentRequestComplete) {\n      this.syncDatafile();\n    }\n    this.syncOnCurrentRequestComplete = false;\n  }\n\n  private syncDatafile(): void {\n    const headers: Headers = {};\n    if (this.lastResponseLastModified) {\n      headers['if-modified-since'] = this.lastResponseLastModified;\n    }\n\n    logger.debug('Making datafile request to url %s with headers: %s', this.datafileUrl, () => JSON.stringify(headers));\n    this.currentRequest = this.makeGetRequest(this.datafileUrl, headers);\n\n    const onRequestComplete = (): void => {\n      this.onRequestComplete();\n    };\n    const onRequestResolved = (response: Response): void => {\n      this.onRequestResolved(response);\n    };\n    const onRequestRejected = (err: any): void => {\n      this.onRequestRejected(err);\n    };\n    this.currentRequest.responsePromise\n      .then(onRequestResolved, onRequestRejected)\n      .then(onRequestComplete, onRequestComplete);\n\n    if (this.autoUpdate) {\n      this.scheduleNextUpdate();\n    }\n  }\n\n  private resolveReadyPromise(): void {\n    this.readyPromiseResolver();\n    this.isReadyPromiseSettled = true;\n  }\n\n  private rejectReadyPromise(err: Error): void {\n    this.readyPromiseRejecter(err);\n    this.isReadyPromiseSettled = true;\n  }\n\n  private scheduleNextUpdate(): void {\n    const currentBackoffDelay = this.backoffController.getDelay();\n    const nextUpdateDelay = Math.max(currentBackoffDelay, this.updateInterval);\n    logger.debug('Scheduling sync in %s ms', nextUpdateDelay);\n    this.currentTimeout = setTimeout(() => {\n      if (this.currentRequest) {\n        this.syncOnCurrentRequestComplete = true;\n      } else {\n        this.syncDatafile();\n      }\n    }, nextUpdateDelay);\n  }\n\n  private getNextDatafileFromResponse(response: Response): string {\n    logger.debug('Response status code: %s', response.statusCode);\n    if (typeof response.statusCode === 'undefined') {\n      return '';\n    }\n    if (response.statusCode === 304) {\n      return '';\n    }\n    if (isSuccessStatusCode(response.statusCode)) {\n      return response.body;\n    }\n    logger.error(`Datafile fetch request failed with status: ${response.statusCode}`);\n    return '';\n  }\n\n  private trySavingLastModified(headers: Headers): void {\n    const lastModifiedHeader = headers['last-modified'] || headers['Last-Modified'];\n    if (typeof lastModifiedHeader !== 'undefined') {\n      this.lastResponseLastModified = lastModifiedHeader;\n      logger.debug('Saved last modified header value from response: %s', this.lastResponseLastModified);\n    }\n  }\n\n  setDatafileFromCacheIfAvailable(): void {\n    this.cache.get(this.cacheKey).then(datafile => {\n      if (this.isStarted && !this.isReadyPromiseSettled && datafile) {\n        logger.debug('Using datafile from cache');\n        this.currentDatafile = datafile;\n        this.resolveReadyPromise();\n      }\n    });\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getLogger } from '../logging';\nimport { makeGetRequest } from './nodeRequest';\nimport HttpPollingDatafileManager from './httpPollingDatafileManager';\nimport { Headers, AbortableRequest } from './http';\nimport { NodeDatafileManagerConfig, DatafileManagerConfig } from './datafileManager';\nimport { DEFAULT_URL_TEMPLATE, DEFAULT_AUTHENTICATED_URL_TEMPLATE } from './config';\n\nconst logger = getLogger('NodeDatafileManager');\n\nexport default class NodeDatafileManager extends HttpPollingDatafileManager {\n  private accessToken?: string;\n\n  constructor(config: NodeDatafileManagerConfig) {\n    const defaultUrlTemplate = config.datafileAccessToken ? DEFAULT_AUTHENTICATED_URL_TEMPLATE : DEFAULT_URL_TEMPLATE;\n    super({\n      ...config,\n      urlTemplate: config.urlTemplate || defaultUrlTemplate,\n    });\n    this.accessToken = config.datafileAccessToken;\n  }\n\n  protected makeGetRequest(reqUrl: string, headers: Headers): AbortableRequest {\n    const requestHeaders = Object.assign({}, headers);\n    if (this.accessToken) {\n      logger.debug('Adding Authorization header with Bearer Token');\n      requestHeaders['Authorization'] = `Bearer ${this.accessToken}`;\n    }\n    return makeGetRequest(reqUrl, requestHeaders);\n  }\n\n  protected getConfigDefaults(): Partial<DatafileManagerConfig> {\n    return {\n      autoUpdate: true,\n    };\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport NodeDatafileManager from './nodeDatafileManager';\nexport * from './datafileManager';\nexport { NodeDatafileManager as HttpPollingDatafileManager };\nexport default { HttpPollingDatafileManager: NodeDatafileManager };\n","/**\n * Copyright 2021-2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { LoggerFacade } from '../../modules/logging';\nimport datafileManager from '../../modules/datafile-manager/index.node';\nimport { DatafileOptions, DatafileManagerConfig, DatafileManager } from '../../shared_types';\nimport { toDatafile, tryCreatingProjectConfig } from '../../core/project_config';\nimport fns from '../../utils/fns';\n\nexport function createHttpPollingDatafileManager(\n  sdkKey: string,\n  logger: LoggerFacade,\n  // TODO[OASIS-6649]: Don't use object type\n  // eslint-disable-next-line  @typescript-eslint/ban-types\n  datafile?: string | object,\n  datafileOptions?: DatafileOptions,\n): DatafileManager {  \n  const datafileManagerConfig: DatafileManagerConfig = { sdkKey };\n  if (datafileOptions === undefined || (typeof datafileOptions === 'object' && datafileOptions !== null)) {\n    fns.assign(datafileManagerConfig, datafileOptions);\n  }\n  if (datafile) {\n    const { configObj, error } = tryCreatingProjectConfig({\n      datafile: datafile,\n      jsonSchemaValidator: undefined,\n      logger: logger,\n    });\n    \n    if (error) {\n      logger.error(error);\n    }\n    if (configObj) {\n      datafileManagerConfig.datafile = toDatafile(configObj);\n    }\n  }\n  return new datafileManager.HttpPollingDatafileManager(datafileManagerConfig);\n}\n","/**\n * Copyright 2022-2023 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport http from 'http';\nimport https from 'https';\nimport url from 'url';\nimport { AbortableRequest, Headers, RequestHandler, Response } from './http';\nimport decompressResponse from 'decompress-response';\nimport { LogHandler } from '../../modules/logging';\nimport { REQUEST_TIMEOUT_MS } from '../enums';\n\n/**\n * Handles sending requests and receiving responses over HTTP via NodeJS http module\n */\nexport class NodeRequestHandler implements RequestHandler {\n  private readonly logger: LogHandler;\n  private readonly timeout: number;\n\n  constructor(logger: LogHandler, timeout: number = REQUEST_TIMEOUT_MS) {\n    this.logger = logger;\n    this.timeout = timeout;\n  }\n\n  /**\n   * Builds an XMLHttpRequest\n   * @param requestUrl Fully-qualified URL to which to send the request\n   * @param headers List of headers to include in the request\n   * @param method HTTP method to use\n   * @param data? stringified version of data to POST, PUT, etc\n   * @returns AbortableRequest contains both the response Promise and capability to abort()\n   */\n  makeRequest(requestUrl: string, headers: Headers, method: string, data?: string): AbortableRequest {\n    const parsedUrl = url.parse(requestUrl);\n\n    if (parsedUrl.protocol !== 'https:') {\n      return {\n        responsePromise: Promise.reject(new Error(`Unsupported protocol: ${parsedUrl.protocol}`)),\n        abort: () => {},\n      };\n    }\n\n    const request = https.request({\n      ...this.getRequestOptionsFromUrl(parsedUrl),\n      method,\n      headers: {\n        ...headers,\n        'accept-encoding': 'gzip,deflate',\n      },\n      timeout: this.timeout,\n    });\n    const abortableRequest = this.getAbortableRequestFromRequest(request);\n\n    if (data) {\n      request.write(data);\n    }\n    request.end();\n\n    return abortableRequest;\n  }\n\n  /**\n   * Parses a URL into its constituent parts\n   * @param url URL object to parse\n   * @private\n   * @returns https.RequestOptions Standard request options dictionary\n   */\n  private getRequestOptionsFromUrl(url: url.UrlWithStringQuery): https.RequestOptions {\n    return {\n      hostname: url.hostname,\n      path: url.path,\n      port: url.port,\n      protocol: url.protocol,\n    };\n  }\n\n  /**\n   * Parses headers from an http response\n   * @param incomingMessage Incoming response message to parse\n   * @private\n   * @returns Headers Dictionary of headers without duplicates\n   */\n  private createHeadersFromNodeIncomingMessage(incomingMessage: http.IncomingMessage): Headers {\n    const headers: Headers = {};\n    Object.keys(incomingMessage.headers).forEach(headerName => {\n      const headerValue = incomingMessage.headers[headerName];\n      if (typeof headerValue === 'string') {\n        headers[headerName] = headerValue;\n      } else if (typeof headerValue === 'undefined') {\n        // no value provided for this header\n      } else {\n        // array\n        if (headerValue.length > 0) {\n          // We don't care about multiple values - just take the first one\n          headers[headerName] = headerValue[0];\n        }\n      }\n    });\n    return headers;\n  }\n\n  /**\n   * Sends a built request handling response, errors, and events around the transmission\n   * @param request Request to send\n   * @private\n   * @returns AbortableRequest with simplified response promise\n   */\n  private getAbortableRequestFromRequest(request: http.ClientRequest): AbortableRequest {\n    let aborted = false;\n\n    const abort = () => {\n      aborted = true;\n      request.destroy();\n    };\n\n    const responsePromise: Promise<Response> = new Promise((resolve, reject) => {\n      request.on('timeout', () => {\n        aborted = true;\n        request.destroy();\n        reject(new Error('Request timed out'));\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      request.on('error', (err: any) => {\n        if (err instanceof Error) {\n          reject(err);\n        } else if (typeof err === 'string') {\n          reject(new Error(err));\n        } else {\n          reject(new Error('Request error'));\n        }\n      });\n\n      request.once('response', (incomingMessage: http.IncomingMessage) => {\n        if (aborted) {\n          return;\n        }\n\n        const response = decompressResponse(incomingMessage);\n\n        response.setEncoding('utf8');\n\n        let responseData = '';\n        response.on('data', (chunk: string) => {\n          if (!aborted) {\n            responseData += chunk;\n          }\n        });\n\n        response.on('end', () => {\n          if (aborted) {\n            return;\n          }\n\n          resolve({\n            statusCode: incomingMessage.statusCode,\n            body: responseData,\n            headers: this.createHeadersFromNodeIncomingMessage(incomingMessage),\n          });\n        });\n      });\n    });\n\n    return { abort, responsePromise };\n  }\n}\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * CacheElement represents an individual generic item within the LRUCache\n */\nexport class CacheElement<V> {\n  private _value: V | null;\n  private _time: number;\n\n  get value(): V | null {\n    return this._value;\n  }\n  get time(): number {\n    return this._time;\n  }\n\n  constructor(value: V | null = null) {\n    this._value = value;\n    this._time = Date.now();\n  }\n\n  public is_stale(timeout: number): boolean {\n    if (timeout <= 0) return false;\n    return Date.now() - this._time >= timeout;\n  }\n}\n\nexport default CacheElement;\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getLogger } from '../../modules/logging';\nimport CacheElement from './cache_element';\n\nexport interface LRUCacheConfig {\n  maxSize: number;\n  timeout: number;\n}\n\nexport interface ICache<K, V> {\n  lookup(key: K): V | null;\n  save({ key, value }: { key: K; value: V }): void;\n  reset(): void;\n}\n\n/**\n * Least-Recently Used Cache (LRU Cache) Implementation with Generic Key-Value Pairs\n * Analogous to a Map that has a specified max size and a timeout per element.\n * - Removes the least-recently used element from the cache if max size exceeded.\n * - Removes stale elements (entries older than their timeout) from the cache.\n */\nexport class LRUCache<K, V> implements ICache<K, V> {\n  private _map: Map<K, CacheElement<V>> = new Map();\n  private _maxSize; // Defines maximum size of _map\n  private _timeout; // Milliseconds each entry has before it becomes stale\n\n  get map(): Map<K, CacheElement<V>> {\n    return this._map;\n  }\n\n  get maxSize(): number {\n    return this._maxSize;\n  }\n\n  get timeout(): number {\n    return this._timeout;\n  }\n\n  constructor({ maxSize, timeout }: LRUCacheConfig) {\n    const logger = getLogger();\n\n    logger.debug(`Provisioning cache with maxSize of ${maxSize}`);\n    logger.debug(`Provisioning cache with timeout of ${timeout}`);\n\n    this._maxSize = maxSize;\n    this._timeout = timeout;\n  }\n\n  /**\n   * Returns a valid, non-stale value from LRU Cache based on an input key.\n   * Additionally moves the element to the end of the cache and removes from cache if stale.\n   */\n  lookup(key: K): V | null {\n    if (this._maxSize <= 0) {\n      return null;\n    }\n\n    const element: CacheElement<V> | undefined = this._map.get(key);\n\n    if (!element) return null;\n\n    if (element.is_stale(this._timeout)) {\n      this._map.delete(key);\n      return null;\n    }\n\n    this._map.delete(key);\n    this._map.set(key, element);\n\n    return element.value;\n  }\n\n  /**\n   * Inserts/moves an input key-value pair to the end of the LRU Cache.\n   * Removes the least-recently used element if the cache exceeds it's maxSize.\n   */\n  save({ key, value }: { key: K; value: V }): void {\n    if (this._maxSize <= 0) return;\n\n    const element: CacheElement<V> | undefined = this._map.get(key);\n    if (element) this._map.delete(key);\n    this._map.set(key, new CacheElement(value));\n\n    if (this._map.size > this._maxSize) {\n      const firstMapEntryKey = this._map.keys().next().value;\n      this._map.delete(firstMapEntryKey);\n    }\n  }\n\n  /**\n   * Clears the LRU Cache\n   */\n  reset(): void {\n    if (this._maxSize <= 0) return;\n\n    this._map.clear();\n  }\n\n  /**\n   * Reads value from specified key without moving elements in the LRU Cache.\n   * @param {K} key\n   */\n  peek(key: K): V | null {\n    if (this._maxSize <= 0) return null;\n\n    const element: CacheElement<V> | undefined = this._map.get(key);\n\n    return element?.value ?? null;\n  }\n}\n\nexport interface ISegmentsCacheConfig {\n  DEFAULT_CAPACITY: number;\n  DEFAULT_TIMEOUT_SECS: number;\n}\n\nexport default LRUCache;\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport LRUCache, { ISegmentsCacheConfig } from './lru_cache';\n\nexport interface ServerLRUCacheConfig {\n  maxSize?: number;\n  timeout?: number;\n}\n\nexport const ServerLRUCacheConfig: ISegmentsCacheConfig = {\n  DEFAULT_CAPACITY: 10000,\n  DEFAULT_TIMEOUT_SECS: 600,\n};\n\nexport class ServerLRUCache<K, V> extends LRUCache<K, V> {\n  constructor(config?: ServerLRUCacheConfig) {\n    super({\n      maxSize: config?.maxSize?? ServerLRUCacheConfig.DEFAULT_CAPACITY,\n      timeout: config?.timeout?? ServerLRUCacheConfig.DEFAULT_TIMEOUT_SECS * 1000,\n    });\n  }\n}\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { uuid } from '../../utils/fns';\nimport PersistentKeyValueCache from '../key_value_cache/persistentKeyValueCache';\n\nexport interface IVuidManager {\n  readonly vuid: string;\n}\n\n/**\n * Manager for creating, persisting, and retrieving a Visitor Unique Identifier\n */\nexport class VuidManager implements IVuidManager {\n  /**\n   * Prefix used as part of the VUID format\n   * @public\n   * @readonly\n   */\n  static readonly vuid_prefix: string = `vuid_`;\n\n  /**\n   * Unique key used within the persistent value cache against which to\n   * store the VUID\n   * @private\n   */\n  private _keyForVuid = 'optimizely-vuid';\n\n  /**\n   * Current VUID value being used\n   * @private\n   */\n  private _vuid: string;\n\n  /**\n   * Get the current VUID value being used\n   */\n  get vuid(): string {\n    return this._vuid;\n  }\n\n  private constructor() {\n    this._vuid = '';\n  }\n\n  /**\n   * Instance of the VUID Manager\n   * @private\n   */\n  private static _instance: VuidManager;\n\n  /**\n   * Gets the current instance of the VUID Manager, initializing if needed\n   * @param cache Caching mechanism to use for persisting the VUID outside working memory   *\n   * @returns An instance of VuidManager\n   */\n  static async instance(cache: PersistentKeyValueCache): Promise<VuidManager> {\n    if (!this._instance) {\n      this._instance = new VuidManager();\n    }\n\n    if (!this._instance._vuid) {\n      await this._instance.load(cache);\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Attempts to load a VUID from persistent cache or generates a new VUID\n   * @param cache Caching mechanism to use for persisting the VUID outside working memory\n   * @returns Current VUID stored in the VuidManager\n   * @private\n   */\n  private async load(cache: PersistentKeyValueCache): Promise<string> {\n    const cachedValue = await cache.get(this._keyForVuid);\n    if (cachedValue && VuidManager.isVuid(cachedValue)) {\n      this._vuid = cachedValue;\n    } else {\n      this._vuid = this.makeVuid();\n      await this.save(this._vuid, cache);\n    }\n\n    return this._vuid;\n  }\n\n  /**\n   * Creates a new VUID\n   * @returns A new visitor unique identifier\n   * @private\n   */\n  private makeVuid(): string {\n    const maxLength = 32; // required by ODP server\n\n    // make sure UUIDv4 is used (not UUIDv1 or UUIDv6) since the trailing 5 chars will be truncated. See TDD for details.\n    const uuidV4 = uuid();\n    const formatted = uuidV4.replace(/-/g, '').toLowerCase();\n    const vuidFull = `${VuidManager.vuid_prefix}${formatted}`;\n\n    return vuidFull.length <= maxLength ? vuidFull : vuidFull.substring(0, maxLength);\n  }\n\n  /**\n   * Saves a VUID to a persistent cache\n   * @param vuid VUID to be stored\n   * @param cache Caching mechanism to use for persisting the VUID outside working memory\n   * @private\n   */\n  private async save(vuid: string, cache: PersistentKeyValueCache): Promise<void> {\n    await cache.set(this._keyForVuid, vuid);\n  }\n\n  /**\n   * Validates the format of a Visitor Unique Identifier\n   * @param vuid VistorId to check\n   * @returns *true* if the VisitorId is valid otherwise *false* for invalid\n   */\n  static isVuid = (vuid: string): boolean => vuid?.startsWith(VuidManager.vuid_prefix) || false;\n\n  /**\n   * Function used in unit testing to reset the VuidManager\n   * **Important**: This should not to be used in production code\n   * @private\n   */\n  private static _reset(): void {\n    this._instance._vuid = '';\n  }\n}\n","/**\n * Copyright 2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Validate event data value types\n * @param data Event data to be validated\n * @returns True if an invalid type was found in the data otherwise False\n * @private\n */\nexport function invalidOdpDataFound(data: Map<string, any>): boolean {\n  const validTypes: string[] = ['string', 'number', 'boolean'];\n  let foundInvalidValue = false;\n  data.forEach(value => {\n    if (!validTypes.includes(typeof value) && value !== null) {\n      foundInvalidValue = true;\n    }\n  });\n  return foundInvalidValue;\n}\n","/**\n * Copyright 2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst noop = () => {};\n\nexport type ResolvablePromise<T> = {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: any) => void;\n  then: Promise<T>['then'];\n};\n\nexport function resolvablePromise<T>(): ResolvablePromise<T> {\n  let resolve: (value: T | PromiseLike<T>) => void = noop;\n  let reject: (reason?: any) => void = noop;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject, then: promise.then.bind(promise) };\n}\n","/**\n * Copyright 2023-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LOG_MESSAGES } from './../../utils/enums/index';\nimport { getLogger, LogHandler, LogLevel } from '../../modules/logging';\nimport { ERROR_MESSAGES, ODP_USER_KEY } from '../../utils/enums';\n\nimport { VuidManager } from '../../plugins/vuid_manager';\n\nimport { OdpConfig, OdpIntegrationConfig, odpIntegrationsAreEqual } from './odp_config';\nimport { IOdpEventManager } from './odp_event_manager';\nimport { IOdpSegmentManager } from './odp_segment_manager';\nimport { OptimizelySegmentOption } from './optimizely_segment_option';\nimport { invalidOdpDataFound } from './odp_utils';\nimport { OdpEvent } from './odp_event';\nimport { resolvablePromise, ResolvablePromise } from '../../utils/promise/resolvablePromise';\n\n/**\n * Manager for handling internal all business logic related to\n * Optimizely Data Platform (ODP) / Advanced Audience Targeting (AAT)\n */\nexport interface IOdpManager {\n  onReady(): Promise<unknown>;\n\n  isReady(): boolean;\n\n  updateSettings(odpIntegrationConfig: OdpIntegrationConfig): boolean;\n\n  stop(): void;\n\n  fetchQualifiedSegments(userId: string, options?: Array<OptimizelySegmentOption>): Promise<string[] | null>;\n\n  identifyUser(userId?: string, vuid?: string): void;\n\n  sendEvent({ type, action, identifiers, data }: OdpEvent): void;\n\n  isVuidEnabled(): boolean;\n\n  getVuid(): string | undefined;\n}\n\nexport enum Status {\n  Running,\n  Stopped,\n}\n\n/**\n * Orchestrates segments manager, event manager, and ODP configuration\n */\nexport abstract class OdpManager implements IOdpManager {\n  /**\n   * Promise that returns when the OdpManager is finished initializing\n   */\n  private initPromise: Promise<unknown>;\n  private ready = false;\n\n  /**\n   * Promise that resolves when odpConfig becomes available\n   */\n  private configPromise: ResolvablePromise<void>;\n\n  status: Status = Status.Stopped;\n\n  /**\n   * ODP Segment Manager which provides an interface to the remote ODP server (GraphQL API) for audience segments mapping.\n   * It fetches all qualified segments for the given user context and manages the segments cache for all user contexts.\n   */\n  private segmentManager: IOdpSegmentManager;\n\n  /**\n   * ODP Event Manager which provides an interface to the remote ODP server (REST API) for events.\n   * It will queue all pending events (persistent) and send them (in batches of up to 10 events) to the ODP server when possible.\n   */\n  private eventManager: IOdpEventManager;\n\n  /**\n   * Handler for recording execution logs\n   * @protected\n   */\n  protected logger: LogHandler;\n\n  /**\n   * ODP configuration settings for identifying the target API and segments\n   */\n  odpIntegrationConfig?: OdpIntegrationConfig;\n\n  // TODO: Consider accepting logger as a parameter and initializing it in constructor instead\n  constructor({\n    odpIntegrationConfig,\n    segmentManager,\n    eventManager,\n    logger,\n  }: {\n    odpIntegrationConfig?: OdpIntegrationConfig;\n    segmentManager: IOdpSegmentManager;\n    eventManager: IOdpEventManager;\n    logger: LogHandler;\n  }) {\n    this.segmentManager = segmentManager;\n    this.eventManager = eventManager;\n    this.logger = logger;\n\n    this.configPromise = resolvablePromise();\n\n    const readinessDependencies: PromiseLike<unknown>[] = [this.configPromise];\n\n    if (this.isVuidEnabled()) {\n      readinessDependencies.push(this.initializeVuid());\n    }\n\n    this.initPromise = Promise.all(readinessDependencies);\n\n    this.onReady().then(() => {\n      this.ready = true;\n      if (this.isVuidEnabled() && this.status === Status.Running) {\n        this.registerVuid();\n      }\n    });\n\n    if (odpIntegrationConfig) {\n      this.updateSettings(odpIntegrationConfig);\n    }\n  }\n\n  public getStatus(): Status {\n    return this.status;\n  }\n\n  async start(): Promise<void> {\n    if (this.status === Status.Running) {\n      return;\n    }\n\n    if (!this.odpIntegrationConfig) {\n      return Promise.reject(new Error('cannot start without ODP config'));\n    }\n\n    if (!this.odpIntegrationConfig.integrated) {\n      return Promise.reject(new Error('start() called when ODP is not integrated'));\n    }\n\n    this.status = Status.Running;\n    this.segmentManager.updateSettings(this.odpIntegrationConfig.odpConfig);\n    this.eventManager.updateSettings(this.odpIntegrationConfig.odpConfig);\n    this.eventManager.start();\n    return Promise.resolve();\n  }\n\n  async stop(): Promise<void> {\n    if (this.status === Status.Stopped) {\n      return;\n    }\n    this.status = Status.Stopped;\n    await this.eventManager.stop();\n  }\n\n  onReady(): Promise<unknown> {\n    return this.initPromise;\n  }\n\n  isReady(): boolean {\n    return this.ready;\n  }\n\n  /**\n   * Provides a method to update ODP Manager's ODP Config\n   */\n  updateSettings(odpIntegrationConfig: OdpIntegrationConfig): boolean {\n    this.configPromise.resolve();\n\n    // do nothing if config did not change\n    if (this.odpIntegrationConfig && odpIntegrationsAreEqual(this.odpIntegrationConfig, odpIntegrationConfig)) {\n      return false;\n    }\n\n    this.odpIntegrationConfig = odpIntegrationConfig;\n\n    if (odpIntegrationConfig.integrated) {\n      // already running, just propagate updated config to children;\n      if (this.status === Status.Running) {\n        this.segmentManager.updateSettings(odpIntegrationConfig.odpConfig);\n        this.eventManager.updateSettings(odpIntegrationConfig.odpConfig);\n      } else {\n        this.start();\n      }\n    } else {\n      this.stop();\n    }\n    return true;\n  }\n\n  /**\n   * Attempts to fetch and return a list of a user's qualified segments from the local segments cache.\n   * If no cached data exists for the target user, this fetches and caches data from the ODP server instead.\n   * @param {string}                          userId  - Unique identifier of a target user.\n   * @param {Array<OptimizelySegmentOption>}  options - An array of OptimizelySegmentOption used to ignore and/or reset the cache.\n   * @returns {Promise<string[] | null>}      A promise holding either a list of qualified segments or null.\n   */\n  async fetchQualifiedSegments(userId: string, options: Array<OptimizelySegmentOption> = []): Promise<string[] | null> {\n    if (!this.odpIntegrationConfig) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_CONFIG_NOT_AVAILABLE);\n      return null;\n    }\n\n    if (!this.odpIntegrationConfig.integrated) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_NOT_INTEGRATED);\n      return null;\n    }\n\n    if (VuidManager.isVuid(userId)) {\n      return this.segmentManager.fetchQualifiedSegments(ODP_USER_KEY.VUID, userId, options);\n    }\n\n    return this.segmentManager.fetchQualifiedSegments(ODP_USER_KEY.FS_USER_ID, userId, options);\n  }\n\n  /**\n   * Identifies a user via the ODP Event Manager\n   * @param {string}  userId    (Optional) Custom unique identifier of a target user.\n   * @param {string}  vuid      (Optional) Secondary unique identifier of a target user, primarily used by client SDKs.\n   * @returns\n   */\n  identifyUser(userId?: string, vuid?: string): void {\n    if (!this.odpIntegrationConfig) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_CONFIG_NOT_AVAILABLE);\n      return;\n    }\n\n    if (!this.odpIntegrationConfig.integrated) {\n      this.logger.log(LogLevel.INFO, ERROR_MESSAGES.ODP_NOT_INTEGRATED);\n      return;\n    }\n\n    if (userId && VuidManager.isVuid(userId)) {\n      this.eventManager.identifyUser(undefined, userId);\n      return;\n    }\n\n    this.eventManager.identifyUser(userId, vuid);\n  }\n\n  /**\n   * Sends an event to the ODP Server via the ODP Events API\n   * @param {OdpEvent}  > ODP Event to send to event manager\n   */\n  sendEvent({ type, action, identifiers, data }: OdpEvent): void {\n    let mType = type;\n\n    if (typeof mType !== 'string' || mType === '') {\n      mType = 'fullstack';\n    }\n\n    if (!this.odpIntegrationConfig) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_CONFIG_NOT_AVAILABLE);\n      return;\n    }\n\n    if (!this.odpIntegrationConfig.integrated) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_NOT_INTEGRATED);\n      return;\n    }\n\n    if (invalidOdpDataFound(data)) {\n      throw new Error(ERROR_MESSAGES.ODP_INVALID_DATA);\n    }\n\n    if (typeof action !== 'string' || action === '') {\n      throw new Error('ODP action is not valid (cannot be empty).');\n    }\n\n    this.eventManager.sendEvent(new OdpEvent(mType, action, identifiers, data));\n  }\n\n  /**\n   * Identifies if the VUID feature is enabled\n   */\n  abstract isVuidEnabled(): boolean;\n\n  /**\n   * Returns VUID value if it exists\n   */\n  abstract getVuid(): string | undefined;\n\n  protected initializeVuid(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  private registerVuid() {\n    if (!this.odpIntegrationConfig) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_CONFIG_NOT_AVAILABLE);\n      return;\n    }\n\n    if (!this.odpIntegrationConfig.integrated) {\n      this.logger.log(LogLevel.INFO, ERROR_MESSAGES.ODP_NOT_INTEGRATED);\n      return;\n    }\n\n    const vuid = this.getVuid();\n    if (!vuid) {\n      return;\n    }\n\n    try {\n      this.eventManager.registerVuid(vuid);\n    } catch (e) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_VUID_REGISTRATION_FAILED);\n    }\n  }\n}\n","/**\n * Copyright 2022-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LogHandler, LogLevel } from '../../modules/logging';\n\nimport { uuid } from '../../utils/fns';\nimport { ERROR_MESSAGES, ODP_USER_KEY, ODP_DEFAULT_EVENT_TYPE, ODP_EVENT_ACTION } from '../../utils/enums';\n\nimport { OdpEvent } from './odp_event';\nimport { OdpConfig } from './odp_config';\nimport { IOdpEventApiManager } from './odp_event_api_manager';\nimport { invalidOdpDataFound } from './odp_utils';\nimport { IUserAgentParser } from './user_agent_parser';\nimport { scheduleMicrotaskOrTimeout } from '../../utils/microtask';\n\nconst MAX_RETRIES = 3;\n\n/**\n * Event dispatcher's execution states\n */\nexport enum Status {\n  Stopped,\n  Running,\n}\n\n/**\n * Manager for persisting events to the Optimizely Data Platform (ODP)\n */\nexport interface IOdpEventManager {\n  updateSettings(odpConfig: OdpConfig): void;\n\n  start(): void;\n\n  stop(): Promise<void>;\n\n  registerVuid(vuid: string): void;\n\n  identifyUser(userId?: string, vuid?: string): void;\n\n  sendEvent(event: OdpEvent): void;\n\n  flush(retry?: boolean): void;\n}\n\n/**\n * Concrete implementation of a manager for persisting events to the Optimizely Data Platform\n */\nexport abstract class OdpEventManager implements IOdpEventManager {\n  /**\n   * Current state of the event processor\n   */\n  status: Status = Status.Stopped;\n\n  /**\n   * Queue for holding all events to be eventually dispatched\n   * @protected\n   */\n  protected queue = new Array<OdpEvent>();\n\n  /**\n   * Identifier of the currently running timeout so clearCurrentTimeout() can be called\n   * @private\n   */\n  private timeoutId?: NodeJS.Timeout | number;\n\n  /**\n   * ODP configuration settings for identifying the target API and segments\n   * @private\n   */\n  private odpConfig?: OdpConfig;\n\n  /**\n   * REST API Manager used to send the events\n   * @private\n   */\n  private readonly apiManager: IOdpEventApiManager;\n\n  /**\n   * Handler for recording execution logs\n   * @private\n   */\n  private readonly logger: LogHandler;\n\n  /**\n   * Maximum queue size\n   * @protected\n   */\n  protected queueSize!: number;\n\n  /**\n   * Maximum number of events to process at once. Ignored in browser context\n   * @protected\n   */\n  protected batchSize!: number;\n\n  /**\n   * Milliseconds between setTimeout() to process new batches. Ignored in browser context\n   * @protected\n   */\n  protected flushInterval!: number;\n\n  /**\n   * Type of execution context eg node, js, react\n   * @private\n   */\n  private readonly clientEngine: string;\n\n  /**\n   * Version of the client being used\n   * @private\n   */\n  private readonly clientVersion: string;\n\n  /**\n   * Version of the client being used\n   * @private\n   */\n  private readonly userAgentParser?: IUserAgentParser;\n\n  private retries: number;\n\n\n  /**\n   * Information about the user agent\n   * @private\n   */\n  private readonly userAgentData?: Map<string, unknown>;\n\n  constructor({\n    odpConfig,\n    apiManager,\n    logger,\n    clientEngine,\n    clientVersion,\n    queueSize,\n    batchSize,\n    flushInterval,\n    userAgentParser,\n    retries,\n  }: {\n    odpConfig?: OdpConfig;\n    apiManager: IOdpEventApiManager;\n    logger: LogHandler;\n    clientEngine: string;\n    clientVersion: string;\n    queueSize?: number;\n    batchSize?: number;\n    flushInterval?: number;\n    userAgentParser?: IUserAgentParser;\n    retries?: number;\n  }) {\n    this.apiManager = apiManager;\n    this.logger = logger;\n    this.clientEngine = clientEngine;\n    this.clientVersion = clientVersion;\n    this.initParams(batchSize, queueSize, flushInterval);\n    this.status = Status.Stopped;\n    this.userAgentParser = userAgentParser;\n    this.retries = retries || MAX_RETRIES;\n\n    if (userAgentParser) {\n      const { os, device } = userAgentParser.parseUserAgentInfo();\n\n      const userAgentInfo: Record<string, unknown> = {\n        'os': os.name,\n        'os_version': os.version,\n        'device_type': device.type,\n        'model': device.model,\n      };\n\n      this.userAgentData = new Map<string, unknown>(\n        Object.entries(userAgentInfo).filter(([key, value]) => value != null && value != undefined)\n      );\n    }\n\n    if (odpConfig) {\n      this.updateSettings(odpConfig);\n    }\n  }\n\n  protected abstract initParams(\n    batchSize: number | undefined,\n    queueSize: number | undefined,\n    flushInterval: number | undefined\n  ): void;\n\n  /**\n   * Update ODP configuration settings.\n   * @param newConfig New configuration to apply\n   */\n  updateSettings(odpConfig: OdpConfig): void {\n    // do nothing if config did not change\n    if (this.odpConfig && this.odpConfig.equals(odpConfig)) {\n      return;\n    }\n\n    this.flush();\n    this.odpConfig = odpConfig;\n  }\n\n  /**\n   * Cleans up all pending events;\n   */\n  flush(): void {\n    this.processQueue(true);\n  }\n\n  /**\n   * Start the event manager\n   */\n  start(): void {\n    if (!this.odpConfig) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_CONFIG_NOT_AVAILABLE);\n      return;\n    }\n\n    this.status = Status.Running;\n\n    // no need of periodic flush if batchSize is 1\n    if (this.batchSize > 1) {\n      this.setNewTimeout();\n    }\n  }\n\n  /**\n   * Drain the queue sending all remaining events in batches then stop processing\n   */\n  async stop(): Promise<void> {\n    this.logger.log(LogLevel.DEBUG, 'Stop requested.');\n\n    this.flush();\n    this.clearCurrentTimeout();\n    this.status = Status.Stopped;\n    this.logger.log(LogLevel.DEBUG, 'Stopped. Queue Count: %s', this.queue.length);\n  }\n\n  /**\n   * Register a new visitor user id (VUID) in ODP\n   * @param vuid Visitor User ID to send\n   */\n  registerVuid(vuid: string): void {\n    const identifiers = new Map<string, string>();\n    identifiers.set(ODP_USER_KEY.VUID, vuid);\n\n    const event = new OdpEvent(ODP_DEFAULT_EVENT_TYPE, ODP_EVENT_ACTION.INITIALIZED, identifiers);\n    this.sendEvent(event);\n  }\n\n  /**\n   * Associate a full-stack userid with an established VUID\n   * @param {string} userId   (Optional) Full-stack User ID\n   * @param {string} vuid     (Optional) Visitor User ID\n   */\n  identifyUser(userId?: string, vuid?: string): void {\n    const identifiers = new Map<string, string>();\n    if (!userId && !vuid) {\n      this.logger.log(LogLevel.ERROR, ERROR_MESSAGES.ODP_SEND_EVENT_FAILED_UID_MISSING);\n      return;\n    }\n\n    if (vuid) {\n      identifiers.set(ODP_USER_KEY.VUID, vuid);\n    }\n\n    if (userId) {\n      identifiers.set(ODP_USER_KEY.FS_USER_ID, userId);\n    }\n\n    const event = new OdpEvent(ODP_DEFAULT_EVENT_TYPE, ODP_EVENT_ACTION.IDENTIFIED, identifiers);\n    this.sendEvent(event);\n  }\n\n  /**\n   * Send an event to ODP via dispatch queue\n   * @param event ODP Event to forward\n   */\n  sendEvent(event: OdpEvent): void {\n    if (invalidOdpDataFound(event.data)) {\n      this.logger.log(LogLevel.ERROR, 'Event data found to be invalid.');\n    } else {\n      event.data = this.augmentCommonData(event.data);\n      this.enqueue(event);\n    }\n  }\n\n  /**\n   * Add a new event to the main queue\n   * @param event ODP Event to be queued\n   * @private\n   */\n  private enqueue(event: OdpEvent): void {\n    if (this.status === Status.Stopped) {\n      this.logger.log(LogLevel.WARNING, 'Failed to Process ODP Event. ODPEventManager is not running.');\n      return;\n    }\n\n    if (!this.hasNecessaryIdentifiers(event)) {\n      this.logger.log(LogLevel.ERROR, 'ODP events should have at least one key-value pair in identifiers.');\n      return;\n    }\n\n    if (this.queue.length >= this.queueSize) {\n      this.logger.log(\n        LogLevel.WARNING,\n        'Failed to Process ODP Event. Event Queue full. queueSize = %s.',\n        this.queue.length\n      );\n      return;\n    }\n\n    this.queue.push(event);\n    this.processQueue();\n  }\n\n  protected abstract hasNecessaryIdentifiers(event: OdpEvent): boolean;\n\n  /**\n   * Process events in the main queue\n   * @param shouldFlush Flush all events regardless of available queue event count\n   * @private\n   */\n  private processQueue(shouldFlush = false): void {\n    if (this.status !== Status.Running) {\n      return;\n    }\n    \n    if (shouldFlush) {\n      // clear the queue completely\n      this.clearCurrentTimeout();\n\n      while (this.queueContainsItems()) {\n        this.makeAndSend1Batch();\n      }\n    } else if (this.queueHasBatches()) {\n      // Check if queue has a full batch available\n      this.clearCurrentTimeout();\n\n      while (this.queueHasBatches()) {\n        this.makeAndSend1Batch();\n      }\n    }\n\n    // no need for periodic flush if batchSize is 1\n    if (this.batchSize > 1) {\n      this.setNewTimeout();\n    }\n  }\n\n  /**\n   * Clear the currently running timout\n   * @private\n   */\n  private clearCurrentTimeout(): void {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n\n  /**\n   * Start a new timeout\n   * @private\n   */\n  private setNewTimeout(): void {\n    if (this.timeoutId !== undefined) {\n      return;\n    }\n    this.timeoutId = setTimeout(() => this.processQueue(true), this.flushInterval);\n  }\n\n  /**\n   * Make a batch and send it to ODP\n   * @private\n   */\n  private makeAndSend1Batch(): void {\n    if (!this.odpConfig) {\n      return;\n    }\n\n    const batch = this.queue.splice(0, this.batchSize);\n\n    const odpConfig = this.odpConfig;\n\n    if (batch.length > 0) {\n      // put sending the event on another event loop\n      scheduleMicrotaskOrTimeout(async () => {\n        let shouldRetry: boolean;\n        let attemptNumber = 0;\n        do {\n          shouldRetry = await this.apiManager.sendEvents(odpConfig, batch);\n          attemptNumber += 1;\n        } while (shouldRetry && attemptNumber < this.retries);\n      })\n    }\n  }\n\n  /**\n   * Check if main queue has any full/even batches available\n   * @returns True if there are event batches available in the queue otherwise False\n   * @private\n   */\n  private queueHasBatches(): boolean {\n    return this.queueContainsItems() && this.queue.length % this.batchSize === 0;\n  }\n\n  /**\n   * Check if main queue has any items\n   * @returns True if there are any events in the queue otherwise False\n   * @private\n   */\n  private queueContainsItems(): boolean {\n    return this.queue.length > 0;\n  }\n\n  protected abstract discardEventsIfNeeded(): void;\n\n  /**\n   * Add additional common data including an idempotent ID and execution context to event data\n   * @param sourceData Existing event data to augment\n   * @returns Augmented event data\n   * @private\n   */\n  private augmentCommonData(sourceData: Map<string, unknown>): Map<string, unknown> {\n    const data = new Map<string, unknown>(this.userAgentData);\n  \n    data.set('idempotence_id', uuid());\n    data.set('data_source_type', 'sdk');\n    data.set('data_source', this.clientEngine);\n    data.set('data_source_version', this.clientVersion);\n\n    sourceData.forEach((value, key) => data.set(key, value));\n    return data;\n  }\n\n  protected getLogger(): LogHandler {\n    return this.logger;\n  }\n\n  getQueue(): OdpEvent[] {\n    return this.queue;\n  }\n}\n","/****************************************************************************\n * Copyright 2024, Optimizely, Inc. and contributors                        *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    http://www.apache.org/licenses/LICENSE-2.0                            *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\n\nimport { OdpConfig, OdpIntegrationConfig } from '../../../core/odp/odp_config';\nimport { OdpEvent } from '../../../core/odp/odp_event';\nimport { OdpEventApiManager } from '../../../core/odp/odp_event_api_manager';\nimport { LogLevel } from '../../../modules/logging';\nexport class NodeOdpEventApiManager extends OdpEventApiManager {\n  protected shouldSendEvents(events: OdpEvent[]): boolean {\n    return true;\n  }\n\n  protected generateRequestData(\n    odpConfig: OdpConfig,\n    events: OdpEvent[]\n  ): { method: string; endpoint: string; headers: { [key: string]: string }; data: string } {\n\n    const { apiHost, apiKey } = odpConfig;\n    \n    return {\n      method: 'POST',\n      endpoint: `${apiHost}/v3/events`,\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKey,\n      },\n      data: JSON.stringify(events, this.replacer),\n    };\n  }\n\n  private replacer(_: unknown, value: unknown) {\n    if (value instanceof Map) {\n      return Object.fromEntries(value);\n    } else {\n      return value;\n    }\n  }\n}\n","/**\n * Copyright 2022-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LogHandler, LogLevel } from '../../modules/logging';\nimport { OdpEvent } from './odp_event';\nimport { RequestHandler } from '../../utils/http_request_handler/http';\nimport { OdpConfig } from './odp_config';\nimport { ERROR_MESSAGES } from '../../utils/enums';\n\nconst EVENT_SENDING_FAILURE_MESSAGE = 'ODP event send failed';\n\n/**\n * Manager for communicating with the Optimizely Data Platform REST API\n */\nexport interface IOdpEventApiManager {\n  sendEvents(odpConfig: OdpConfig, events: OdpEvent[]): Promise<boolean>;\n}\n\n/**\n * Concrete implementation for accessing the ODP REST API\n */\nexport abstract class OdpEventApiManager implements IOdpEventApiManager {\n  /**\n   * Handler for recording execution logs\n   * @private\n   */\n  private readonly logger: LogHandler;\n\n  /**\n   * Handler for making external HTTP/S requests\n   * @private\n   */\n  private readonly requestHandler: RequestHandler;\n\n  /**\n   * Creates instance to access Optimizely Data Platform (ODP) REST API\n   * @param requestHandler Desired request handler for testing\n   * @param logger Collect and record events/errors for this GraphQL implementation\n   */\n  constructor(requestHandler: RequestHandler, logger: LogHandler) {\n    this.requestHandler = requestHandler;\n    this.logger = logger;\n  }\n\n  getLogger(): LogHandler {\n    return this.logger;\n  }\n\n  /**\n   * Service for sending ODP events to REST API\n   * @param events ODP events to send\n   * @returns Retry is true - if network or server error (5xx), otherwise false\n   */\n  async sendEvents(odpConfig: OdpConfig, events: OdpEvent[]): Promise<boolean> {\n    let shouldRetry = false;\n\n    if (events.length === 0) {\n      this.logger.log(LogLevel.ERROR, `${EVENT_SENDING_FAILURE_MESSAGE} (no events)`);\n      return shouldRetry;\n    }\n\n    if (!this.shouldSendEvents(events)) {\n      return shouldRetry;\n    }\n\n    const { method, endpoint, headers, data } = this.generateRequestData(odpConfig, events);\n\n    let statusCode = 0;\n    try {\n      const request = this.requestHandler.makeRequest(endpoint, headers, method, data);\n      const response = await request.responsePromise;\n      statusCode = response.statusCode ?? statusCode;\n    } catch (err) {\n      let message = 'network error';\n      if (err instanceof Error) {\n        message = (err as Error).message;\n      }\n      this.logger.log(LogLevel.ERROR, `${EVENT_SENDING_FAILURE_MESSAGE} (${message})`);\n      shouldRetry = true;\n    }\n\n    if (statusCode >= 400) {\n      this.logger.log(LogLevel.ERROR, `${EVENT_SENDING_FAILURE_MESSAGE} (${statusCode})`);\n    }\n\n    if (statusCode >= 500) {\n      shouldRetry = true;\n    }\n\n    return shouldRetry;\n  }\n\n  protected abstract shouldSendEvents(events: OdpEvent[]): boolean;\n\n  protected abstract generateRequestData(\n    odpConfig: OdpConfig,\n    events: OdpEvent[]\n  ): {\n    method: string;\n    endpoint: string;\n    headers: { [key: string]: string };\n    data: string;\n  };\n}\n","/**\n * Copyright 2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OdpEvent } from '../../../core/odp/odp_event';\nimport { IOdpEventManager, OdpEventManager } from '../../../core/odp/odp_event_manager';\nimport { LogLevel } from '../../../modules/logging';\n\nconst DEFAULT_BATCH_SIZE = 10;\nconst DEFAULT_FLUSH_INTERVAL_MSECS = 1000;\nconst DEFAULT_SERVER_QUEUE_SIZE = 10000;\n\nexport class NodeOdpEventManager extends OdpEventManager implements IOdpEventManager {\n  protected initParams(\n    batchSize: number | undefined,\n    queueSize: number | undefined,\n    flushInterval: number | undefined\n  ): void {\n    this.queueSize = queueSize || DEFAULT_SERVER_QUEUE_SIZE;\n    this.batchSize = batchSize || DEFAULT_BATCH_SIZE;\n\n    if (flushInterval === 0) {\n      // disable event batching\n      this.batchSize = 1;\n      this.flushInterval = 0;\n    } else {\n      this.flushInterval = flushInterval || DEFAULT_FLUSH_INTERVAL_MSECS;\n    }\n  }\n\n  protected discardEventsIfNeeded(): void {\n    // if Node/server-side context, empty queue items before ready state\n    this.getLogger().log(LogLevel.WARNING, 'ODPConfig not ready. Discarding events in queue.');\n    this.queue = new Array<OdpEvent>();\n  }\n\n  protected hasNecessaryIdentifiers = (event: OdpEvent): boolean => event.identifiers.size >= 1;\n}\n","/**\n * Copyright 2022-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getLogger, LogHandler, LogLevel } from '../../modules/logging';\nimport { ERROR_MESSAGES, ODP_USER_KEY } from '../../utils/enums';\nimport { ICache } from '../../utils/lru_cache';\nimport { IOdpSegmentApiManager } from './odp_segment_api_manager';\nimport { OdpConfig } from './odp_config';\nimport { OptimizelySegmentOption } from './optimizely_segment_option';\n\nexport interface IOdpSegmentManager {\n  fetchQualifiedSegments(\n    userKey: ODP_USER_KEY,\n    userValue: string,\n    options: Array<OptimizelySegmentOption>\n  ): Promise<string[] | null>;\n  reset(): void;\n  makeCacheKey(userKey: string, userValue: string): string;\n  updateSettings(config: OdpConfig): void;\n}\n\n/**\n * Schedules connections to ODP for audience segmentation and caches the results.\n */\nexport class OdpSegmentManager implements IOdpSegmentManager {\n  /**\n   * ODP configuration settings in used\n   * @private\n   */\n  private odpConfig?: OdpConfig;\n\n  /**\n   * Holds cached audience segments\n   * @private\n   */\n  private _segmentsCache: ICache<string, string[]>;\n\n  /**\n   * Getter for private segments cache\n   * @public\n   */\n  get segmentsCache(): ICache<string, string[]> {\n    return this._segmentsCache;\n  }\n\n  /**\n   * GraphQL API Manager used to fetch segments\n   * @private\n   */\n  private odpSegmentApiManager: IOdpSegmentApiManager;\n\n  /**\n   * Handler for recording execution logs\n   * @private\n   */\n  private readonly logger: LogHandler;\n\n  constructor(\n    segmentsCache: ICache<string, string[]>,\n    odpSegmentApiManager: IOdpSegmentApiManager,\n    logger?: LogHandler,\n    odpConfig?: OdpConfig,\n  ) {\n    this.odpConfig = odpConfig;\n    this._segmentsCache = segmentsCache;\n    this.odpSegmentApiManager = odpSegmentApiManager;\n    this.logger = logger || getLogger('OdpSegmentManager');\n  }\n\n  /**\n   * Attempts to fetch and return a list of a user's qualified segments from the local segments cache.\n   * If no cached data exists for the target user, this fetches and caches data from the ODP server instead.\n   * @param userKey Key used for identifying the id type.\n   * @param userValue The id value itself.\n   * @param options An array of OptimizelySegmentOption used to ignore and/or reset the cache.\n   * @returns Qualified segments for the user from the cache or the ODP server if the cache is empty.\n   */\n  async fetchQualifiedSegments(\n    userKey: ODP_USER_KEY,\n    userValue: string,\n    options: Array<OptimizelySegmentOption>\n  ): Promise<string[] | null> {\n    if (!this.odpConfig) {\n      this.logger.log(LogLevel.WARNING, ERROR_MESSAGES.ODP_CONFIG_NOT_AVAILABLE);\n      return null;      \n    }\n\n    const segmentsToCheck = this.odpConfig.segmentsToCheck;\n    if (!segmentsToCheck || segmentsToCheck.length <= 0) {\n      this.logger.log(LogLevel.DEBUG, 'No segments are used in the project. Returning an empty list.');\n      return [];\n    }\n\n    const cacheKey = this.makeCacheKey(userKey, userValue);\n\n    const ignoreCache = options.includes(OptimizelySegmentOption.IGNORE_CACHE);\n    const resetCache = options.includes(OptimizelySegmentOption.RESET_CACHE);\n\n    if (resetCache) {\n      this.reset();\n    }\n\n    if (!ignoreCache && !resetCache) {\n      const cachedSegments = this._segmentsCache.lookup(cacheKey);\n      if (cachedSegments) {\n        this.logger.log(LogLevel.DEBUG, 'ODP cache hit. Returning segments from cache \"%s\".', cacheKey);\n        return cachedSegments;\n      }\n      this.logger.log(LogLevel.DEBUG, `ODP cache miss.`);\n    }\n\n    this.logger.log(LogLevel.DEBUG, `Making a call to ODP server.`);\n\n    const segments = await this.odpSegmentApiManager.fetchSegments(\n      this.odpConfig.apiKey,\n      this.odpConfig.apiHost,\n      userKey,\n      userValue,\n      segmentsToCheck\n    );\n\n    if (segments && !ignoreCache) {\n      this._segmentsCache.save({ key: cacheKey, value: segments });\n    }\n\n    return segments;\n  }\n\n  /**\n   * Clears the segments cache\n   */\n  reset(): void {\n    this._segmentsCache.reset();\n  }\n\n  /**\n   * Creates a key used to identify which user fetchQualifiedSegments should lookup and save to in the segments cache\n   * @param userKey User type based on ODP_USER_KEY, such as \"vuid\" or \"fs_user_id\"\n   * @param userValue Arbitrary string, such as \"test-user\"\n   * @returns Concatenates inputs and returns the string \"{userKey}-$-{userValue}\"\n   */\n  makeCacheKey(userKey: string, userValue: string): string {\n    return `${userKey}-$-${userValue}`;\n  }\n\n  /**\n   * Updates the ODP Config settings of ODP Segment Manager\n   * @param config New ODP Config that will overwrite the existing config\n   */\n  updateSettings(config: OdpConfig): void {\n    this.odpConfig = config;\n    this.reset();\n  }\n}\n","/**\n * Copyright 2016-2017, 2020, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*eslint-disable */\n/**\n * Project Config JSON Schema file used to validate the project json datafile\n */\nimport { JSONSchema4 } from 'json-schema';\n\nvar schemaDefinition = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  title: 'Project Config JSON Schema',\n  type: 'object',\n  properties: {\n    projectId: {\n      type: 'string',\n      required: true,\n    },\n    accountId: {\n      type: 'string',\n      required: true,\n    },\n    groups: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          id: {\n            type: 'string',\n            required: true,\n          },\n          policy: {\n            type: 'string',\n            required: true,\n          },\n          trafficAllocation: {\n            type: 'array',\n            items: {\n              type: 'object',\n              properties: {\n                entityId: {\n                  type: 'string',\n                  required: true,\n                },\n                endOfRange: {\n                  type: 'integer',\n                  required: true,\n                },\n              },\n            },\n            required: true,\n          },\n          experiments: {\n            type: 'array',\n            items: {\n              type: 'object',\n              properties: {\n                id: {\n                  type: 'string',\n                  required: true,\n                },\n                key: {\n                  type: 'string',\n                  required: true,\n                },\n                status: {\n                  type: 'string',\n                  required: true,\n                },\n                layerId: {\n                  type: 'string',\n                  required: true,\n                },\n                variations: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    properties: {\n                      id: {\n                        type: 'string',\n                        required: true,\n                      },\n                      key: {\n                        type: 'string',\n                        required: true,\n                      },\n                    },\n                  },\n                  required: true,\n                },\n                trafficAllocation: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    properties: {\n                      entityId: {\n                        type: 'string',\n                        required: true,\n                      },\n                      endOfRange: {\n                        type: 'integer',\n                        required: true,\n                      },\n                    },\n                  },\n                  required: true,\n                },\n                audienceIds: {\n                  type: 'array',\n                  items: {\n                    type: 'string',\n                  },\n                  required: true,\n                },\n                forcedVariations: {\n                  type: 'object',\n                  required: true,\n                },\n              },\n            },\n            required: true,\n          },\n        },\n      },\n      required: true,\n    },\n    experiments: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          id: {\n            type: 'string',\n            required: true,\n          },\n          key: {\n            type: 'string',\n            required: true,\n          },\n          status: {\n            type: 'string',\n            required: true,\n          },\n          layerId: {\n            type: 'string',\n            required: true,\n          },\n          variations: {\n            type: 'array',\n            items: {\n              type: 'object',\n              properties: {\n                id: {\n                  type: 'string',\n                  required: true,\n                },\n                key: {\n                  type: 'string',\n                  required: true,\n                },\n              },\n            },\n            required: true,\n          },\n          trafficAllocation: {\n            type: 'array',\n            items: {\n              type: 'object',\n              properties: {\n                entityId: {\n                  type: 'string',\n                  required: true,\n                },\n                endOfRange: {\n                  type: 'integer',\n                  required: true,\n                },\n              },\n            },\n            required: true,\n          },\n          audienceIds: {\n            type: 'array',\n            items: {\n              type: 'string',\n            },\n            required: true,\n          },\n          forcedVariations: {\n            type: 'object',\n            required: true,\n          },\n        },\n      },\n      required: true,\n    },\n    events: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          key: {\n            type: 'string',\n            required: true,\n          },\n          experimentIds: {\n            type: 'array',\n            items: {\n              type: 'string',\n              required: true,\n            },\n          },\n          id: {\n            type: 'string',\n            required: true,\n          },\n        },\n      },\n      required: true,\n    },\n    audiences: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          id: {\n            type: 'string',\n            required: true,\n          },\n          name: {\n            type: 'string',\n            required: true,\n          },\n          conditions: {\n            type: 'string',\n            required: true,\n          },\n        },\n      },\n      required: true,\n    },\n    attributes: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          id: {\n            type: 'string',\n            required: true,\n          },\n          key: {\n            type: 'string',\n            required: true,\n          },\n        },\n      },\n      required: true,\n    },\n    version: {\n      type: 'string',\n      required: true,\n    },\n    revision: {\n      type: 'string',\n      required: true,\n    },\n    integrations: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          key: {\n            type: 'string',\n            required: true\n          },\n          host: {\n            type: 'string'\n          },\n          publicKey: {\n            type: 'string'\n          },\n          pixelUrl: {\n            type: 'string'\n          },\n        },\n      },\n    },\n  },\n};\n\nconst schema = schemaDefinition as JSONSchema4\n\nexport default schema\n","/**\n * Copyright 2022, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JSONSchema4 } from 'json-schema';\n\n/**\n * JSON Schema used to validate the ODP GraphQL response\n */\nexport const OdpResponseSchema = {\n  $schema: 'https://json-schema.org/draft/2019-09/schema',\n  $id: 'https://example.com/example.json',\n  title: 'ODP Response Schema',\n  type: 'object',\n  required: [\n    'data',\n  ],\n  properties: {\n    data: {\n      title: 'The data Schema',\n      type: 'object',\n      required: [\n        'customer',\n      ],\n      properties: {\n        customer: {\n          title: 'The customer Schema',\n          type: 'object',\n          required: [],\n          properties: {\n            audiences: {\n              title: 'The audiences Schema',\n              type: 'object',\n              required: [\n                'edges',\n              ],\n              properties: {\n                edges: {\n                  title: 'The edges Schema',\n                  type: 'array',\n                  items: {\n                    title: 'A Schema',\n                    type: 'object',\n                    required: [\n                      'node',\n                    ],\n                    properties: {\n                      node: {\n                        title: 'The node Schema',\n                        type: 'object',\n                        required: [\n                          'name',\n                          'state',\n                        ],\n                        properties: {\n                          name: {\n                            title: 'The name Schema',\n                            type: 'string',\n                            examples: [\n                              'has_email',\n                              'has_email_opted_in',\n                            ],\n                          },\n                          state: {\n                            title: 'The state Schema',\n                            type: 'string',\n                            examples: [\n                              'qualified',\n                            ],\n                          },\n                        },\n                        examples: [],\n                      },\n                    },\n                    examples: [],\n                  },\n                  examples: [],\n                },\n              },\n              examples: [],\n            },\n          },\n          examples: [],\n        },\n      },\n      examples: [],\n    },\n    errors: {\n      title: 'The errors Schema',\n      type: 'array',\n      default: [],\n      items: {\n        title: 'A Schema',\n        type: 'object',\n        required: [\n          'message',\n          'locations',\n          'extensions',\n        ],\n        properties: {\n          message: {\n            title: 'The message Schema',\n            type: 'string',\n            examples: [\n              'Exception while fetching data (/customer) : java.lang.RuntimeException: could not resolve _fs_user_id = asdsdaddddd',\n            ],\n          },\n          locations: {\n            title: 'The locations Schema',\n            type: 'array',\n            items: {\n              title: 'A Schema',\n              type: 'object',\n              required: [\n                'line',\n                'column',\n              ],\n              properties: {\n                line: {\n                  title: 'The line Schema',\n                  type: 'integer',\n                  examples: [\n                    2,\n                  ],\n                },\n                column: {\n                  title: 'The column Schema',\n                  type: 'integer',\n                  examples: [\n                    3,\n                  ],\n                },\n              },\n              examples: [],\n            },\n            examples: [],\n          },\n          path: {\n            title: 'The path Schema',\n            type: 'array',\n            items: {\n              title: 'A Schema',\n              type: 'string',\n              examples: [\n                'customer',\n              ],\n            },\n            examples: [],\n          },\n          extensions: {\n            title: 'The extensions Schema',\n            type: 'object',\n            required: [\n              'classification',\n            ],\n            properties: {\n              classification: {\n                title: 'The classification Schema',\n                type: 'string',\n                examples: [\n                  'InvalidIdentifierException',\n                ],\n              },\n            },\n            examples: [],\n          },\n        },\n        examples: [],\n      },\n      examples: [],\n    },\n  },\n  examples: [],\n} as JSONSchema4;\n","/**\n * Copyright 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LogHandler, LogLevel } from '../../modules/logging';\nimport { validate } from '../../utils/json_schema_validator';\nimport { OdpResponseSchema } from './odp_response_schema';\nimport { ODP_USER_KEY } from '../../utils/enums';\nimport { RequestHandler, Response as HttpResponse } from '../../utils/http_request_handler/http';\nimport { Response as GraphQLResponse } from './odp_types';\n\n/**\n * Expected value for a qualified/valid segment\n */\nconst QUALIFIED = 'qualified';\n/**\n * Return value when no valid segments found\n */\nconst EMPTY_SEGMENTS_COLLECTION: string[] = [];\n/**\n * Return value for scenarios with no valid JSON\n */\nconst EMPTY_JSON_RESPONSE = null;\n/**\n * Standard message for audience querying fetch errors\n */\nconst AUDIENCE_FETCH_FAILURE_MESSAGE = 'Audience segments fetch failed';\n\n/**\n * Manager for communicating with the Optimizely Data Platform GraphQL endpoint\n */\nexport interface IOdpSegmentApiManager {\n  fetchSegments(\n    apiKey: string,\n    apiHost: string,\n    userKey: string,\n    userValue: string,\n    segmentsToCheck: string[]\n  ): Promise<string[] | null>;\n}\n\n/**\n * Concrete implementation for communicating with the ODP GraphQL endpoint\n */\nexport class OdpSegmentApiManager implements IOdpSegmentApiManager {\n  private readonly logger: LogHandler;\n  private readonly requestHandler: RequestHandler;\n\n  /**\n   * Communicates with Optimizely Data Platform's GraphQL endpoint\n   * @param requestHandler Desired request handler for testing\n   * @param logger Collect and record events/errors for this GraphQL implementation\n   */\n  constructor(requestHandler: RequestHandler, logger: LogHandler) {\n    this.requestHandler = requestHandler;\n    this.logger = logger;\n  }\n\n  /**\n   * Retrieves the audience segments from ODP\n   * @param apiKey ODP public key\n   * @param apiHost Host of ODP endpoint\n   * @param userKey 'vuid' or 'fs_user_id key'\n   * @param userValue Associated value to query for the user key\n   * @param segmentsToCheck Audience segments to check for experiment inclusion\n   */\n  async fetchSegments(\n    apiKey: string,\n    apiHost: string,\n    userKey: ODP_USER_KEY,\n    userValue: string,\n    segmentsToCheck: string[]\n  ): Promise<string[] | null> {\n    if (!apiKey || !apiHost) {\n      this.logger.log(LogLevel.ERROR, `${AUDIENCE_FETCH_FAILURE_MESSAGE} (Parameters apiKey or apiHost invalid)`);\n      return null;\n    }\n\n    if (segmentsToCheck?.length === 0) {\n      return EMPTY_SEGMENTS_COLLECTION;\n    }\n\n    const endpoint = `${apiHost}/v3/graphql`;\n    const query = this.toGraphQLJson(userKey, userValue, segmentsToCheck);\n\n    const segmentsResponse = await this.querySegments(apiKey, endpoint, userKey, userValue, query);\n    if (!segmentsResponse) {\n      this.logger.log(LogLevel.ERROR, `${AUDIENCE_FETCH_FAILURE_MESSAGE} (network error)`);\n      return null;\n    }\n\n    const parsedSegments = this.parseSegmentsResponseJson(segmentsResponse);\n    if (!parsedSegments) {\n      this.logger.log(LogLevel.ERROR, `${AUDIENCE_FETCH_FAILURE_MESSAGE} (decode error)`);\n      return null;\n    }\n\n    if (parsedSegments.errors?.length > 0) {\n      const { code, classification } = parsedSegments.errors[0].extensions;\n\n      if (code == 'INVALID_IDENTIFIER_EXCEPTION') {\n        this.logger.log(LogLevel.ERROR, `${AUDIENCE_FETCH_FAILURE_MESSAGE} (invalid identifier)`);\n      } else {\n        this.logger.log(LogLevel.ERROR, `${AUDIENCE_FETCH_FAILURE_MESSAGE} (${classification})`);\n      }\n\n      return null;\n    }\n\n    const edges = parsedSegments?.data?.customer?.audiences?.edges;\n    if (!edges) {\n      this.logger.log(LogLevel.ERROR, `${AUDIENCE_FETCH_FAILURE_MESSAGE} (decode error)`);\n      return null;\n    }\n\n    return edges.filter(edge => edge.node.state == QUALIFIED).map(edge => edge.node.name);\n  }\n\n  /**\n   * Converts the query parameters to a GraphQL JSON payload\n   * @returns GraphQL JSON string\n   */\n  private toGraphQLJson = (userKey: string, userValue: string, segmentsToCheck: string[]): string =>\n    [\n      '{\"query\" : \"query {customer',\n      `(${userKey} : \\\\\"${userValue}\\\\\") `,\n      '{audiences',\n      '(subset: [',\n      ...(segmentsToCheck?.map(\n        (segment, index) => `\\\\\"${segment}\\\\\"${index < segmentsToCheck.length - 1 ? ',' : ''}`\n      ) || ''),\n      ']) {edges {node {name state}}}}}\"}',\n    ].join('');\n\n  /**\n   * Handler for querying the ODP GraphQL endpoint\n   * @param apiKey ODP API key\n   * @param endpoint Fully-qualified GraphQL endpoint URL\n   * @param userKey 'vuid' or 'fs_user_id'\n   * @param userValue userKey's value\n   * @param query GraphQL formatted query string\n   * @returns JSON response string from ODP or null\n   */\n  private async querySegments(\n    apiKey: string,\n    endpoint: string,\n    userKey: string,\n    userValue: string,\n    query: string\n  ): Promise<string | null> {\n    const method = 'POST';\n    const url = endpoint;\n    const headers = {\n      'Content-Type': 'application/json',\n      'x-api-key': apiKey,\n    };\n\n    let response: HttpResponse;\n    try {\n      const request = this.requestHandler.makeRequest(url, headers, method, query);\n      response = await request.responsePromise;\n    } catch {\n      return null;\n    }\n\n    return response.body;\n  }\n\n  /**\n   * Parses JSON response\n   * @param jsonResponse JSON response from ODP\n   * @private\n   * @returns Response Strongly-typed ODP Response object\n   */\n  private parseSegmentsResponseJson(jsonResponse: string): GraphQLResponse | null {\n    let jsonObject = {};\n\n    try {\n      jsonObject = JSON.parse(jsonResponse);\n    } catch {\n      return EMPTY_JSON_RESPONSE;\n    }\n\n    if (validate(jsonObject, OdpResponseSchema, false)) {\n      return jsonObject as GraphQLResponse;\n    }\n\n    return EMPTY_JSON_RESPONSE;\n  }\n}\n","/**\n * Copyright 2016-2017, 2020, 2022 Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { sprintf } from '../fns';\nimport { JSONSchema4, validate as jsonSchemaValidator } from 'json-schema';\n\nimport { ERROR_MESSAGES } from '../enums';\nimport schema from '../../core/project_config/project_config_schema';\n\nconst MODULE_NAME = 'JSON_SCHEMA_VALIDATOR';\n\n/**\n * Validate the given json object against the specified schema\n * @param {unknown} jsonObject The object to validate against the schema\n * @param {JSONSchema4} validationSchema Provided schema to use for validation\n * @param {boolean} shouldThrowOnError Should validation throw if invalid JSON object\n * @return {boolean} true if the given object is valid; throws or false if invalid\n */\nexport function validate(\n  jsonObject: unknown,\n  validationSchema: JSONSchema4 = schema,\n  shouldThrowOnError = true\n): boolean {\n  const moduleTitle = `${MODULE_NAME} (${validationSchema.title})`;\n\n  if (typeof jsonObject !== 'object' || jsonObject === null) {\n    throw new Error(sprintf(ERROR_MESSAGES.NO_JSON_PROVIDED, moduleTitle));\n  }\n\n  const result = jsonSchemaValidator(jsonObject, validationSchema);\n  if (result.valid) {\n    return true;\n  }\n\n  if (!shouldThrowOnError) {\n    return false;\n  }\n\n  if (Array.isArray(result.errors)) {\n    throw new Error(\n      sprintf(ERROR_MESSAGES.INVALID_DATAFILE, moduleTitle, result.errors[0].property, result.errors[0].message)\n    );\n  }\n\n  throw new Error(sprintf(ERROR_MESSAGES.INVALID_JSON, moduleTitle));\n}\n","/**\n * Copyright 2023-2024, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NodeRequestHandler } from '../../utils/http_request_handler/node_request_handler';\n\nimport { ServerLRUCache } from './../../utils/lru_cache/server_lru_cache';\n\nimport { getLogger, LogHandler, LogLevel } from '../../modules/logging';\nimport {\n  NODE_CLIENT_ENGINE,\n  CLIENT_VERSION,\n  REQUEST_TIMEOUT_ODP_EVENTS_MS,\n  REQUEST_TIMEOUT_ODP_SEGMENTS_MS,\n} from '../../utils/enums';\n\nimport { OdpManager } from '../../core/odp/odp_manager';\nimport { IOdpEventManager, OdpOptions } from '../../shared_types';\nimport { NodeOdpEventApiManager } from '../odp/event_api_manager/index.node';\nimport { NodeOdpEventManager } from '../odp/event_manager/index.node';\nimport { IOdpSegmentManager, OdpSegmentManager } from '../../core/odp/odp_segment_manager';\nimport { OdpSegmentApiManager } from '../../core/odp/odp_segment_api_manager';\nimport { OdpConfig, OdpIntegrationConfig } from '../../core/odp/odp_config';\n\ninterface NodeOdpManagerConfig {\n  clientEngine?: string,\n  clientVersion?: string,\n  logger?: LogHandler;\n  odpOptions?: OdpOptions;\n  odpIntegrationConfig?: OdpIntegrationConfig;\n}\n\n/**\n * Server-side Node Plugin for ODP Manager.\n * Note: As this is still a work-in-progress. Please avoid using the Node ODP Manager.\n */\nexport class NodeOdpManager extends OdpManager {\n  constructor(options: {\n    odpIntegrationConfig?: OdpIntegrationConfig;\n    segmentManager: IOdpSegmentManager;\n    eventManager: IOdpEventManager;\n    logger: LogHandler;\n  }) {\n    super(options);\n  }\n\n  static createInstance({\n    logger, odpOptions, odpIntegrationConfig, clientEngine, clientVersion\n  }: NodeOdpManagerConfig): NodeOdpManager {\n    logger = logger || getLogger();\n\n    clientEngine = clientEngine || NODE_CLIENT_ENGINE;\n    clientVersion = clientVersion || CLIENT_VERSION;\n\n    let odpConfig : OdpConfig | undefined = undefined;\n    if (odpIntegrationConfig?.integrated) {\n      odpConfig = odpIntegrationConfig.odpConfig;\n    }\n\n    let customSegmentRequestHandler;\n\n    if (odpOptions?.segmentsRequestHandler) {\n      customSegmentRequestHandler = odpOptions.segmentsRequestHandler;\n    } else {\n      customSegmentRequestHandler = new NodeRequestHandler(\n        logger,\n        odpOptions?.segmentsApiTimeout || REQUEST_TIMEOUT_ODP_SEGMENTS_MS\n      );\n    }\n\n    let segmentManager: IOdpSegmentManager;\n\n    if (odpOptions?.segmentManager) {\n      segmentManager = odpOptions.segmentManager;\n    } else {\n      segmentManager = new OdpSegmentManager(\n        odpOptions?.segmentsCache ||\n          new ServerLRUCache<string, string[]>({\n            maxSize: odpOptions?.segmentsCacheSize,\n            timeout: odpOptions?.segmentsCacheTimeout,\n          }),\n        new OdpSegmentApiManager(customSegmentRequestHandler, logger),\n        logger,\n        odpConfig\n      );\n    }\n\n    let customEventRequestHandler;\n\n    if (odpOptions?.eventRequestHandler) {\n      customEventRequestHandler = odpOptions.eventRequestHandler;\n    } else {\n      customEventRequestHandler = new NodeRequestHandler(\n        logger,\n        odpOptions?.eventApiTimeout || REQUEST_TIMEOUT_ODP_EVENTS_MS\n      );\n    }\n\n    let eventManager: IOdpEventManager;\n\n    if (odpOptions?.eventManager) {\n      eventManager = odpOptions.eventManager;\n    } else {\n      eventManager = new NodeOdpEventManager({\n        odpConfig,\n        apiManager: new NodeOdpEventApiManager(customEventRequestHandler, logger),\n        logger: logger,\n        clientEngine,\n        clientVersion,\n        flushInterval: odpOptions?.eventFlushInterval,\n        batchSize: odpOptions?.eventBatchSize,\n        queueSize: odpOptions?.eventQueueSize,\n        userAgentParser: odpOptions?.userAgentParser,\n      });\n    }\n\n    return new NodeOdpManager({\n      odpIntegrationConfig,\n      segmentManager,\n      eventManager,\n      logger,\n    });\n  }\n\n  public isVuidEnabled(): boolean {\n    return false;\n  }\n\n  public getVuid(): string | undefined {\n    return undefined;\n  }\n}\n","/****************************************************************************\n * Copyright 2016-2017, 2019-2024 Optimizely, Inc. and contributors         *\n *                                                                          *\n * Licensed under the Apache License, Version 2.0 (the \"License\");          *\n * you may not use this file except in compliance with the License.         *\n * You may obtain a copy of the License at                                  *\n *                                                                          *\n *    https://www.apache.org/licenses/LICENSE-2.0                           *\n *                                                                          *\n * Unless required by applicable law or agreed to in writing, software      *\n * distributed under the License is distributed on an \"AS IS\" BASIS,        *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n * See the License for the specific language governing permissions and      *\n * limitations under the License.                                           *\n ***************************************************************************/\n\nimport { getLogger, setErrorHandler, getErrorHandler, LogLevel, setLogHandler, setLogLevel } from './modules/logging';\nimport Optimizely from './optimizely';\nimport * as enums from './utils/enums';\nimport * as loggerPlugin from './plugins/logger';\nimport configValidator from './utils/config_validator';\nimport defaultErrorHandler from './plugins/error_handler';\nimport defaultEventDispatcher from './plugins/event_dispatcher/index.node';\nimport eventProcessorConfigValidator from './utils/event_processor_config_validator';\nimport { createNotificationCenter } from './core/notification_center';\nimport { createEventProcessor } from './plugins/event_processor';\nimport { OptimizelyDecideOption, Client, Config } from './shared_types';\nimport { createHttpPollingDatafileManager } from './plugins/datafile_manager/http_polling_datafile_manager';\nimport { NodeOdpManager } from './plugins/odp_manager/index.node';\nimport * as commonExports from './common_exports';\n\nconst logger = getLogger();\nsetLogLevel(LogLevel.ERROR);\n\nconst DEFAULT_EVENT_BATCH_SIZE = 10;\nconst DEFAULT_EVENT_FLUSH_INTERVAL = 30000; // Unit is ms, default is 30s\nconst DEFAULT_EVENT_MAX_QUEUE_SIZE = 10000;\n\n/**\n * Creates an instance of the Optimizely class\n * @param  {Config} config\n * @return {Client|null} the Optimizely client object\n *                           null on error\n */\nconst createInstance = function(config: Config): Client | null {\n  try {\n    let hasLogger = false;\n    let isValidInstance = false;\n\n    // TODO warn about setting per instance errorHandler / logger / logLevel\n    if (config.errorHandler) {\n      setErrorHandler(config.errorHandler);\n    }\n    if (config.logger) {\n      // only set a logger in node if one is provided, by not setting we are noop-ing\n      hasLogger = true;\n      setLogHandler(config.logger);\n      // respect the logger's shouldLog functionality\n      setLogLevel(LogLevel.NOTSET);\n    }\n    if (config.logLevel !== undefined) {\n      setLogLevel(config.logLevel);\n    }\n    try {\n      configValidator.validate(config);\n      isValidInstance = true;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (ex) {\n      if (hasLogger) {\n        logger.error(ex);\n      } else {\n        console.error(ex.message);\n      }\n    }\n\n    let eventBatchSize = config.eventBatchSize;\n    let eventFlushInterval = config.eventFlushInterval;\n\n    if (!eventProcessorConfigValidator.validateEventBatchSize(config.eventBatchSize)) {\n      logger.warn('Invalid eventBatchSize %s, defaulting to %s', config.eventBatchSize, DEFAULT_EVENT_BATCH_SIZE);\n      eventBatchSize = DEFAULT_EVENT_BATCH_SIZE;\n    }\n    if (!eventProcessorConfigValidator.validateEventFlushInterval(config.eventFlushInterval)) {\n      logger.warn(\n        'Invalid eventFlushInterval %s, defaulting to %s',\n        config.eventFlushInterval,\n        DEFAULT_EVENT_FLUSH_INTERVAL\n      );\n      eventFlushInterval = DEFAULT_EVENT_FLUSH_INTERVAL;\n    }\n\n    const errorHandler = getErrorHandler();\n    const notificationCenter = createNotificationCenter({ logger: logger, errorHandler: errorHandler });\n\n    const eventProcessorConfig = {\n      dispatcher: config.eventDispatcher || defaultEventDispatcher,\n      flushInterval: eventFlushInterval,\n      batchSize: eventBatchSize,\n      maxQueueSize: config.eventMaxQueueSize || DEFAULT_EVENT_MAX_QUEUE_SIZE,\n      notificationCenter,\n    };\n\n    const eventProcessor = createEventProcessor(eventProcessorConfig);\n\n    const odpExplicitlyOff = config.odpOptions?.disabled === true;\n    if (odpExplicitlyOff) {\n      logger.info(enums.LOG_MESSAGES.ODP_DISABLED);\n    }\n\n    const { clientEngine, clientVersion } = config;\n\n    const optimizelyOptions = {\n      clientEngine: enums.NODE_CLIENT_ENGINE,\n      ...config,\n      eventProcessor,\n      logger,\n      errorHandler,\n      datafileManager: config.sdkKey\n        ? createHttpPollingDatafileManager(config.sdkKey, logger, config.datafile, config.datafileOptions)\n        : undefined,\n      notificationCenter,\n      isValidInstance,\n      odpManager: odpExplicitlyOff ? undefined\n        : NodeOdpManager.createInstance({ logger, odpOptions: config.odpOptions, clientEngine, clientVersion }),\n    };\n\n    return new Optimizely(optimizelyOptions);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e) {\n    logger.error(e);\n    return null;\n  }\n};\n\n/**\n * Entry point into the Optimizely Node testing SDK\n */\nexport {\n  loggerPlugin as logging,\n  defaultErrorHandler as errorHandler,\n  defaultEventDispatcher as eventDispatcher,\n  enums,\n  setLogHandler as setLogger,\n  setLogLevel,\n  createInstance,\n  OptimizelyDecideOption,\n};\n\nexport * from './common_exports';\n\nexport default {\n  ...commonExports,\n  logging: loggerPlugin,\n  errorHandler: defaultErrorHandler,\n  eventDispatcher: defaultEventDispatcher,\n  enums,\n  setLogger: setLogHandler,\n  setLogLevel,\n  createInstance,\n  OptimizelyDecideOption,\n};\n\nexport * from './export_types';\n","/**\n * Copyright 2020, 2022-2023, Optimizely\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LogTierV1EventProcessor, LocalStoragePendingEventsDispatcher } from '../../modules/event_processor';\n\nexport function createEventProcessor(\n  ...args: ConstructorParameters<typeof LogTierV1EventProcessor>\n): LogTierV1EventProcessor {\n  return new LogTierV1EventProcessor(...args);\n}\n\nexport default { createEventProcessor, LocalStoragePendingEventsDispatcher };\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","pop","push","__spreadArray","to","from","pack","ar","l","slice","concat","SuppressedError","LogLevel","globalErrorHandler","NoopErrorHandler","exception","getErrorHandler","MAX_SAFE_INTEGER_LIMIT","Math","pow","target","_i","sources","index","nextSource","nextKey","keyBy","arr","key","keyByUtil","item","uuid","v4","getTimestamp","Date","getTime","isValidEnum","enumToCheck","found","keys","objectValues","obj","map","objectEntries","find","cond","arr_1","keyByFn","forEach","sprintf","format","args","replace","arg","type","checkArrayEquality","arrayA","arrayB","every","currentTimestamp","round","isSafeInteger","number","abs","isNumber","groupBy","grouperFn","grouper","stringToLogLevel","NOTSET","DEBUG","INFO","WARNING","ERROR","coerceLogLevel","level","toUpperCase","OptimizelyLogger","loggers","DefaultLogManager","name","messagePrefix","defaultLoggerFacade","config","logLevel","undefined","setLogLevel","logToConsole","prefix","ConsoleLogHandler","message","shouldLog","logMessage","getLogLevelName","consoleLog","toISOString","targetLogLevel","logArguments","console","log","info","warn","error","globalLogLevel","globalLogHandler","opts","splat","internalLog","namedLog","data","Error","handleError","last","splice","globalLogManager","getLogger","setLogHandler","logger","OptimizelySegmentOption","VariableType","OptimizelyDecideOption","action","identifiers","Map","newErrorDecision","user","reasons","variationKey","enabled","variables","ruleKey","flagKey","userContext","NOTIFICATION_TYPES","LOG_LEVEL","ERROR_MESSAGES","BROWSER_ODP_MANAGER_INITIALIZATION_FAILED","CONDITION_EVALUATOR_ERROR","DATAFILE_AND_SDK_KEY_MISSING","EXPERIMENT_KEY_NOT_IN_DATAFILE","FEATURE_NOT_IN_DATAFILE","FETCH_SEGMENTS_FAILED_NETWORK_ERROR","FETCH_SEGMENTS_FAILED_DECODE_ERROR","IMPROPERLY_FORMATTED_EXPERIMENT","INVALID_ATTRIBUTES","INVALID_BUCKETING_ID","INVALID_DATAFILE","INVALID_DATAFILE_MALFORMED","INVALID_CONFIG","INVALID_JSON","INVALID_ERROR_HANDLER","INVALID_EVENT_DISPATCHER","INVALID_EVENT_TAGS","INVALID_EXPERIMENT_KEY","INVALID_EXPERIMENT_ID","INVALID_GROUP_ID","INVALID_LOGGER","INVALID_ROLLOUT_ID","INVALID_USER_ID","INVALID_USER_PROFILE_SERVICE","LOCAL_STORAGE_DOES_NOT_EXIST","MISSING_INTEGRATION_KEY","NO_DATAFILE_SPECIFIED","NO_JSON_PROVIDED","NO_VARIATION_FOR_EXPERIMENT_KEY","ODP_CONFIG_NOT_AVAILABLE","ODP_EVENT_FAILED","ODP_FETCH_QUALIFIED_SEGMENTS_SEGMENTS_MANAGER_MISSING","ODP_IDENTIFY_FAILED_EVENT_MANAGER_MISSING","ODP_INITIALIZATION_FAILED","ODP_INVALID_DATA","ODP_EVENT_FAILED_ODP_MANAGER_MISSING","ODP_FETCH_QUALIFIED_SEGMENTS_FAILED_ODP_MANAGER_MISSING","ODP_IDENTIFY_USER_FAILED_ODP_MANAGER_MISSING","ODP_IDENTIFY_USER_FAILED_USER_CONTEXT_INITIALIZATION","ODP_MANAGER_UPDATE_SETTINGS_FAILED_EVENT_MANAGER_MISSING","ODP_MANAGER_UPDATE_SETTINGS_FAILED_SEGMENTS_MANAGER_MISSING","ODP_NOT_ENABLED","ODP_NOT_INTEGRATED","ODP_SEND_EVENT_FAILED_EVENT_MANAGER_MISSING","ODP_SEND_EVENT_FAILED_UID_MISSING","ODP_SEND_EVENT_FAILED_VUID_MISSING","ODP_VUID_INITIALIZATION_FAILED","ODP_VUID_REGISTRATION_FAILED","ODP_VUID_REGISTRATION_FAILED_EVENT_MANAGER_MISSING","UNDEFINED_ATTRIBUTE","UNRECOGNIZED_ATTRIBUTE","UNABLE_TO_CAST_VALUE","USER_NOT_IN_FORCED_VARIATION","USER_PROFILE_LOOKUP_ERROR","USER_PROFILE_SAVE_ERROR","VARIABLE_KEY_NOT_IN_DATAFILE","VARIATION_ID_NOT_IN_DATAFILE","VARIATION_ID_NOT_IN_DATAFILE_NO_EXPERIMENT","INVALID_INPUT_FORMAT","INVALID_DATAFILE_VERSION","INVALID_VARIATION_KEY","LOG_MESSAGES","ACTIVATE_USER","DISPATCH_CONVERSION_EVENT","DISPATCH_IMPRESSION_EVENT","DEPRECATED_EVENT_VALUE","EVENT_KEY_NOT_FOUND","EXPERIMENT_NOT_RUNNING","FEATURE_ENABLED_FOR_USER","FEATURE_NOT_ENABLED_FOR_USER","FEATURE_HAS_NO_EXPERIMENTS","FAILED_TO_PARSE_VALUE","FAILED_TO_PARSE_REVENUE","FORCED_BUCKETING_FAILED","INVALID_OBJECT","INVALID_CLIENT_ENGINE","INVALID_DEFAULT_DECIDE_OPTIONS","INVALID_DECIDE_OPTIONS","INVALID_VARIATION_ID","NOTIFICATION_LISTENER_EXCEPTION","NO_ROLLOUT_EXISTS","NOT_ACTIVATING_USER","NOT_TRACKING_USER","ODP_DISABLED","ODP_IDENTIFY_FAILED_ODP_DISABLED","ODP_IDENTIFY_FAILED_ODP_NOT_INTEGRATED","ODP_SEND_EVENT_IDENTIFIER_CONVERSION_FAILED","PARSED_REVENUE_VALUE","PARSED_NUMERIC_VALUE","RETURNING_STORED_VARIATION","ROLLOUT_HAS_NO_EXPERIMENTS","SAVED_VARIATION","SAVED_VARIATION_NOT_FOUND","SHOULD_NOT_DISPATCH_ACTIVATE","SKIPPING_JSON_VALIDATION","TRACK_EVENT","UNRECOGNIZED_DECIDE_OPTION","USER_ASSIGNED_TO_EXPERIMENT_BUCKET","USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP","USER_BUCKETED_INTO_TARGETING_RULE","USER_IN_FEATURE_EXPERIMENT","USER_IN_ROLLOUT","USER_NOT_BUCKETED_INTO_EVERYONE_TARGETING_RULE","USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP","USER_NOT_BUCKETED_INTO_ANY_EXPERIMENT_IN_GROUP","USER_NOT_BUCKETED_INTO_TARGETING_RULE","USER_NOT_IN_FEATURE_EXPERIMENT","USER_NOT_IN_ROLLOUT","USER_FORCED_IN_VARIATION","USER_MAPPED_TO_FORCED_VARIATION","USER_DOESNT_MEET_CONDITIONS_FOR_TARGETING_RULE","USER_MEETS_CONDITIONS_FOR_TARGETING_RULE","USER_HAS_VARIATION","USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED","USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED","USER_HAS_FORCED_DECISION_WITH_RULE_SPECIFIED_BUT_INVALID","USER_HAS_FORCED_DECISION_WITH_NO_RULE_SPECIFIED_BUT_INVALID","USER_HAS_FORCED_VARIATION","USER_HAS_NO_VARIATION","USER_HAS_NO_FORCED_VARIATION","USER_HAS_NO_FORCED_VARIATION_FOR_EXPERIMENT","USER_NOT_IN_ANY_EXPERIMENT","USER_NOT_IN_EXPERIMENT","USER_RECEIVED_DEFAULT_VARIABLE_VALUE","FEATURE_NOT_ENABLED_RETURN_DEFAULT_VARIABLE_VALUE","VARIABLE_NOT_USED_RETURN_DEFAULT_VARIABLE_VALUE","USER_RECEIVED_VARIABLE_VALUE","VALID_DATAFILE","VALID_USER_PROFILE_SERVICE","VARIATION_REMOVED_FOR_USER","VARIABLE_REQUESTED_WITH_WRONG_TYPE","VALID_BUCKETING_ID","BUCKETING_ID_NOT_STRING","EVALUATING_AUDIENCE","EVALUATING_AUDIENCES_COMBINED","AUDIENCE_EVALUATION_RESULT","AUDIENCE_EVALUATION_RESULT_COMBINED","MISSING_ATTRIBUTE_VALUE","UNEXPECTED_CONDITION_VALUE","UNEXPECTED_TYPE","UNEXPECTED_TYPE_NULL","UNKNOWN_CONDITION_TYPE","UNKNOWN_MATCH_TYPE","UPDATED_OPTIMIZELY_CONFIG","OUT_OF_BOUNDS","UNABLE_TO_ATTACH_UNLOAD","CONTROL_ATTRIBUTES","BOT_FILTERING","BUCKETING_ID","STICKY_BUCKETING_KEY","USER_AGENT","FORCED_DECISION_NULL_RULE_KEY","DECISION_NOTIFICATION_TYPES","AB_TEST","FEATURE","FEATURE_TEST","FEATURE_VARIABLE","ALL_FEATURE_VARIABLES","FLAG","DECISION_SOURCES","ROLLOUT","EXPERIMENT","AUDIENCE_EVALUATION_TYPES","RULE","FEATURE_VARIABLE_TYPES","BOOLEAN","DOUBLE","INTEGER","STRING","JSON","DATAFILE_VERSIONS","V2","V3","V4","DECISION_MESSAGES","SDK_NOT_READY","FLAG_KEY_INVALID","VARIABLE_VALUE_INVALID","ODP_USER_KEY","ODP_EVENT_ACTION","_a","optimizely","userId","attributes","_b","shouldIdentifyUser","forcedDecisionsMap","onReady","_this","identifyUser","OptimizelyUserContext","_qualifiedSegments","qualifiedSegments","options","decide","cloneUserContext","decideForKeys","decideAll","eventName","eventTags","track","context","decision","forcedDecision","findForcedDecision","isForcedDecisionRemoved","validRuleKey","forcedDecisionByRuleKey","getOptimizely","getUserId","getAttributes","fetchQualifiedSegments","segments","segment","indexOf","DEFAULT_OPERATOR_TYPES","evaluate","conditions","leafEvaluator","isArray","firstOperator","restOfConditions","sawNullResult","conditionResult","andEvaluator","notEvaluator","orEvaluator","configObj","datafile","sdkKey","environmentKey","audiences","OptimizelyConfig","getAudiences","events","revision","featureIdVariablesMap","featureFlags","reduce","resultMap","feature","id","variableIdMap","getVariableIdMap","_c","getExperimentsMap","experimentsMapById","experimentsMapByKey","experimentsMap","featuresMap","getFeaturesMap","typedAudienceIds","typedAudiences","typedAudience","stringify","audience","audiencesById","serializedAudience","cond_1","subAudience","getSerializedAudiences","audienceName","experiment","audienceConditions","featureIdVariableMap","featureId","featureVariableUsages","isFeatureEnabled","variablesMap","optlyVariablesMap","featureVariable","defaultValue","featureVariableUsage","defaultVariable","optimizelyVariable","variations","optlyVariationsMap","variation","mergeFeatureVariables","featureEnabled","variable","featureVariableIdMap","experiments","getExperimentAudiences","variationsMap","getVariationsMap","rollouts","experimentIds","rollout","rolloutExperimentIds","getRolloutExperimentIds","featureIds","experimentFeatureMap","toString","optimizelyExperiment","experimentKeysMap","featureFlag","featureExperimentMap","experimentRules","experimentId","featureVariableMap","deliveryRules","rolloutIdMap","rolloutId","getDeliveryRules","MODULE_NAME","SUPPORTED_VERSIONS","errorHandler","eventDispatcher","parse","ex","apiKey","apiHost","pixelUrl","segmentsToCheck","OdpConfig","configToCompare","createProjectConfig","datafileObj","datafileStr","datafileCopy","projectConfig","groups","group","groupCopy","rolloutCopy","__datafileStr","attributeKeyMap","eventKeyMap","groupIdMap","Id","groupId","variationKeyMap","allSegmentsSet","Set","getAudienceSegments","audienceSegments","add","allSegments","odpIntegrated","odpApiHost","odpApiKey","odpPixelUrl","integrations","integrationKeyMap","integration","publicKey","host","odpIntegrationConfig","integrated","odpConfig","experimentKeyMap","experimentIdMap","variationIdMap","variationVariableUsageMap","featureKeyMap","subType","variableKeyMap","flagRulesMap","flagRuleExperiments","flagVariationsMap","rules","rule","getSegmentsFromConditions","condition","includes","isLogicalOperator","nextCondition","getLayerId","layerId","getAttributeId","attributeKey","attribute","hasReservedPrefix","getEventId","eventKey","event","getExperimentStatus","experimentKey","status","getVariationKeyFromId","variationId","getExperimentFromKey","getTrafficAllocation","trafficAllocation","getExperimentFromId","getFlagVariationByKey","getFeatureFromKey","featureKey","toDatafile","tryCreatingProjectConfig","newDatafileObj","configValidator","jsonSchemaValidator","validate","createProjectConfigArgs","getSendFlagDecisionsValue","sendFlagDecisions","scheduleMicrotaskOrTimeout","callback","queueMicrotask","setTimeout","getErrorMessage","maybeError","defaultMessage","datafileAndSdkKeyMissingError","readyPromise","success","reason","handleNewDatafileException","handleNewDatafile","datafileManager","start","onDatafileManagerReadyFulfill","bind","onDatafileManagerReadyReject","on","onDatafileManagerUpdate","ProjectConfigManager","newDatafileError","get","err","newDatafile","oldRevision","optimizelyConfigObj","updateListeners","listener","createOptimizelyConfig","stop","MAX_HASH_VALUE","bucket","bucketerParams","decideReasons","policy","bucketedExperimentId","bucketUserIntoExperiment","bucketingId","bucketValue","_generateBucketValue","entityId","_findBucket","trafficAllocationConfig","bucketingKey","endOfRange","ratio","murmurhash","v3","floor","content","test","isPreReleaseVersion","version","preReleaseIndex","buildIndex","isBuildVersion","splitVersion","targetPrefix","targetSuffix","hasWhiteSpaces","substring","dotCount","split","targetVersionParts","targetVersionParts_1","MATCH_TYPES","EVALUATORS_BY_MATCH_TYPE","isValueTypeValidForExactConditions","fns","exactEvaluator","userAttributes","conditionValue","conditionValueType","conditionName","userValue","userValueType","debug","validateValuesForNumericCondition","evaluateSemanticVersion","conditionsVersion","userProvidedVersion","userVersionParts","conditionsVersionParts","userVersionPartsLen","idx","userVersionPart","parseInt","conditionsVersionPart","compareVersion","conditionMatch","match","qualifiedEvaluator","isQualifiedFor","UNSTABLE_conditionEvaluators","typeToEvaluatorMap","custom_attribute","customAttributeConditionEvaluator","third_party_dimension","odpSegmentsConditionEvaluator","AudienceEvaluator","conditionTreeEvaluator.evaluate","audienceId","evaluateConditionWithUserAttributes","resultText","evaluator","input","audienceEvaluator","forcedVariationMap","userProfileService","DecisionService","getBucketingId","checkIfExperimentIsActive","decisionForcedVariation","getForcedVariation","forcedVariationKey","decisionWhitelistedVariation","getWhitelistedVariation","shouldIgnoreUPS","IGNORE_USER_PROFILE_SERVICE","experimentBucketMap","resolveExperimentBucketMap","getStoredVariation","decisionifUserIsInAudience","checkIfUserIsInAudience","buildBucketerParams","decisionVariation","saveUserProfile","userProfile","getUserProfile","attributeExperimentBucketMap","experiment_bucket_map","isActive","forcedVariations","evaluationAttribute","loggingKey","experimentAudienceConditions","audienceIds","getExperimentAudienceConditions","variation_id","user_id","lookup","save","getVariationForFeatureExperiment","experimentDecision","decisionRolloutVariation","getVariationForRollout","rolloutDecision","getVariationFromExperimentRule","decisionSource","skipToEveryoneElse","rolloutRules","getVariationFromDeliveryRule","getForcedDecision","experimentToVariationMap","stringValidator.validate","removeForcedVariation","getVariationIdFromExperimentAndVariationKey","setInForcedVariationMap","forcedDecisionResponse","findValidatedForcedDecision","forcedVariation","getVariation","ruleIndex","bucketerVariationId","everyoneElse","bucketedVariation","getRevenueValue","rawValue","parsedRevenueValue","isFinite","getEventValue","parsedEventValue","parseFloat","isAttributeValid","attributeValue","ENDPOINT","getCommonEventParams","clientEngine","clientVersion","anonymize_ip","anonymizeIP","botFiltering","visitor","snapshots","visitor_id","commonParams","account_id","accountId","project_id","projectId","visitors","client_name","client_version","enrich_decisions","attributeId","entity_id","getImpressionEvent","ruleType","campaignId","impressionEventParams","decisions","campaign_id","experiment_id","metadata","flag_key","rule_key","rule_type","variation_key","timestamp","httpVerb","url","params","getConversionEvent","snapshot","eventDict","revenue","eventTagUtils.getRevenueValue","eventValue","eventTagUtils.getEventValue","getVisitorSnapshot","getExperimentKey","decisionObj","getVariationKey","getFeatureEnabledFromVariation","getExperimentId","getVariationId","buildVisitorAttributes","builtAttributes","attributesValidator.isAttributeValid","notificationListeners","notificationTypeEnum","listenerId","NotificationCenter","notificationType","callbackAlreadyAdded_1","listenerEntry","returnId","indexToRemove_1","typeToRemove_1","some","notificationData","createNotificationCenter","NotificationRegistry","notificationCenter","_notificationCenters","has","set","clearAllNotificationListeners","delete","isOptimizelyConfigValid","isValidInstance","odpManager","decideOptionsArray","defaultDecideOptions","option","projectConfigManager","createProjectConfigManager","disposeOnUpdate","onUpdate","sendNotifications","OPTIMIZELY_CONFIG_UPDATE","updateOdpSettings","projectConfigManagerReadyPromise","userProfileServiceInstance","userProfileServiceValidator.validate","decisionService","eventProcessor","eventProcessorStartedPromise","all","promiseResults","readyTimeouts","nextReadyTimeoutId","Optimizely","getConfig","validateInputs","experiment_key","notActivatingExperiment","projectConfig.isRunning","projectConfig.getExperimentFromKey","sendImpressionEvent","impressionEvent","decision.getExperimentKey","decision.getExperimentId","decision.getVariationKey","decision.getVariationId","clientName","layer","buildImpressionEvent","process","emitNotificationCenterActivate","ACTIVATE","logEvent","event_key","projectConfig.eventWithKeyExists","conversionEvent","eventId","tags","buildConversionEvent","filterEmptyValues","emitNotificationCenterTrack","TRACK","createInternalUserContext","decisionNotificationType","DECISION","decisionInfo","setForcedVariation","stringInputs","eventTagsValidator.validate","feature_key","projectConfig.getFeatureFromKey","sourceInfo","getVariationForFeature","decision.getFeatureEnabledFromVariation","projectConfig.getSendFlagDecisionsValue","featureInfo","source","enabledFeatures_1","variableKey","getFeatureVariableForType","variableType","variable_key","projectConfig.getVariableForFeature","variableValue","getFeatureVariableValueFromVariation","variableUsage","projectConfig.getVariableValueForVariation","castValue","isNaN","projectConfig.getTypeCastValue","decisionObj_1","featureEnabled_1","allVariables_1","variableValues","getOptimizelyConfig","removeNotificationCenter","eventProcessorStoppedPromise","readyTimeoutId","readyTimeoutRecord","clearTimeout","readyTimeout","onClose","timeoutValue","resolveTimeoutPromise","timeout","timeoutPromise","timeoutId","race","userIdentifier","getVuid","allDecideOptions","getAllDecideOptions","flagEnabled","decisionEventDispatched","EXCLUDE_VARIABLES","DISABLE_DECISION_EVENT","reportedReasons","INCLUDE_REASONS","decisionMap","optimizelyDecision","ENABLED_FLAGS_ONLY","allFlagKeys","updateSettings","odpEventType","odpIdentifiers","size","identifier_value","identifier_key","toLowerCase","FS_USER_ID","odpEvent","OdpEvent","sendEvent","isOdpIntegrated","isVuidEnabled","NoOpLogger","createLogger","dispatchEvent","eventObj","parsedUrl","dataString","requestOptions","path","method","headers","content-type","content-length","reqWrapper","req","protocol","http","https","request","response","statusCode","destroy","write","end","eventBatchSize","eventFlushInterval","areEventContextsEqual","eventA","eventB","contextA","contextB","max","Timer","sink","SingleEventQueue","flushInterval","maxQueueSize","closingSink","batchComparator","buffer","timer","flush","started","DefaultEventQueue","bufferedEvent","refresh","maxValues","LS_KEY","LocalStorageStore","getMap","window","localStorage","setItem","clean","toRemove","entries","sort","a","getItem","_super","store","dispatcher","PendingEventsDispatcher","send","pendingEvents","values","entry","remove","makeBatchedEventV1","attr","makeVisitor","makeDecisionSnapshot","conversion","makeConversionSnapshot","RequestTracker","reqPromise","reqsInFlightCount","onReqComplete","reqsCompleteResolvers","resolver","closingDispatcher","batchSize","requestTracker","validateAndGetFlushInterval","validateAndGetBatchSize","queue","getQueue","drainQueue","LogTierV1EventProcessor","useClosingDispatcher","notificationSender","formattedEvent","LOG_EVENT","trackRequest","enqueue","onRequestsComplete","UPDATE_INTERVAL_BELOW_MINIMUM_MESSAGE","BACKOFF_BASE_WAIT_SECONDS_BY_ERROR_COUNT","createHeadersFromNodeIncomingMessage","incomingMessage","headerName","headerValue","makeGetRequest","reqUrl","requester","responsePromise","abort","hostname","port","getRequestOptionsFromUrl","accept-encoding","once","aborted","decompressResponse","setEncoding","responseData","chunk","getResponseFromRequest","EventEmitter","listeners","currentListenerId","BackoffController","errorCount","min","random","isSuccessStatusCode","noOpKeyValueCache","contains","configWithDefaultsApplied","getConfigDefaults","autoUpdate","updateInterval","DEFAULT_UPDATE_INTERVAL_MINUTES","urlTemplate","_d","cache","cacheKey","isReadyPromiseSettled","readyPromiseResolver","readyPromiseRejecter","currentDatafile","resolveReadyPromise","isStarted","datafileUrl","emitter","MIN_UPDATE_INTERVAL_SECONDS","currentTimeout","currentRequest","backoffController","syncOnCurrentRequestComplete","HttpPollingDatafileManager","reset","setDatafileFromCacheIfAvailable","syncDatafile","removeAllListeners","countError","trySavingLastModified","getNextDatafileFromResponse","datafileUpdate","getNotificationCenter","emit","rejectReadyPromise","lastResponseLastModified","onRequestComplete","onRequestResolved","onRequestRejected","scheduleNextUpdate","currentBackoffDelay","getDelay","nextUpdateDelay","lastModifiedHeader","defaultUrlTemplate","datafileAccessToken","accessToken","NodeDatafileManager","requestHeaders","createHttpPollingDatafileManager","datafileOptions","datafileManagerConfig","NodeRequestHandler","requestUrl","abortableRequest","getAbortableRequestFromRequest","_value","_time","now","CacheElement","maxSize","_maxSize","_timeout","LRUCache","_map","element","is_stale","firstMapEntryKey","clear","ServerLRUCacheConfig","_vuid","VuidManager","_instance","load","_keyForVuid","cachedValue","isVuid","makeVuid","formatted","vuidFull","vuid_prefix","vuid","startsWith","invalidOdpDataFound","validTypes","foundInvalidValue","Status","noop","promise","segmentManager","eventManager","Stopped","configPromise","res","rej","readinessDependencies","initializeVuid","initPromise","ready","Running","registerVuid","OdpManager","config1","config2","equals","VUID","mType","NodeOdpEventApiManager","endpoint","Content-Type","x-api-key","replacer","fromEntries","requestHandler","OdpEventApiManager","shouldRetry","shouldSendEvents","generateRequestData","makeRequest","err_1","apiManager","queueSize","userAgentParser","retries","initParams","parseUserAgentInfo","os","device","userAgentInfo","os_version","device_type","model","userAgentData","filter","OdpEventManager","processQueue","setNewTimeout","clearCurrentTimeout","INITIALIZED","IDENTIFIED","augmentCommonData","hasNecessaryIdentifiers","shouldFlush","queueContainsItems","makeAndSend1Batch","queueHasBatches","batch","attemptNumber","sendEvents","sourceData","NodeOdpEventManager","segmentsCache","odpSegmentApiManager","_segmentsCache","OdpSegmentManager","userKey","makeCacheKey","ignoreCache","IGNORE_CACHE","resetCache","RESET_CACHE","cachedSegments","fetchSegments","schema","$schema","title","properties","required","items","OdpResponseSchema","$id","customer","edges","node","examples","state","errors","default","locations","line","column","extensions","classification","EMPTY_SEGMENTS_COLLECTION","join","OdpSegmentApiManager","query","toGraphQLJson","querySegments","segmentsResponse","_f","parsedSegments","parseSegmentsResponseJson","_e","code","edge","jsonResponse","jsonObject","validationSchema","shouldThrowOnError","moduleTitle","valid","property","NodeOdpManager","odpOptions","customSegmentRequestHandler","customEventRequestHandler","segmentsRequestHandler","segmentsApiTimeout","ServerLRUCache","segmentsCacheSize","segmentsCacheTimeout","eventRequestHandler","eventApiTimeout","eventQueueSize","createInstance","handler","hasLogger","eventProcessorConfigValidator","createEventProcessor","defaultEventDispatcher","eventMaxQueueSize","odpExplicitlyOff","disabled","enums.LOG_MESSAGES","optimizelyOptions","commonExports","logging","loggerPlugin","defaultErrorHandler","enums","setLogger"],"mappings":"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"}